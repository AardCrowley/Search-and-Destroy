<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE muclient>
<!-- Saved on Saturday, July 05, 2008, 4:46 PM -->
<muclient> 
<plugin version="4.57" name="Search_and_Destroy" id="30000000537461726C696E67" date_written="2018-12-31 23:00:00" author="Crowley, branched from Starling" language="Lua" purpose="Safe, legal Search and Destroy" save_state="y" requires="4.90" >
<description trim="n"> </description> </plugin>

<!-- Isolinear intermatrix (utility module) -->
<include name="constants.lua"/>
<variables><variable name="example"></variable></variables>

<timers>
	<timer name="tim_init_plugin"
		second="0.5" active_closed="y"
		script="init_plugin" 
		enabled="y" send_to="12" > </timer>
		
	<timer name="execute_in_area_timer"
		second="0.1" 
		script=""
		enabled="n" send_to="12">
			<send>	execute_in_area_tick() </send> </timer>
		
	<timer name="vidblain_nav_timer"
		second="0.1" 
		script=""
		enabled="n" send_to="12">
			<send>	vidblain_nav_tick() </send> </timer>
</timers>

<script>
<![CDATA[
--Line 152
	-- This script was originally improved upon by Starling. Credit is due to Starling for the job she did on the plugin in the past, but in order to ensure future compliance with Aardwolf and MUSHclient, maintenance will now be provided by me. If you have any questions, feel free to shoot me a message on Personal or through tells. I'll make changes as I see fit to the code. // Crowley

	--[[ ToDo List:
		* Move 'hiding' mobs further down the list
		* Add a mob database
		* Add ability to keyword mobs, tie in with mob database
		* Change way XRT works - if no shortname found, run to best matching area ]]--
    
	--require "copytable"
	require "movewindow"
	require "serialize"
	require "tprint"
	require "wait"

	function mapFind(query)
		return CallPlugin("b6eae87ccedd84f510b74714", "map_find_query", query)
	end

--line 171

	PLUGIN_VERSION  = GetPluginInfo(GetPluginID(), 19)
	PLUGIN_NAME 	= GetPluginInfo(GetPluginID(), 1)
	
	local current_sd_version 		= "Search & Destroy v" .. PLUGIN_VERSION
	local plugin_id_gmcp_handler 	= "3e7dedbe37e44942dd46d264"		-- easier to remember the var names than the plugin id's
	local plugin_id_gmcp_mapper		= "b6eae87ccedd84f510b74714"
	local plugin_id_z_order 		= "462b665ecb569efbf261422f"
	 
	local main_color_table = {	["gr1"] = "#00C040", ["gr2"] = "#90EE90", ["gr3"] = "#006000",
								["gy1"] = "#808080", ["gy2"] = "#484848", ["gy3"] = "#404040",
								["or1"] = "#FF8000", ["or2"] = "#FF5000", ["or3"] = "#FF3000",
								["wh1"] = "#E0E0E0", ["wh2"] = "#F0F0F0", }
	
	local plugins_folder = GetPluginInfo(GetPluginID(), 20)
	local db_file_1
	local db_file_2
	local mapper_db_file = GetInfo(66)..WorldName()..".db"	-- typically aardwolf.db, normally found in main Mushclient folder
	--local sd_db_file = GetPluginInfo(GetPluginID(), 20) .. "sddb.db"	-- sddb.db, normally found in MUSHClient/worlds/plugins folder

-- [[ Current, previous room data GMCP_room_info ]]
	local current_room  = { rmid = "-1", arid = "-1", maze = "no", exits = {} }
	local previous_room = { rmid = "-2", arid = "-2", maze = "no", exits = {} }
	local room_history = { }
	
-- [[ player status ]]
	local current_character_state = "0"		
	
-- [[ Execute in area, room ]]
	local execute_in_area_tbl = { i=0, j=0, arid="", f="", stat=1 }
	local execute_in_room_tbl = { i=0, j=0, rmid="", f="", stat=1 }
	local vidblain_nav_tbl    = { i=0, j=0, rmid="", f="", stat=1 }
	
-- [[ main target data / current activity type ]]
	local main_target_list = {}
	local room_targets_ignored = {}
	local area_room_type = "init"
	local current_activity = "init"	-- valid: cp, gq, init, none = "init"
	
-- [[ campaign data (cpmd) ]]
	local cp_info_level = tonumber(GetVariable("mcvar_cp_level_taken")) or 0
	local cp_info_list = {}
	local cp_check_list = {}
	local last_cp_check = os.clock()
	
-- [[cp status, etc. ]]	
	local can_get_new_cp = "no"
	local player_on_cp = "no"
	
-- [[ gquest data ]]
	local gqid_declared = GetVariable("mcvar_gqid_declared") or "-1"
	local gqid_joined = GetVariable("mcvar_gqid_joined") or "-1"
	local gqid_started = GetVariable("mcvar_gqid_started") or "-1"
	local gqid_extended = GetVariable("mcvar_gqid_extended") or "-1"
	local player_on_gq = "no"
	local gq_info_list = {}
	local gq_check_list = {}
	local last_gq_check = os.clock()	
	local gq_info_minlvl = tonumber(GetVariable("mcvar_gq_info_minlvl")) or 0
	local gq_info_maxlvl = tonumber(GetVariable("mcvar_gq_info_maxlvl")) or 0
	local gq_info_efflvl = tonumber(GetVariable("mcvar_gq_info_efflvl")) or 0

-- [[ current target data - cp, gq, quest ]]
	local xcp_index = 0
	local quest_target = {}	-- {qmob = "", area = "", room = "", keyword="", status="0"}
	local short_mob_name = -1
	local full_mob_name = -1
	
-- [[ xcp action mode ]]
	local xcp_action_mode = GetVariable("mcvar_xcp_action_mode") or "qw"
	local xcp_next_onoff = GetVariable("mcvar_xcp_next_onoff") or "off"
	
-- [[ goto/nx data ]]
	local gotoArea = -1
	local gotoIndex = 0
	local gotoList = {}
	local next_room = -1

-- [[ auto-hunt ]]
	local auto_hunt_dir = ""
	local auto_hunt_mob = ""
	local autoHuntData = {}
	
-- [[ hunt trick ]]
	local ht = { index = 1 }
	
-- [[ quick where ]]
	local qw = { index = 1 }

-- [[ quick kill ]]
	local quick_kill_command = GetVariable("mcvar_quick_kill_command") or "k"
	
-- [[ automatic noexp ]]
	local anex_tnl_cutoff = tonumber(GetVariable("mcvar_anex_tnl_cutoff")) or 0
	local noexp_onoff = "off"
	local anex_automatic_onoff = GetVariable("mcvar_anex_automatic_onoff") or "on"
	
-- [[ Vidblain navigation ]]
	local xset_vidblain_level = tonumber(GetVariable("mcvar_xset_vidblain_level")) or 300
	local xset_vidblain_onoff = GetVariable("mcvar_xset_vidblain_onoff") or "off"
	
-- [[ Variables from old Mapper Extender ]]
	local area_range_index = {}
	local area_start_rooms = {}
	local last_area = ""
	local mapper_area_index = 0
	local speed = "run"
	local start_room_type
	
-- [[ Variables from old Search and Destroy ]]
	local dir_map = { north = "n", south = "s", east = "e", west = "w", up = "u", down = "d" }

-- [[ game time data ]]
	local gCycle 
	local gYear
	local gYearName
	local gSeason
	local gDay
	local gHour

-- [[ Log players ]]
	local logplayer_table = {}
	local logplayer_levels
	local logplayer_hours
	local logplayer_stats
	local logplayer_qp
	local logplayer_timestamp
	local logplayer_datestamp 

-- [[ S&D window data ]]
	local win = "sd_window_" .. GetPluginID()
	local windowinfo
	local win_pos_x = tonumber(GetVariable("mcvar_window_pos_x")) or 0			-- window position x,y coordinates
	local win_pos_y = tonumber(GetVariable("mcvar_window_pos_y")) or 0
	local win_width = tonumber(GetVariable("mcvar_window_width")) or 325
	local win_width_min = 325
	local win_width_max = tonumber(GetVariable("mcvar_window_width_max")) or win_width_min
	local win_height = tonumber(GetVariable("mcvar_window_height")) or 280
	local win_height_min = 60
	local win_height_max = tonumber(GetVariable("mcvar_window_height_max")) or 280
	local win_dragmove_start_x
	local win_dragmove_start_y
	local win_state = GetVariable("mcvar_window_state") or "max"
	local win_init = false
	local win_line_space = tonumber(GetVariable("mcvar_window_line_space")) or 14
	local win_font_size = tonumber(GetVariable("mcvar_window_font_size")) or 8
	local win_hotspots = {}
	local win_target_hotspots = {}

-- [[ S&D window color data]]
	local win_bgcolor = 0x000000
	
--	[[ Plugin broadcast/receive process ]]
	function OnPluginBroadcast(msg, id, name, text)
		if (id == plugin_id_gmcp_handler) then
			if (text == "char.status") then		-- character status
				current_character_state = gmcp("char.status.state")
			elseif (text == "room.info") then	-- current/previous room info
				local ri = gmcp("room.info")
				ri.maze = (string.match(ri.details, "maze") == "maze") and 1 or 0
				previous_room = current_room or { rmid="-2", arid="-2" }
				current_room = { rmid = ri.num, arid = ri.zone, exits = ri.exits, maze = ri.maze } or {}
				if (current_room.rmid == previous_room.rmid) then
					-- do nothing
				else
					if (#room_history == 300) then
						room_history[300] = nil
					end
					table.insert(room_history, 1, room_history[0])
					room_history[0] = { rmid = current_room.rmid, arid=current_room.arid }
				end
				--ColourNote("#808080", "", "room: " .. current_room.rmid .. ", prev: " .. previous_room.rmid .. "  ", ((ri.maze==1) and "#FF0000" or "#808080"), "", "maze: " .. current_room.maze)
			elseif (text == "comm.quest") then	-- quest info
				local q = gmcp("comm.quest")
				quest_status_gmcp(q)
			elseif (text == "config") then		-- config data, needed for automatic noexp
				noexp_onoff = (gmcp("config.noexp") == "YES") and "on" or "off"
			end
		end
	end
	
-- [[ Plugin installation ]]
	function OnPluginInstall()
		ColourNote("#808080", "", "\n+=================================================================+")
		ColourNote("#FF3000", "", "    " .. current_sd_version .. " installed at " .. os.time() )
		print("")
		ColourNote("#FF3000", "", "    " .. "For support, contact Crowley" )
		ColourNote("#808080", "", "+=================================================================+\n")
		windowinfo = movewindow.install (win, miniwin.pos_center, miniwin.create_absolute_location, false, nil, {mouseup=MouseUp, mousedown=LeftClickOnly, dragmove=LeftClickOnly, dragrelease=LeftClickOnly},{x=win_pos_x, y=win_pos_y})
		xg_create_window()
	--	db = assert(sqlite3.open(sd_db_file))
		--if not db then db = assert (sqlite3.open(dbPath)) end
		--DebugNote("opened WinkleGold_Database.db")
		--print(sql_table_exists("mobs"))
	--	if not sql_table_exists("mobs") then
	--	--DebugNote("No tables found in database, creating fresh structure.")
	--		create_sddb_tables()
	--		--print("create sql tables")
	--	else
	--		--print("no create sql tables")
	--	end
	--	db:close()
	end
	
	local init_called = 0
	function init_plugin()
		if not IsConnected() then return end
		local ch_state = current_character_state
		if ((ch_state ~= "3") and (ch_state ~= "8") and (ch_state ~= "9") and (ch_state ~= "11")) then
			send_gmcp_packet("request char")
			return
		end
		send_gmcp_packet("request room")
		init_called = init_called + 1
		if (init_called == 2) then
			EnableTimer("tim_init_plugin", false)
			load_saved_table_data()
			send_gmcp_packet("config noexp")
		end
	end

-- [[ Lookup table:  Area start room, noquest true/false, vidblain areas ]]
	local areaDefaultStartRooms = {			
		["abend"] 		= { start = "24909", ct = "3" },		-- Continents
		["alagh"] 		= { start =  "3224", ct = "4", noquest = true },
		["gelidus"] 	= { start = "18780", ct = "2", noquest = true },
		["mesolar"] 	= { start = "12664", ct = "0", noquest = true },
		["southern"] 	= { start =  "5192", ct = "1", noquest = true },
		["uncharted"] 	= { start =  "7701", ct = "5", noquest = true },
		["vidblain"] 	= { start = "33570", ct = "6", noquest = true, vidblain = true },
	
		["aardington"] 	= { start = "47509" },		-- A --
		["academy"] 	= { start = "35233" },
		["adaldar"] 	= { start = "34400" },
		["afterglow"] 	= { start = "38134" },
		["agroth"] 		= { start = "11027" },
		["ahner"] 		= { start = "30129" },
		["alehouse"] 	= { start =   "885" },
		["amazon"] 		= { start =  "1409" },
		["amusement"] 	= { start = "29282" },
		["andarin"] 	= { start =  "2399" },
		["annwn"] 		= { start = "28963" },
		["anthrox"] 	= { start =  "3993" }, 
		["arboretum"] 	= { start = "39100" }, 
		["arena"] 		= { start = "25768" },
		["arisian"] 	= { start = "28144" },
		["ascent"] 		= { start = "43150" },
		["astral"] 		= { start = "27882" },
		["atlantis"] 	= { start = "10573" },
		["autumn"] 		= { start = "13839" },
		["avian"] 		= { start =  "4334" },
		["aylor"] 		= { start = "32418" },
		["bazaar"] 		= { start = "34454" },		-- B --
		["beer"] 		= { start = "20062" },
		["believer"] 	= { start = "25940" },
		["blackrose"] 	= { start =  "1817" },
		["bliss"] 		= { start = "29988" },
		["bonds"] 		= { start = "23411" },
		["caldera"] 	= { start = "26341" },		-- C --
		["callhero"] 	= { start = "33031" },
		["camps"] 		= { start =  "4714" },
		["canyon"] 		= { start = "25551" },
		["caravan"] 	= { start = "16071" },
		["cards"] 		= { start =  "6255" },
		["carnivale"] 	= { start = "28635" },
		["cataclysm"] 	= { start = "19976" },
		["cathedral"] 	= { start = "27497" },
		["cats"] 		= { start = "40900" },
		["chasm"] 		= { start = "29446" },
		["chessboard"]	= { start = "25513" },
		["childsplay"] 	= { start =   "678" },
		["cineko"] 		= { start =  "1507" },
		["citadel"] 	= { start = "14963" },
		["conflict"] 	= { start = "27711" },
		["coral"] 		= { start =  "4565" },
		["cougarian"] 	= { start = "14311" },
		["cove"] 		= { start = "49941" },
		["cradle"] 		= { start = "11267" },
		["crynn"] 		= { start = "43800" },
		["damned"] 		= { start = "10469" },		-- D --
		["darklight"] 	= { start = "19642", vidblain = true },
		["darkside"] 	= { start = "15060" },
		["ddoom"] 		= { start =  "4193" },
		["deadlights"] 	= { start = "16856" },
		["deathtrap"] 	= { start =  "1767" },
		["deneria"] 	= { start = "35006" },
		["desert"] 		= { start = "20186" },
		["desolation"] 	= { start = "19532" },
		["dhalgora"] 	= { start = "16755" },
		["diatz"] 		= { start =  "1254" },
		["diner"] 		= { start = "36700" },
		["dortmund"] 	= { start = "16577" },
		["drageran"] 	= { start = "25894" },
		["dread"] 		= { start = "26075" },
		["dsr"] 		= { start = "30030" },
		["dundoom"] 	= { start = "25661" },
		["dunoir"] 		= { start = "14222" },
		["duskvalley"] 	= { start = "37301" },
		["dynasty"] 	= { start = "30799" },
		["earthlords"] 	= { start = "42000" },		-- E --
		["earthplane"] 	= { start =  "1354" },
		["elemental"] 	= { start = "41624" },
		["empire"] 		= { start = "32203" },
		["empyrean"] 	= { start = "14042" },
		["entropy"] 	= { start = "29773" },
		["fantasy"] 	= { start = "15205" },		-- F --
		["farm"] 		= { start = "10676" },
		["fayke"] 		= { start = "30418" },
		["fens"] 		= { start = "16528" },
		["fields"] 		= { start = "29232" },
		["firebird"] 	= { start = "32885" },
		["firenation"] 	= { start = "41879" },
		["fireswamp"] 	= { start = "34755" },
		["fortress"] 	= { start = "31835" },
		["fortune"] 	= { start = "38561" },
		["fractured"] 	= { start = "17033" },
		["ft1"] 		= { start =  "1205" },
		["ftii"] 		= { start = "26673" },
		["gallows"] 	= { start =  "4344" },		-- G --
		["gathering"] 	= { start = "36451" },
		["gauntlet"] 	= { start = "31652" },
		["gilda"] 		= { start =  "4243" },
		["glamdursil"] 	= { start = "35055" },
		["glimmerdim"] 	= { start = "26252" },
		["gnomalin"] 	= { start = "34397" },
		["goldrush"] 	= { start = "15014" },
		["graveyard"] 	= { start = "28918" },
		["greece"] 		= { start =  "2089" },
		["gwillim"] 	= { start = "25974" },
		["hades"] 		= { start = "29161" },		-- H --
		["hatchling"]	= { start = "34670" },
		["hawklord"] 	= { start = "40550" },
		["hedge"] 		= { start = "15146" },
		["helegear"] 	= { start = "30699" },
		["hell"] 		= { start = "30984" },
		["hoard"] 		= { start =  "1675" },
		["hodgepodge"] 	= { start = "30469" },
		["horath"] 		= { start =    "91" },
		["horizon"] 	= { start = "31959" },
		["illoria"] 	= { start = "10420" },
		["imagi"] 		= { start = "36800" },		-- I --
		["imperial"] 	= { start = "16966", vidblain = true },
		["infamy"] 		= { start = "26641" },
		["infest"] 		= { start = "16165" },
		["insan"] 		= { start =  "6850" },
		["jenny"] 		= { start = "29637" },		-- J --
		["jotun"] 		= { start = "31508" },
		["kearvek"] 	= { start = "29722" },		-- K --
		["kerofk"] 		= { start = "16405" },
		["ketu"] 		= { start = "35114" },
		["kingsholm"] 	= { start = "27522" },
		["knossos"] 	= { start = "28193" },
		["kobaloi"] 	= { start = "10691" },
		["kultiras"] 	= { start = "31161" },
		["lab"] 		= { start = "28684" },		-- L --
		["labyrinth"] 	= { start = "31405" },
		["lagoon"] 		= { start = "30549" },
		["landofoz"] 	= { start =   "510" },
		["laym"] 		= { start =  "6005" },
		["legend"] 		= { start = "16224" },
		["lemdagor"] 	= { start =  "1966" },
		["lidnesh"] 	= { start = "27995" },
		["livingmine"] 	= { start = "37008" },
		["longnight"] 	= { start = "26367" },
		["losttime"] 	= { start = "28584" },
		["lplanes"] 	= { start = "29364" },
		["maelstrom"] 	= { start = "38058" },		-- M --
		["manor"] 		= { start = "10621" },
		["masq"] 		= { start = "29840" },
		["mayhem"] 		= { start =  "1866" },
		["melody"] 		= { start = "14172" },
		["minos"] 		= { start = "20472" },
		["mistridge"] 	= { start =  "4491" },
		["monastery"] 	= { start = "15756" },
		["mudwog"] 		= { start =  "2347" },
		["nanjiki"] 	= { start = "11203" },		-- N --
		["necro"] 		= { start = "29922" },
		["nenukon"] 	= { start = "31784" },
		["newthalos"] 	= { start = "23853" },
		["ninehells"] 	= { start =  "4613" },
		["northstar"] 	= { start = "11127" },
		["nottingham"] 	= { start = "11077" },
		["nulan"] 		= { start = "37900" },
		["nursing"] 	= { start = "31977" },
		["nynewoods"] 	= { start = "23562" },
		["oceanpark"] 	= { start = "39600" },		-- O --
		["omentor"] 	= { start = "15579", vidblain = true },
		["ooku"] 		= { start = "39000" },
		["origins"] 	= { start = "35900" },
		["orlando"] 	= { start = "30331" },
		["paradise"] 	= { start = "29624" },		-- P --
		["partroxis"] 	= { start =  "5814" },
		["peninsula"] 	= { start = "35701" },
		["petstore"] 	= { start =   "995" },
		["pompeii"] 	= { start =    "57" },
		["promises"] 	= { start = "25819" },
		["prosper"] 	= { start = "28268" },
		["qong"] 		= { start = "16115" },		-- Q --
		["quarry"] 		= { start = "23510" },
		["radiance"] 	= { start = "19805" },		-- R --
		["raga"] 		= { start = "19861" },
		["raukora"] 	= { start =  "6040" },
		["rebellion"] 	= { start = "10305" },
		["remcon"] 		= { start = "25837" },
		["reme"] 		= { start = "32703" },
		["rosewood"] 	= { start =  "6901" },
		["ruins"] 		= { start = "16805" },
		["sagewood"] 	= { start = "28754" },		-- S --
		["sahuagin"] 	= { start = "34592" },
		["salt"] 		= { start =  "4538" },
		["sanctity"] 	= { start = "10518" },
		["sanctum"] 	= { start = "15307" },
		["sandcastle"] 	= { start = "37701" },
		["sanguine"] 	= { start = "15436" },
		["scarred"] 	= { start = "34036" },
		["sendhian"] 	= { start = "20288", vidblain = true },
		["sennarre"] 	= { start = "15491" },
		["shadowsend"]	= { start = "53439" },
		["shouggoth"] 	= { start = "34087" },
		["siege"] 		= { start = "43265" },
		["sirens"] 		= { start = "16298" },
		["slaughter"] 	= { start =  "1601" },
		["snuckles"] 	= { start =   "182" },
		["soh"] 		= { start = "25611" },
		["sohtwo"] 		= { start = "30752" },
		["solan"] 		= { start = "23713" },
		["songpalace"] 	= { start = "47013" },
		["spyreknow"] 	= { start = "34800" },
		["stone"] 		= { start = "11386" },
		["storm"] 		= { start =  "6304" },
		["stormhaven"] 	= { start = "20649" },
		["stronghold"] 	= { start = "20572" },
		["stuff"] 		= { start = "40400" },
		["takeda"] 		= { start = "15952" },		-- T --
		["talsa"] 		= { start = "26917" },
		["temple"] 		= { start = "31597" },
		["tanra"] 		= { start = "46913" },
		["terra"] 		= { start = "19679" },
		["terramire"] 	= { start =  "4493" },
		["thieves"] 	= { start =     "7" },
		["tilule"]		= { start = "39771"	},
		["times"] 		= { start = "28463" },
		["tirna"] 		= { start = "20136" },
		["tol"] 		= { start = "16325" },
		["tombs"] 		= { start = "15385" },
		["umari"] 		= { start = "36601" },		-- U --
		["underdark"] 	= { start = "27341" },
		["uplanes"] 	= { start = "29364" },
		["uprising"] 	= { start = "15382" },
		["vale"] 		= { start =  "1036" },		-- V --
		["verdure"] 	= { start = "24090" },
		["verume"] 		= { start = "30607" },
		["village"] 	= { start = "30850" },
		["vlad"] 		= { start = "15970" },
		["volcano"] 	= { start =  "6091" },
		["weather"] 	= { start = "40499" },		-- W --
		["werewood"] 	= { start = "30956" },
		["wildwood"] 	= { start =   "322" },
		["winter"] 		= { start =  "1306" },
		["wizards"] 	= { start = "31316" },
		["wonders"] 	= { start = "32981" },
		["wooble"] 		= { start = "11335" },
		["woodelves"] 	= { start = "32199" },
		["wtc"] 		= { start = "37895" },
		["wyrm"] 		= { start = "28847" },
		["xmas"] 		= { start =  "6212" },		-- X --
		["xylmos"] 		= { start =   "472" },
		["yarr"] 		= { start = "30281" },
		["ygg"] 		= { start = "24186" },		-- Y --
		["yurgach"] 	= { start = "29450" },
		["zangar"] 		= { start =  "6164" },		-- Z --
		["zodiac"] 		= { start = "15857" },
		["zoo"] 		= { start =  "5920" },
		["zyian"] 		= { start =   "729" },
		-- Non-questable Areas
		["manor1"] 		= { start = "14460", noquest = true },		-- Manor areas
		["manor3"] 		= { start = "20836", noquest = true },
		["manorisle"] 	= { start =  "6366", noquest = true },
		["manormount"] 	= { start = "39449", noquest = true },
		["manorsea"] 	= { start = "35003", noquest = true },
		["manorville"] 	= { start = "35004", noquest = true },
		["manorwoods"] 	= { start = "35002", noquest = true },
		["blackclaw"]	= { start = "   -1", noquest = true }, -- epic areas
		["geniewish"] 	= { start = "38464", noquest = true },
		["icefall"] 	= { start = "38701", noquest = true },
		["inferno"]		= { start =    "-1", noquest = true },		
		["oradrin"] 	= { start = "25436", noquest = true }, 
		["titan"] 		= { start = "38234", noquest = true },
		["winds"] 		= { start = "39900", noquest = true },
		
		["badtrip"] 	= { start = "32877", noquest = true },		-- Other no-quest areas
		["birthday"]	= { start = "10920", noquest = true },
		["lowlands"] 	= { start = "28044", noquest = true },
		["seaking"]		= { start =    "-1", noquest = true },
		["amazonclan"] 	= { start = "34212", noquest = true },		-- Public clan halls
		["bard"] 		= { start = "30538", noquest = true },
		["bootcamp"] 	= { start = "49256", noquest = true },
		["cabal"] 		= { start = "15704", noquest = true },
		["chaos"] 		= { start = "28909", noquest = true },
		["crimson"] 	= { start = "27989", noquest = true },
		["crusaders"] 	= { start = "31122", noquest = true },
		["daoine"] 		= { start = "30949", noquest = true },
		["doh"] 		= { start = "16803", noquest = true },
		["dominion"] 	= { start =  "5863", noquest = true },
		["dragon"] 		= { start =   "642", noquest = true },
		["druid"] 		= { start = "29582", noquest = true },
		["emerald"] 	= { start =   "831", noquest = true },
		["gaardian"] 	= { start = "20026", noquest = true },
		["imperium"] 	= { start = "30415", noquest = true },
		["light"] 		= { start =  "2339", noquest = true },
		["loqui"] 		= { start = "28580", noquest = true },
		["masaki"] 		= { start = "15852", noquest = true },
		["perdition"] 	= { start = "19968", noquest = true },
		["pyre"] 		= { start = "15141", noquest = true },
		["romani"] 		= { start = "24180", noquest = true },
		["seekers"] 	= { start = "14165", noquest = true },
		["shadokil"] 	= { start = "32407", noquest = true },
		["tanelorn"] 	= { start = "31561", noquest = true },
		["tao"] 		= { start = "29210", noquest = true },
		["touchstone"] 	= { start = "28346", noquest = true },
		["twinlobe"] 	= { start = "15575", noquest = true },
		["vanir"] 		= { start =   "878", noquest = true },
		["watchmen"] 	= { start = "32342", noquest = true },
		
		["baal"] 		= { start =    "-1", noquest = true },		-- Closed clan halls
		["hook"] 		= { start =    "-1", noquest = true },
		["retri"] 		= { start =    "-1", noquest = true },
		["rhabdo"] 		= { start =    "-1", noquest = true },
		["rogues"] 		= { start =    "-1", noquest = true },
		["xunti"] 		= { start =    "-1", noquest = true },
		
		["challenge"]	= { start =    "-1", noquest = true },		-- Normally inaccessible areas, or which lack a sensible starting room.
		["immhomes"]	= { start =    "-1", noquest = true },
		["lasertwo"]	= { start =    "-1", noquest = true },
		["limbo"]		= { start =    "-1", noquest = true },
		["lualand"]		= { start =    "-1", noquest = true },
		["midgaard"]	= { start =    "-1", noquest = true },
		["oldclanone"] 	= { start =    "-1", noquest = true },
		["oldclantwo"] 	= { start =    "-1", noquest = true },
		["oldclanthr"] 	= { start =    "-1", noquest = true },
		["oldclanfou"] 	= { start =    "-1", noquest = true },
		["vault"]		= { start =    "-1", noquest = true },
		["warzone"]		= { start =    "-1", noquest = true },
		["wolfmaze"]	= { start =    "-1", noquest = true } }
	
	local vidblain_area_list = {
		["darklight"] 	= { },
		["imperial"] 	= { },
		["omentor"] 	= { },
		["sendhian"] 	= { },
		["vidblain"] 	= { } }

--	[[ Lookup table to get area id from area long name ]]
	local areaNameXref = {
		["A Genie's Last Wish"] 				= "geniewish",
		["A Magical Hodgepodge"] 				= "hodgepodge",
		["A Peaceful Giant Village"]			= "village",
		["Aardington Estate"]					= "aardington",
		["Aardwolf Zoological Park"] 			= "zoo",
		["Adventures in Sendhia"] 				= "sendhian",
		["Aerial City of Cineko"] 				= "cineko",
		["Afterglow"] 							= "afterglow",
		["Alagh, the Blood Lands"] 				= "alagh",
		["All in a Fayke Day"] 					= "fayke",
		["Ancient Greece"] 						= "greece",
		["Andolor's Ocean Adventure Park"] 		= "oceanpark",
		["Annwn"] 								= "annwn",
		["Anthrox"] 							= "anthrox",
		["Arboretum"] 							= "arboretum",
		["Arisian Realm"] 						= "arisian",
		["Art of Melody"] 						= "melody",
		["Artificer's Mayhem"] 					= "mayhem",
		["Ascension Bluff Nursing Home"] 		= "nursing",
		["Atlantis"] 							= "atlantis",
		["Avian Kingdom"] 						= "avian",
		["Battlefields of Adaldar"] 			= "adaldar",
		["Black Lagoon"] 						= "lagoon",
		["Black Rose"] 							= "blackrose",
		["Brightsea and Glimmerdim"]			= "glimmerdim",
		["Canyon Memorial Hospital"] 			= "canyon",
		["Castle Vlad-Shamir"] 					= "vlad",
		["Chaprenula's Laboratory"] 			= "lab",
		["Child's Play"] 						= "childsplay",
		["Christmas Vacation"] 					= "xmas",
		["Cloud City of Gnomalin"] 				= "gnomalin",
		["Cradlebrook"] 						= "cradle",
		["Crossroads of Fortune"] 				= "fortune",
		["Crynn's Church"] 						= "crynn",
		["Dark Elf Stronghold"] 				= "stronghold",
		["Death's Manor"] 						= "manor",
		["Deathtrap Dungeon"] 					= "deathtrap",
		["Den of Thieves"] 						= "thieves",
		["Descent to Hell"] 					= "hell",
		["Desert Doom"] 						= "ddoom",
		["Dhal'Gora Outlands"] 					= "dhalgora",
		["Diamond Soul Revelation"] 			= "dsr",
		["Dortmund"] 							= "dortmund",
		["Dread Tower"] 						= "dread",
		["Dusk Valley"] 						= "duskvalley",
		["Earth Plane 4"] 						= "earthplane",
		["Elemental Chaos"] 					= "elemental",
		["Empyrean, Streets of Downfall"] 		= "empyrean",
		["Entrance to Hades"] 					= "hades",
		["Eternal Autumn"] 						= "autumn",
		["Faerie Tales II"] 					= "ftii",
		["Faerie Tales"] 						= "ft1",
		["Fantasy Fields"] 						= "fantasy",
		["Foolish Promises"] 					= "promises",
		["Fort Terramire"] 						= "terramire",
		["Gallows Hill"] 						= "gallows",
		["Gelidus"] 							= "gelidus",
		["Giant's Pet Store"] 					= "petstore",
		["Gilda And The Dragon"] 				= "gilda",
		["Gnoll's Quarry"] 						= "quarry",
		["Gold Rush"] 							= "goldrush",
		["Guardian's Spyre of Knowledge"] 		= "spyreknow",
		["Gypsy Caravan"] 						= "caravan",
		["Halls of the Damned"] 				= "damned",
		["Hatchling Aerie"] 					= "hatchling",
		["Hedgehogs' Paradise"] 				= "hedge",
		["Helegear Sea"] 						= "helegear",
		["Hotel Orlando"] 						= "orlando",
		["House of Cards"] 						= "cards",
		["Icefall"] 							= "icefall",
		["Imagi's Nation"] 						= "imagi",
		["Imperial Nation"] 					= "imperial",
		["Insanitaria"] 						= "insan",
		["Into the Long Night"] 				= "longnight",
		["Intrigues of Times Past"] 			= "times",
		["Island of Lost Time"] 				= "losttime",
		["Jenny's Tavern"] 						= "jenny",
		["Jotunheim"] 							= "jotun",
		["Jungles of Verume"] 					= "verume",
		["Keep of the Kobaloi"] 				= "kobaloi",
		["Kerofk"] 								= "kerofk",
		["Ketu Uplands"] 						= "ketu",
		["Kiksaadi Cove"] 						= "cove",
		["Kimr's Farm"] 						= "farm",
		["Kingdom of Ahner"] 					= "ahner",
		["Kingsholm"] 							= "kingsholm",
		["Kobold Siege Camp"] 					= "siege",
		["Kul Tiras"] 							= "kultiras",
		["Land of Legend"] 						= "legend",
		["Living Mines of Dak'Tai"] 			= "livingmine",
		["Masquerade Island"] 					= "masq",
		["Mount duNoir"] 						= "dunoir",
		["Mudwog's Swamp"] 						= "mudwog",
		["Nanjiki Ruins"] 						= "nanjiki",
		["Nebulous Horizon"] 					= "horizon",
		["Necromancers' Guild"] 				= "necro",
		["Nenukon and the Far Country"] 		= "nenukon",
		["New Thalos"] 							= "newthalos",
		["Northstar"] 							= "northstar",
		["Nottingham"] 							= "nottingham",
		["Olde Worlde Carnivale"]				= "carnivale",
		["Onyx Bazaar"] 						= "bazaar",
		["Ookushka Garrison"] 					= "ooku",
		["Paradise Lost"] 						= "paradise",
		["Plains of Nulan'Boar"] 				= "nulan",
		["Pompeii"] 							= "pompeii",
		["Prosper's Island"] 					= "prosper",
		["Qong"] 								= "qong",
		["Radiance Woods"] 						= "radiance",
		["Raganatittu"] 						= "raga",
		["Realm of Deneria"] 					= "deneria",
		["Realm of the Firebird"] 				= "firebird",
		["Realm of the Sacred Flame"] 			= "firenation",
		["Realm of the Zodiac"] 				= "zodiac",
		["Rebellion of the Nix"] 				= "rebellion",
		["Rosewood Castle"] 					= "rosewood",
		["Sagewood Grove"] 						= "sagewood",
		["Sanctity of Eternal Damnation"] 		= "sanctity",
		["Sen'narre Lake"] 						= "sennarre",
		["Seven Wonders"] 						= "wonders",
		["Shadow's End"]						= "shadowsend",
		["Sheila's Cat Sanctuary"] 				= "cats",
		["Sho'aram, Castle in the Sand"] 		= "sandcastle",
		["Siren's Oasis Resort"] 				= "sirens",
		["Snuckles Village"] 					= "snuckles",
		["Storm Mountain"] 						= "storm",
		["Storm Ships of Lem-Dagor"] 			= "lemdagor",
		["Sundered Vale"] 						= "vale",
		["Swordbreaker's Hoard"] 				= "hoard",
		["Tairayden Peninsula"] 				= "peninsula",
		["Tai'rha Laym"] 						= "laym",
		["Takeda's Warcamp"] 					= "takeda",
		["Tanra'vea"] 							= "tanra",
		["Thandeld's Conflict"] 				= "conflict",
		["The Abyssal Caverns of Sahuagin"] 	= "sahuagin",
		["The Amazon Nation"] 					= "amazon",
		["The Amusement Park"] 					= "amusement",
		["The Archipelago of Entropy"] 			= "entropy",
		["The Astral Travels"] 					= "astral",
		["The Aylorian Academy"] 				= "academy",
		["The Blighted Tundra of Andarin"] 		= "andarin",
		["The Blood Opal of Rauko'ra"] 			= "raukora",
		["The Blood Sanctum"] 					= "sanctum",
		["The Broken Halls of Horath"] 			= "horath",
		["The Call of Heroes"] 					= "callhero",
		["The Cataclysm"] 						= "cataclysm",
		["The Chasm and The Catacombs"] 		= "chasm",
		["The Chessboard"] 						= "chessboard",
		["The Continent of Mesolar"] 			= "mesolar",
		["The Coral Kingdom"] 					= "coral",
		["The Cougarian Queendom"] 				= "cougarian",
		["The Council of the Wyrm"] 			= "wyrm",
		["The Covenant of Mistridge"] 			= "mistridge",
		["The Cracks of Terra"] 				= "terra",
		["The Curse of the Midnight Fens"] 		= "fens",
		["The Dark Continent, Abend"] 			= "abend",
		["The Dark Temple of Zyian"] 			= "zyian",
		["The DarkLight"] 						= "darklight",
		["The Darkside of the Fractured Lands"] = "darkside",
		["The Deadlights"] 						= "deadlights",
		["The Desert Prison"] 					= "desert",
		["The Drageran Empire"] 				= "drageran",
		["The Dungeon of Doom"] 				= "dundoom",
		["The Earth Lords"] 					= "earthlords",
		["The Eighteenth Dynasty"] 				= "dynasty",
		["The Empire of Aiighialla"] 			= "empire",
		["The Empire of Talsa"] 				= "talsa",
		["The Fabled City of Stone"] 			= "stone",
		["The Fire Swamp"] 						= "fireswamp",
		["The First Ascent"] 					= "ascent",
		["The Flying Citadel"] 					= "citadel",
		["The Forest of Li'Dnesh"] 				= "lidnesh",
		["The Fractured Lands"] 				= "fractured",
		["The Gathering Horde"] 				= "gathering",
		["The Gauntlet"] 						= "gauntlet",
		["The Gladiator's Arena"] 				= "arena",
		["The Glamdursil"] 						= "glamdursil",
		["The Goblin Fortress"] 				= "fortress",
		["The Grand City of Aylor"] 			= "aylor",
		["The Graveyard"] 						= "graveyard",
		["The Great City of Knossos"]			= "knossos",
		["The Great Salt Flats"] 				= "salt",
		["The Icy Caldera of Mauldoon"] 		= "caldera",
		["The Imperial City of Reme"] 			= "reme",
		["The Infestation"] 					= "infest",
		["The Keep of Kearvek"] 				= "kearvek",
		["The Killing Fields"] 					= "fields",
		["The Labyrinth"] 						= "labyrinth",
		["The Land of Oz"] 						= "landofoz",
		["The Land of the Beer Goblins"] 		= "beer",
		["The Lower Planes"] 					= "lplanes",
		["The Maelstrom"] 						= "maelstrom",
		["The Marshlands of Agroth"] 			= "agroth",
		["The Misty Shores of Yarr"] 			= "yarr",
		["The Monastery"] 						= "monastery",
		["The Mountains of Desolation"] 		= "desolation",
		["The Nine Hells"] 						= "ninehells",
		["The Nyne Woods"] 						= "nynewoods",
		["The Old Cathedral"] 					= "cathedral",
		["The Palace of Song"] 					= "songpalace",
		["The Partroxis"] 						= "partroxis",
		["The Path of the Believer"] 			= "believer",
		["The Realm of Infamy"] 				= "infamy",
		["The Realm of the Hawklords"] 			= "hawklord",
		["The Relinquished Tombs"] 				= "tombs",
		["The Reman Conspiracy"] 				= "remcon",
		["The Ruins of Diamond Reach"] 			= "ruins",
		["The Ruins of Stormhaven"] 			= "stormhaven",
		["The Sanguine Tavern"] 				= "sanguine",
		["The Scarred Lands"] 					= "scarred",
		["The School of Horror"] 				= "soh",
		["The Shadows of Minos"] 				= "minos",
		["The Silver Volcano"] 					= "volcano",
		["The Slaughter House"] 				= "slaughter",
		["The Southern Ocean"] 					= "southern",
		["The Stuff of Shadows"] 				= "stuff",
		["The Temple of Shal'indrael"] 			= "temple",
		["The Temple of Shouggoth"] 			= "shouggoth",
		["The Three Pillars of Diatz"] 			= "diatz",
		["The Titans' Keep"] 					= "titan",
		["The Tournament of Illoria"] 			= "illoria",
		["The Town of Solan"] 					= "solan",
		["The Tree of Life"] 					= "tol",
		["The Trouble with Gwillimberry"] 		= "gwillim",
		["The Uncharted Oceans"] 				= "uncharted",
		["The UnderDark"] 						= "underdark",
		["The Upper Planes"] 					= "uplanes",
		["The Uprising"] 						= "uprising",
		["The Were Wood"] 						= "werewood",
		["The Witches of Omen Tor"] 			= "omentor",
		["The Wobbly Woes of Woobleville"] 		= "wooble",
		["The Wood Elves of Nalondir"] 			= "woodelves",
		["The Yurgach Domain"] 					= "yurgach",
		["Tilule Rehabilitation Clinic"]		= "tilule",
		["Tir na nOg"] 							= "tirna",
		["Tournament Camps"] 					= "camps",
		["Tribal Origins"] 						= "origins",
		["Tumari's Diner"] 						= "diner",
		["Umari's Castle"] 						= "umari",
		["Unearthly Bonds"] 					= "bonds",
		["Verdure Estate"] 						= "verdure",
		["Vidblain, the Ever Dark"] 			= "vidblain",
		["War of the Wizards"] 					= "wizards",
		["Warrior's Training Camp"] 			= "wtc",
		["Wayward Alehouse"] 					= "alehouse",
		["Weather Observatory"] 				= "weather",
		["Wedded Bliss"] 						= "bliss",
		["Wildwood"] 							= "wildwood",
		["Winds of Fate"] 						= "winds",
		["Winterlands"] 						= "winter",
		["Xyl's Mosaic"] 						= "xylmos",
		["Yggdrasil: The World Tree"] 			= "ygg",
		["Zangar's Demonic Grotto"] 			= "zangar" }

-- 	[[ Lookup table: Game calendar data]]		
	local gCalendar = { }	
		
--	[[ Load saved table data ]]
	function load_saved_table_data()
		load_area_start_rooms()
		load_area_range_index()
	end

	function load_area_start_rooms()
		if (GetVariable("mcvar_areaStartRooms") ~= nil) then			
			code = "obj = " .. GetVariable("mcvar_areaStartRooms")
			assert (loadstring (code or "")) ()		
			area_start_rooms = obj
		end	
	end

	function load_area_range_index()
		send_gmcp_packet("request room")
		if (GetVariable("mcvar_area_range") ~= nil) then
			code = "obj = " .. GetVariable("mcvar_area_range")
			assert(loadstring (code or "")) ()		
			area_range_index = obj
			do_cp_info()
		else
			area_index_process()
		end	
	end
	
--	[[ Area index process ]]	
	function area_index_process()
		Execute("xset suspend page size")
		DoAfterSpecial(0.1, [[ SendNoEcho("areas 1 300 keyword") ]], sendto.script)
	end
	
	function area_index_start()		-- called by trigger for "Showing areas from 0 to 300" line at start of areas list.
		area_range_index = {}
		ColourNote("#FF5000", "", "*** Indexing area levels")
	end
	
	function area_index_line(name, line, wildcards)			-- called by trigger reacting to the output lines from the areas list.
		local areaName = Trim(wildcards.areaName)
		local arid = Trim(wildcards.arid)
		local minLvl = tonumber(Trim(wildcards.min)) or 1
		local maxLvl = tonumber(Trim(wildcards.max)) or 201
		--local levelLock = tonumber(Trim(wildcards.lock)) or 0
		if areaDefaultStartRooms[arid] then		     
			if (areaDefaultStartRooms[arid].noquest == true) then
				-- do nothing, we don't want to add noquest areas to the index
			else
				if     (arid == "sahuagin") then areaName = "The Abyssal Caverns of Sahuagin"
				elseif (arid == "darkside") then areaName = "The Darkside of the Fractured Lands"
				elseif (arid == "academy") then maxLvl = 10
				elseif (arid == "sohtwo") then minLvL = 170 
				end
				area_range_index[areaName] = { arid = arid, min = minLvl, max = maxLvl }	-- lock = levelLock }
				
			end
		else
			ColourNote("#802800", "", "*** Missing default start room - " .. areaName)
		end
	end
	
	function area_index_end(name, line, wildcards)
		SetVariable("mcvar_area_range", serialize.save_simple(area_range_index))
		ColourNote("#FF5000", "", "\n*** Area levels indexed!")
		Execute("xset resume page size")
		DoAfterSpecial(0.1, "cp info", sendto.execute)
	end

--	[[ Guess mob keywords ]]
	local gmkw_omit = {	["a"] = "",	["an"] = "", ["and"] = "", ["of"] = "", ["or"] = "", ["some"] = "", ["the"] = "" }
	local gmkw_area_filters = {
		["adaldar"]		= { { f= "^.*(el)vish (%a*%s?%a+)$",			g="%1 %2" 	}, },
		
		["bonds"]		= { { f= "^(.*[bgry]%a+) dragon$",				g="%1"		}, },
		
		["citadel"]   	= {	{ f= "^([bgjlmsv]%a+) ([ap]r%a+[el]) .+$",	g="%1 %2"	}, },
							
		["elemental"]   = {	{ f= "^(%a+)%'(%a+) (%a+)$",				g="%1%2 %3"	}, 
							{ f= "^wandering (%a+)%'(%a+) (%a+)$",		g="%1%2 %3"	}, },
	
		["hatchling"] 	= {	{ f= "^(%a+) dragon (egg)$", 				g="%1 %2"	},
							{ f= "^(%a+) dragon (hatchling)$", 			g="%1 %2"	},
							{ f= "^(%a+ %a+) dragon whelp$", 			g="%1"		},
							{ f= "^(%a+) dragon (whelp)$", 				g="%1 %2"	}, },
							
		["sirens"] 		= {	{ f= "^miss ([%a']+)%s?(%a*).*%a$", 		g="%1 %2"	}, },
		
		["sohtwo"]		= { { f= "^(evil) %a+",							g="%1"		},
							{ f= "^(good) %a+",							g="%1"		}, },
		
		["verume"]		= {	{ f= "^lizardman (temple %a+)$", 			g="%1"		}, },
		
		["wooble"]		= {	{ f= "^sea (%a+)$", 						g="%1"		},
							{ f= "^sea (%a+ %a+)$", 					g="%1"		}, }, }

	local gmkw_exceptions = {
		["aardington"]	= { ["a very large portrait"]				= { kw="large port"			}, },
		
		["anthrox"]		= { ["the little white rabbit"]				= { kw="rabb"				}, },
		
		["ddoom"]		= { ["a dangerous scorpion"]				= { kw="scorp"				},
							["Lwji, the Sunrise great warrior"]		= { kw="lwji"				},
							["Taji, the Sunset leader"]				= { kw="taji lead"			}, 
							["Taji's personal advisor"]				= { kw="pers advi"			},
							["Tjac, the Sunrise leader"]			= { kw="tjac lead"			},
							["Tjac's personal advisor"]				= { kw="sunr advis"			},
							["Yki, the great Sunset warrior"]		= { kw="yki"				}, },
		
		["deneria"]		= { ["High Priest of Miad'Bir"] 			= { kw="high miad" 			}, },
		
		["desert"]		= { ["a village citizen"] 					= { kw="citi" 				}, },
							
		["fields"]		= { ["a mutated goat"] 						= { kw="goat" 				}, },
		
		["fortress"]	= { ["a grizzled goblin dressed in skins"]	= { kw="grizz gobl"		 	},
							["Blood Silk, Collector of souls, Queen of the spiders"] = { kw="silk queen" }, },
		
		["illoria"]		= { ["the King and Queen's Guard"]			= { kw="pers guard"			}, }, 
		
		["landofoz"]	= { ["one of Dorothy's uncles"] 			= { kw="doroth uncle"		}, },
		
		["laym"]		= { ["an elite guard of the church"]		= { kw="elit guar"			}, },
		
		["livingmine"]	= { ["a member of the 'Cal tribe"]			= { kw="memb cal"			},
							["a member of the 'Sorr tribe"]			= { kw="memb sorr"			},
							["a member of the 'Tai tribe"]			= { kw="memb tai"			},
							["Dak'tai's shaman"]					= { kw="dakt shama"			},
							["the 'Tai chieftain"]					= { kw="tai chief"			}, },
							
		["longnight"]	= { ["Mr. Roberge"]							= { kw="car rober"			}, },
		
		["losttime"]	= { ["T-Rex"]								= { kw="T-rex"				}, },
		
		["manor"]		= { ["Aremata-Popua"] 						= { kw="aremata-pop"	 	}, 
							["Aremata-Rorua"] 						= { kw="aremata-ror" 		}, },
							
		["masq"]		= { ["a gentleman on the way to the ball"]	= { kw="gentl"				},
							["a very attractive woman"]				= { kw="attr woman"			}, },
		
		["necro"] 		= { ["the head necromancer's assistant"]	= { kw="old mage assist" 	}, },
		
		["northstar"]	= { ["a Blood Ring elite warrior"]			= { kw="elit warr"			},
							["Daryoon, a priest of nature"]			= { kw="dary pries"			},
							["Tristam, the Prince of the Orcs"]		= { kw="trist orc"			}, },
		
		["sanctity"]	= { ["a half-converted human"]				= { kw="human"				}, },
		
		["siege"]		= { ["a kobold eating lunch"]				= { kw="kobold eating"		},
							["a large mole"]						= { kw="mole"				},
							["a very large firefly"]				= { kw="larg firef"			},
							["the fattest kobold ever"]				= { kw="fat kobold"			}, },

		["sohtwo"]      = { ["An evil form of Sagen"]               = { kw="notcarlsagen"        },
							["Angelic Demonspawn"]                  = { kw="angelic"             },
							["Bubbly Obyron"]                       = { kw="fuzzybunny"          },
							["Dejected Broud"]                      = { kw="dejected"            },
							["Disagreeable Rumour"]                 = { kw="obstinate"           },
							["Disoriented Dadrake"]                 = { kw="letsturnlefthere"    },
							["Evil Aaeron"] 	                    = { kw="shinythings"         },
							["Evil Althalus"]                       = { kw="homeskillet"         },
							["Evil Belmont"]                        = { kw="bridgetroll"         },
							["Evil Domain"]                         = { kw="66"                  },
							["Evil Euphonix"]                       = { kw="ragbrai"             },
							["Evil Ghaan"]                          = { kw="longghaan"           },
							["Evil Halo"]                           = { kw="jackandcoke"         },
							["Evil Ikyu"]                           = { kw="ickypoo"             },
							["Evil Justme"]                         = { kw="helperisme"          },
							["Evil Kharpern"]                       = { kw="kittyimm"            },
							["Evil KlauWaard"]                      = { kw="tricksy"             },
							["Evil Kt"]                             = { kw="ktkat"               },
							["Evil Lasher"]                         = { kw="thearchitect"        },
							["Evil Madcatz"]                        = { kw="mathizard"           },
							["Evil Maerchyng"]                      = { kw="maerchyng"           },
							["Evil Morrigu"]                        = { kw="morrigu"             },
							["Evil OrcWarrior"]                     = { kw="sheepshagger"        },
							["Evil Pane"]                           = { kw="painintheneck"       },
							["Evil Plaideleon"]                     = { kw="crazycanadian"       },
							["Evil Rekhart"]                        = { kw="hartsawreck"         },
							["Evil Sarlock"]                        = { kw="l33td00d"            },
							["Evil Tela"]                           = { kw="telllllllla"         },
							["Evil Timeghost"]                      = { kw="floppyimm"           },
							["Good Tripitaka"]                      = { kw="laketripitaka"       },
							["Evil Tymme"]                          = { kw="hourglass"           },
							["Evil Vladia"]                         = { kw="sexyvamp"            },
							["Evil Whitdjinn"]                      = { kw="thundercat"          },
							["Evil Windjammer"]                     = { kw="justsomeimm"         },
							["Evil Wolfe"]                          = { kw="likeobybutbritish"   },
							["Evil Xyzzy"]                          = { kw="weirdcode"           },
							["Good Aerianne"]                       = { kw="pointyears"          },
							["Good Cadaver"]                        = { kw="newbiehater"         },
							["Good Delight"]                        = { kw="turkishdelight"       },
							["Good Dirtworm"]                       = { kw="wormy"                },
							["Good Eclaboussure"]                   = { kw="dropbearimm"          },
							["Good Filt"]                           = { kw="plainolefilt"         },
							["Good Glimmer"]                        = { kw="betterhalfofclaire"   },
							["Good Kinson"]                         = { kw="upgradeboy"           },
							["Good Lumina"]                         = { kw="thievesrus"           },
							["Good Oladon"]                         = { kw="spellingbee"          },
							["Good Rhuli"]                          = { kw="rulistheworld"        },
							["Good Sausage"]                        = { kw="fatbreakfast"         },
							["Good Sirene"]                         = { kw="warriorprincess"      },
							["Good Takihisis"]                      = { kw="dragonlady"           },
							["Good Terrill"]                        = { kw="askcitron"            },
							["Good Tyanon"]                         = { kw="tieoneon"             },
							["Good Valkur"]                         = { kw="demonlord"            },
							["Good Vilgan"]                         = { kw="unabridged"           },
							["Good Xantcha"]                        = { kw="pokerimm"             },
							["Good Zane"]                           = { kw="inzanity"             },
							["Goodie Goodie Jaenelle"]              = { kw="goodie"               },
							["Impatient Styliann"]                  = { kw="willyouhurryup"       },
							["Kinda-Sorta Good Whisper"]            = { kw="kinda"                },
							["Master Shen"]                         = { kw="master"               },
							["Mathematical Mordist"]                = { kw="complex"              },
							["Nascaard Rezit"]                      = { kw="nascaard"             },
							["Pandemonium Penthesilea"]             = { kw="pandemonium"          },
							["Record Holding Guinness"]             = { kw="cantwriteatall"       },
							["Singing Paramore"]                    = { kw="failedmusician"       },
							["Sith Lord Neeper"]                    = { kw="sith"                 },
							["Smurfy Laren"]                        = { kw="lovethemsmurfs"       },
							["Sober Citron"]                        = { kw="sober"                },
							["Socialite Arthon"]                    = { kw="airhead"              },
							["Straight Dreamfyre"]                  = { kw="straight"             },
							["The cool version of Xeno"]            = { kw="onex"                 },
							["The Pancake Flat"]                    = { kw="pancake"              },
							["Tjopping Quadrapus"]                  = { kw="tjopping"             },
							["Unhelpful Claire"]                    = { kw="cookies"              },
							["Unremarkable Korridel"]               = { kw="unremarkable"         },
							["Unrestrained Elvandar"]               = { kw="omgsheneverstopstalking"},
							["Warsnail Anaristos"]                  = { kw="warsnail"             },
							["Cuddlebear Koala"]                    = { kw="cuddlebear"           },
							["(Helper) Fenix"]                      = { kw="helper"               },},
		
		["snuckles"]	= {	["Sarah, the grieving snuckle"]			= { kw="sarah griev"		}, },

		["stone"]		= { ["a Citadel of Stone Cityguard"]		= { kw="cit guar"			,} },
		
		["talsa"]		= { ["a dwarven mercenary"]					= { kw="dwar merc"			}, },
		
		["wooble"]		= { ["the Sea Snake Master-at-Arms"] 		= { kw="snake mast" 		}, },

		["yarr"]		= {	["a pirate sorting the treasure"]		= { kw="pirat sort"			},
							["a pirate stealing some treasure"]		= { kw="pirat steal"		}, }, 
							
		["zoo"]			= { ["a black-footed pine marten"]			= { kw="pine marte"			}, }, }
	
	function gmkw(s, a)	-- guess mob keywords
		if not s then return "" end
		local ri = current_room
		local ar = a or ri.zone
		local guess
		if gmkw_exceptions[ar] then			-- Is the mob listed as a keyword exception?  if so, look up keywords from the exception table instead of guessing. 
			if gmkw_exceptions[ar][s] then
				guess = gmkw_exceptions[ar][s].kw	-- Special thanks to Redryn for being obtuse and aggravating me enough that I added this.  Dick.
				return guess
			else
				--
			end
		end

		local omit = gmkw_omit
		local s1 = {}
		for w in string.gmatch(string.lower(s), "[^ ]+") do
			w = string.gsub(w, "%p%-", "")
			w = string.gsub(w, ",", "")
			w = string.gsub(w, "%.", "")
			w = string.gsub(w, "'s$", "")
			w = string.gsub(w, "[!?]+$", "")
			table.insert(s1, w)
		end

		local s2
		for i,v in ipairs (s1) do
			if omit[v] then
				-- do nothing
			else
				s2 = (s2 == nil) and v or s2 .. " " .. v
			end
		end	

		local s3
		if gmkw_area_filters[ar] then
			for i,v in ipairs (gmkw_area_filters[ar]) do
				s3 = string.gsub(s2, v.f, v.g)
				if (s3 ~= s2) then
					break
				end
			end
		else
			s3 = s2
		end
		s3 = string.gsub(s3, "-", " ")
		
		local s4 = {}	
		for w in string.gmatch(s3, "[^ ]+") do
			table.insert(s4, w)
		end
		local len1 = #(s4[1])
		local len2 = #(s4[#s4]) or 0
		if (#s4 > 1) then	-- mob name has multiple words
			local x,y = math.random(4,6), math.random(4,6)
			guess = string.sub(s4[1], 1, x) .. " " .. string.sub(s4[#s4], 1, y)
		elseif (#s4 == 1) then	-- mob name has one word
			local x = math.random(2 + round_banker(len1*0.5), len1)
			guess = string.sub(s4[1], 1, x)
		else										-- Sometimes all of the mob words get deleted, if so just use original input.  In theory, if we reached this step
			guess = s or "gmkw error in stage 4"  	-- then the input is non-nil and I've never seen it be "" ... so, if it errors it means Lua is propagating a nil
		end-- somehow or doing one of the other mickey mouse nonsense things that Lua likes to do.
		return guess
	end

--	[[ Detect campaign (or gquest) type - area or room ]]	
	function area_room_type_check(list)
		local areaCount = 0
		local roomCount = 0
		local ar_rm
		for i,v in ipairs (list) do
			if areaNameXref[v.loc] then
				areaCount = areaCount + 1
			else
				roomCount = roomCount + 1
			end
		end
		if (areaCount >= roomCount) then
			ar_rm = "area"
		else
			ar_rm = "room"
		end
		return ar_rm
	end

--	[[ Quest target process ]]
	function xq_command()	-- enables 'xq' command (reload quest info)
		send_gmcp_packet("request quest")
	end

	function target_quest_mob(bool)	-- Re-targets your quest mob if you un-target it somehow (xcp, etc.)
		local qt = quest_target
		xcp_clear_target(true)
		qw_reset(false)
		if (qt.mob == "missing") and (qt.arid == nil) and (qt.areaName == nil) and (qt.room == nil) then
			qt.mob = GetVariable("mcvar_qt_mob")
			qt.arid = GetVariable("mcvar_qt_arid")
			qt.areaName = GetVariable("mcvar_qt_areaName")
			qt.room = GetVariable("mcvar_qt_mob")
			if (bool == true) then
				ColourNote("#FF1010", "", "\n'Target quest mob' (xq) not done - the mob is currently dead, or you can't see it (check detects).")
				ColourNote("#FF1010", "", "\n'The last known location, before it went missing, was:\n")
				ColourNote("#FF5000", "", "mob : ",
							"#00C040", "", qt.mob.." ")
				ColourNote("#FF5000", "", "area: ",
							"#00C040", "", qt.areaName .. " ("..qt.arid..")")
				ColourNote("#FF5000", "", "room: ",
							"#00C040", "", qt.room)
			end
		else
			full_mob_name = qt.mob
			short_mob_name = gmkw(qt.mob, qt.arid)
			SetVariable("mcvar_qt_mob", qt.mob)
			SetVariable("mcvar_qt_arid", qt.arid)
			SetVariable("mcvar_qt_areaName", qt.areaName)
			SetVariable("mcvar_qt_room", qt.room)
			if (bool == true) then
				ColourNote("#FF5000", "", "\nYour quest mob is: \n") 
				ColourNote("#FF5000", "", "mob : ",
						"#00C040", "", qt.mob.." ")
				ColourNote("#FF5000", "", "area: ",
						"#00C040", "", qt.areaName .. " ("..qt.arid..")")
				ColourNote("#FF5000", "", "room: ",
						"#00C040", "", qt.room)
			end
		end
		Execute("xm "..qt.room.."|"..qt.arid)
	end

	function quest_status_gmcp(q)	-- sets quest status when you take a new quest, kill qmob, complete quest, etc.
		if (q.action == "start") then									-- you've just taken a new quest
			quest_target = { qstat = "2", mob = q.targ,	areaName = q.area, arid = areaNameXref[q.area], room = (string.gsub(q.room, "@[bcgmrwyBCDGMRWY]", "")) }
			target_quest_mob(true)
		elseif (q.action == "status" and q.targ and q.timer) then		-- on quest, qmob not yet killed
			quest_target = { qstat="2", mob = q.targ, areaName = q.area, arid = areaNameXref[q.area], room = (string.gsub(q.room, "@[bcgmrwyBCDGMRWY]", "")) }
			target_quest_mob(true)			
		else
			if (q.action == "killed") then	-- you've just killed the target
				quest_target.qstat = "3"
			--elseif (q.action == "start") then	-- you've just taken a new quest
			--	quest_target = { qstat = "2", mob = q.targ,	areaName = q.area, arid = areaNameXref[q.area], room = (string.gsub(q.room, "@[bcgmrwyBCDGMRWY]", "")) }
			--	target_quest_mob(true)
			elseif (q.action == "comp") or (q.action == "fail") or (q.action == "reset") then -- quest has ended (completed, failed, or reset)
				quest_target = { qstat="1"}
				xcp_clear_target(false)
				qw_reset(false)
			elseif (q.action == "ready") or (q.action == "timeout") then -- can take new quest immediately		
				quest_target = { qstat="0"}
			
			-- in all of these, the action is "status"
			elseif (q.action == "status" and q.target == "killed") then		-- on quest, qmob has been killed (do not confuse q.target with q.targ above!)
				quest_target.qstat = "3"
				ColourNote("#FF5000", "", "\nSearch and Destroy: You have already killed your quest target!\n")
			--elseif (q.action == "status" and q.targ and q.timer) then		-- on quest, qmob not yet killed
			--	quest_target = { qstat="2", mob = q.targ, areaName = q.area, arid = areaNameXref[q.area], room = (string.gsub(q.room, "@[bcgmrwyBCDGMRWY]", "")) }
			--	target_quest_mob(true)			
			elseif (q.action == "status" and (q.wait)) then					-- off quest, must wait before requesting new
				quest_target = { qstat="1"}
				ColourNote("#FF5000", "", "\nSearch and Destroy: Not on quest - must wait before requesting new.\n")
			elseif (q.action == "status" and q.status == "ready") then		-- off quest, can request new quest immediately
				quest_target = { qstat="0"}
				ColourNote("#FF5000", "", "\nSearch and Destroy: Not on quest - can request new quest immediately. \n")
			end
			SetVariable("mcvar_qt_mob", "")
			SetVariable("mcvar_qt_arid", "")
			SetVariable("mcvar_qt_areaName", "")
			SetVariable("mcvar_qt_room", "")
		end
	end
	
--	[[ "cp info" process path ]]
	function do_cp_info()
		cp_info_list = {}
		main_target_list = {}
		room_targets_ignored = {}
		xcp_index = 0
		EnableTrigger("trg_cp_info_level_taken", true)
		EnableTrigger("trg_cp_info_targets", true)
		SendNoEcho("cp info")
		xg_draw_window()	-- redraw window during latency period between sending the command and receiving a response, which would otherwise be 'dead' time.
	end
	
	function cp_info_level_taken(name, line, wildcards)
		local x = tonumber(wildcards.level)
		cp_info_level = x
		SetVariable("mcvar_cp_level_taken", x)
	end
	
	function cp_info_line(name, line, wildcards)
		local t = cp_info_list
		local mob = wildcards.mob
		local loc = wildcards.loc
		local ord = #t+1
		table.insert(t, { mob=mob, loc=loc, ord=ord } )
	end
	
	function cp_info_end()
		player_on_cp = "yes"
		current_activity = "cp"
		local t = cp_info_list
		area_room_type = area_room_type_check(t)
		print("cp type detection: ".. area_room_type .." (level "..cp_info_level..")\n")
		xg_draw_window()
		DoAfterSpecial(0.1, [[ do_cp_check() ]], sendto.script)
	end

--	[[ "cp check" process path ]]	
	function do_cp_check()
		local time_check = os.clock()					-- prevent double cp checks from different plugins
		if ((time_check - last_cp_check) < 1.0) then
			return
		end
		last_cp_check = time_check
		cp_check_list = {}
		EnableTrigger("trg_cp_check_line", true)
		SendNoEcho("cp ch")
	end
	
	function cp_check_line(name, line, wildcards)
		local t = cp_check_list
		local mob = wildcards.mob
		local qty = 1
		local kw = ""
		local loc = wildcards.loc
		local is_dead = ((wildcards.isdead == "") and "no" or "yes")
		local ord = #t + 1
		table.insert(t, { mob=mob, qty=qty, loc=loc, is_dead=is_dead, ord=ord })
	end
	
	function cp_check_end(name, line, wildcards)
		player_on_cp = "yes"
		current_activity = "cp"
		build_main_target_list("cp", area_room_type)
		if (xcp_retry_stat == 2) then						-- About xcp_retry_stat:
			if (xcp_index == 0) or (xcp_index == 1) then
				xcp_retry_stat = 0							-- after killing cp mob, it's possible to 'xcp' after tables are cleared,
				xcp_noarg()									-- but before they're refreshed, which would cause 'xcp' to fail with the
			else											-- message "no data yet".  Instead, cp_mob_killed sets a flag that does
				xcp_retry_stat = 0							-- two things: 1) tells 'xcp' to silently abort, 2) tells cp_check_end to
				xcp_arg("", "", {index=xcp_index}) 			-- do xcp again (with or without arg), which works normally now that
			end												-- table data is available.
		end
		xcp_retry_stat = 0				--Execute("xcp " .. xcp_index)				
	end

--	[[ general cp status functions ]]
	function player_start_new_cp()	-- called by line "good luck on your campaign" when starting new cp
		player_on_cp = "yes"
		can_get_new_cp = "no"
		local x = tonumber(gmcp("char.status.level"))
		cp_info_level = x
		current_activity = "cp"
		xg_draw_window()
		if (noexp_onoff == "on") and (anex_tnl_cutoff > 0) then
			ColourNote("#FF5000", "#000000", "Search and Destroy: Turning 'noexp' OFF (you have started a new CP)")
			anex_set_noexp("off")
		end
		do_cp_info()
	end  
	
	function cp_mob_killed()
		if (player_on_gq == "no") then
			xcp_retry_stat = 1
			qw_reset(false)
			if main_target_list[xcp_index] then
				main_target_list[xcp_index].color = "#404040"
			end
			xcp_clear_target(true)
			DoAfterSpecial(0.1, "do_cp_check()", 12)
		end
	end
		
	function player_level_up()
		can_get_new_cp = "yes"
		xg_draw_window()
	end
	
	function player_is_on_cp()
		player_on_cp = "yes"
	end

	function do_cp_complete(name, line, wildcards) 
		player_not_on_cp()
	end
		
	function player_not_on_cp()
		player_on_cp = "no"
		EnableTriggerGroup ("trg_campaign", false)
		cp_info_level = "0"
			SetVariable("mcvar_cp_level_taken", "0")
		cp_info_list = {}
		cp_check_list = {}
		if (player_on_gq == "yes") then
			-- do nothing, we don't want to clear our gq info
		else
			main_target_list = {}
			room_targets_ignored = {}
			area_room_type = "none"
			current_activity = "none"
			xcp_index = 0
			xg_draw_window()
		end
	end
 	
	function cp_check_can_get_new_cp()
		can_get_new_cp = "yes"
		anex_can_get_new_cp()
		xg_draw_window()
	end
	
	function cp_check_cannot_get_new_cp()
		can_get_new_cp = "no"
		anex_must_level_new_cp()
		xg_draw_window()
	end	
	
	function can_player_get_new_cp()
		return (can_get_new_cp == "yes") and true or false
	end

--	[[ Gquest beginning event messages: declare, join, start ]]
	function gqmsg_declared(name, line, wildcards)
		gqid_declared = wildcards.gq_id
			SetVariable("mcvar_gqid_declared", gqid_declared)
		gqid_joined = "-1"
			SetVariable("mcvar_gqid_joined", "-1")
		gqid_started = "-1"
			SetVariable("mcvar_gqid_started", "-1")
		gqid_extended = "-1"
			SetVariable("mcvar_gqid_extended", "-1")
	end
	
	function gqmsg_joined(name, line, wildcards)
		gqid_joined = wildcards.gq_id
		SetVariable("mcvar_gqid_joined", gqid_joined)
		if (gqid_joined == gqid_started) then
			EnableTriggerGroup("trg_gqmsg_2", true)
			do_gq_info()
		end
	end	
	
	function gqmsg_started(name, line, wildcards)
		gqid_started = wildcards.gq_id
		SetVariable("mcvar_gqid_started", gqid_started)
		if (gqid_started == gqid_joined) then
			EnableTriggerGroup("trg_gqmsg_2", true)
			do_gq_info()
		end
	end

--	[[ Gquest info functions ]]	
	function do_gq_info()
		if (gqid_joined ~= "-1") then
			xcp_clear_target(false)
			main_target_list = {}
			room_targets_ignored = {}
			gq_info_list = {}
			EnableTrigger("trg_gq_info_quest_name", true)
			SendNoEcho("gq info " .. gqid_joined)
			--DoAfterSpecial(0.1, [[ Send("gq info .. ]] .. gqid_joined .. [[")]], sendto.script)
		else
			print("\ndo_gq_info: You haven't joined a gquest.")
		end
	end

	function gq_info_quest_name(name, line, wildcards)
		local gqid = wildcards.gq_id
		if (gqid == gqid_joined) then
			EnableTrigger("trg_gq_info_quest_status", true)
			player_is_on_gq()
		else
			print("gq info name fail")
		end
	end
	
	function gq_info_quest_status(name, line, wildcards)
		local status = wildcards.status
		if (status == "Active") or (status == "Extended") then
			EnableTrigger("trg_gq_info_level_range", true)
		end
	end

	function gq_info_level_range(name, line, wildcards)
		local min = tonumber(wildcards.minlvl)
		local max = tonumber(wildcards.maxlvl)
		local eff = math.floor((min + max) / 2)
		gq_info_minlvl = min
			SetVariable("mcvar_gq_info_minlvl", min)
		gq_info_maxlvl = max
			SetVariable("mcvar_gq_info_maxlvl", max)
		gq_info_efflvl = eff
			SetVariable("mcvar_gq_info_efflvl", eff)
	end
	
	function gq_info_line(name, line, wildcards)
		local t = gq_info_list
		local mob = wildcards.mob
		local qty = wildcards.qty
		local loc = wildcards.loc
		local ord = #t+1
		table.insert(t, { mob=mob, qty=qty, loc=loc, ord=ord } )
	end
	
	function gq_info_end()
		player_is_on_gq()	-- more redundancy.  gq's are a pain
		area_room_type = area_room_type_check(gq_info_list)
		cp_info_level = tonumber(gmcp("char.status.level"))	-- room target builder will crash without a sensible value here.  Just use current player level.
		print("gq type detection: " .. area_room_type .. " (level " .. cp_info_level .. ")\n")
		xg_draw_window()
		DoAfterSpecial(0.1, "do_gq_check()", sendto.script)
	end
	
--	[[ Gquest check functions ]]	
	function do_gq_check()
		player_is_on_gq()
		local time_check = os.clock()					-- prevent double cp checks from different plugins
		if ((time_check - last_cp_check) < 1.0) then
			return
		end
		last_gq_check = time_check
		gq_check_list = {}
		EnableTrigger("trg_gq_check_line", true)
		DoAfterSpecial(0.1, 'SendNoEcho("gq ch")', sendto.script)
	end
	
	function gq_check_line(name, line, wildcards)
		local t = gq_check_list
		local mob = wildcards.mob
		local qty = wildcards.qty
		local loc = wildcards.loc
		local is_dead = (wildcards.isdead == "" and "no" or "yes")
		local ord = #t+1
		table.insert(t, { mob=mob, qty=qty, loc=loc, is_dead=is_dead, ord=ord })
	end
	
	function gq_check_end()
		player_is_on_gq()
		build_main_target_list("gq", area_room_type)
		if (xcp_retry_stat == 2) then						-- About xcp_retry_stat:
			if (xcp_index == 0) or (xcp_index == 1) then	
				xcp_retry_stat = 0							-- after killing gq mob, it's possible to 'xcp' after tables are cleared,
				xcp_noarg()									-- but before they're refreshed, which would cause 'xcp' to fail with the
			else											-- message "no data yet".  Instead, gq_mob_killed sets a flag that does
				xcp_retry_stat = 0							-- two things: 1) tells 'xcp' to silently abort, 2) tells gq_check_end to
				Execute("xcp " .. xcp_index)				-- do 'xcp' again (with or without arg), which works normally now that
			end												-- table data is available.
		end
		xcp_retry_stat = 0
	end

--	[[ Gquest general status functions ]]	
	function gq_mob_killed()
		if main_target_list[xcp_index] then
			local x = tonumber(main_target_list[xcp_index].qty) - 1
			main_target_list[xcp_index].qty = x
			if (#main_target_list > 1) then
				if x and (x > 0) then
					xg_draw_window()
					print_target_links(main_target_list)
				else
					qw_reset(false)
					xcp_retry_stat = 1
					main_target_list[xcp_index].color = "#404040"
					xcp_clear_target(true)
					DoAfterSpecial(0.1, "do_gq_check()", 12)
				end
			elseif (#main_target_list == 1) then
				if x and (x > 0) then
					xg_draw_window()
					print_target_links(main_target_list)
				else
					qw_reset(false)
					xcp_clear_target(false)
				end
			end
		else
			qw_reset(false)
			xcp_retry_stat = 1
			xcp_clear_target(false)
			DoAfterSpecial(0.1, "do_gq_check()", 12)
		end
	end

	function gqmsg_winner(name, line, wildcards)
		local gqid = wildcards.gq_id
		local winner = wildcards.winner
		local you = gmcp("char.base.name")
		if (winner == you) then
			ColourNote("#FFFFFF", "", "\nA WINNER IS YOU\n")
			player_not_on_gq()
		elseif (gqid == gqid_joined) then
			EnableTrigger("trg_gqmsg_extended_time", true)
			DoAfterSpecial(0.5, "gq_check_if_extended()", sendto.script)
		else
			-- do nothing, message is for a different gq.
		end
	end

	function gqmsg_extended_time(name, line, wildcards)
		local gqid = wildcards.gq_id
		if (gqid == gqid_joined) then
			gqid_extended = gqid
		end
	end

	function gq_check_if_extended()
		EnableTrigger("trg_gqmsg_extended_time", false)
		if (gqid_extended == gqid_joined) then
			-- do nothing
		else
			player_not_on_gq()
		end
	end
	
	function gq_check_not_yet_started(name, line, wildcards)
		gqid_started = "-1"
			SetVariable("mcvar_gqid_started", "-1")
	end	
	
	function player_is_on_gq()
		player_on_gq = "yes"
		current_activity = "gq"
	end

	function player_not_on_gq()
		EnableTriggerGroup("trg_gq", false)
		EnableTriggerGroup("trg_gqmsg_2", false)
		EnableTrigger("trg_gqmsg_extended_time", false)
		player_on_gq = "no"
		area_room_type = "none"
		current_activity = "none"
		gq_info_list = {}
		gq_check_list = {}
		main_target_list = {}
		room_targets_ignored = {}
		
		gqid_declared = "-1"
			SetVariable("mcvar_gqid_declared", gqid_declared)
		gqid_joined = "-1"
			SetVariable("mcvar_gqid_joined", gqid_joined)
		gqid_started = "-1"
			SetVariable("mcvar_gqid_started", gqid_started)
		gqid_extended = "-1"
			SetVariable("mcvar_gqid_extended", gqid_extended)
		
		gq_info_minlvl = "-1"
			SetVariable("mcvar_gq_info_minlvl", gq_info_minlvl)
		gq_info_maxlvl = "-1"
			SetVariable("mcvar_gq_info_maxlvl", gq_info_maxlvl)
		
		xcp_clear_target(true)
		
		if (player_on_cp == "yes") then
			DoAfterSpecial(0.4, [[ ColourNote("#FF5000", "#000000", "Reloading your cp targets....")
								do_cp_info() ]], sendto.script)
		end
	end
	
--	[[ Build main target list process path ]]
	function build_main_target_list(cp_or_gq, area_or_room)
		local cp_gq = cp_or_gq
		local ar_rm = area_or_room
		
		local sqla = " SELECT uid as arid, name as areaName " .. "FROM areas " .. "WHERE name = %s " .. "ORDER BY arid ASC "
		local sqlr = " SELECT r.uid as roomid, r.name as roomName, a.uid as arid, a.name as areaName, 'room' as link_type " .. "FROM rooms r " .. "INNER JOIN areas a ON r.area = a.uid " .. "WHERE r.name = %s " .. "ORDER BY arid ASC "
		if (ar_rm == "area") then
			main_target_list = build_area_targets(cp_gq, sqla)	
		elseif (ar_rm == "room") then
			main_target_list, room_targets_ignored = build_room_targets(cp_gq, sqlr, sqla)
		elseif (ar_rm == "none") then	-- should never be called but who knows
			print("main_target_list build error - tried to run while on " .. cp_gq .. " but area/room type is 'none'.")
		end
		xg_draw_window()
		print_target_links(main_target_list)
	end

	function build_area_targets(cp_gq, sqla)
		local t, list = {}, {}
		if (cp_gq == "cp") then
			list = cp_check_list
		elseif (cp_gq == "gq") then
			list = gq_check_list
		end
		local db = assert(sqlite3.open(mapper_db_file))
		for i,v in ipairs (list) do
			local dead = v.is_dead
			local cx
			local cy
			if (dead == "yes") then
				cx = "#484848"
				cy = "#900000"
			else
				cx = "#E0E0E0"
				cy = "#FF0000"
			end
			local results_found = false
			local select = string.format(sqla, fixsql(v.loc))
			for row in db:nrows(select) do
				results_found = true
				table.insert(t,
				{	mob = v.mob,
					arid = row.arid,
					qty = v.qty,
					is_dead = dead,
					color = cx,
					link_type = "area",
					index = #t+1,
					ord = v.ord } )
			end
			if (results_found == false) then
				table.insert(t, 
				{	mob = v.mob,
					location = v.loc, 
					arid = "-1", 
					qty = v.qty,
					is_dead = dead,
					color = cy,
					link_type = "unknown",
					index = #t+1,
					ord = v.ord } )
			end
		end
		db:close_vm()
		for i,v in ipairs (t) do
			v.kw = gmkw(v.mob, v.arid)
		end
		return t
	end
	
	function build_room_targets(cp_gq, sqlr, sqla)
		local t, ig, list = {}, {}, {}
		local level_taken
		if (cp_gq == "cp") then
			list = cp_check_list
			level_taken = tonumber(cp_info_level)
		elseif (cp_gq == "gq") then
			list = gq_check_list
			level_taken = tonumber(gq_info_efflvl)
		end
		local db = assert(sqlite3.open(mapper_db_file))
		for i,v in ipairs (list) do
			local dead = v.is_dead
			local cx -- color of link text
			local lt -- link type (area, room, unknown)
			if (dead == "yes") then
				cx = "#484848"
				lt = "area"
			else
				cx = "#E0E0E0"
				lt = "room"
			end
			local results_found = false
			local select = string.format(sqlr, fixsql(v.loc))
			local last_mob_sig = ""
			for row in db:nrows(select) do			-- if not row then / print("error - room db search returned no rows") / elseif not row.areaName then / print("area name missing from row") / end
				if (area_range_index[row.areaName]) then	-- don't include areas that never contain quest mobs
					results_found = true
					local mob_sig = row.arid .. "|" .. v.mob
					if (mob_sig ~= last_mob_sig) then
						last_mob_sig = mob_sig
						local area_min_lvl = (area_range_index[row.areaName].min) or 1
						local area_max_lvl = (area_range_index[row.areaName].max) or 300
						if (level_taken >= area_min_lvl) and (level_taken <= (area_max_lvl+25)) then	-- limit results to sensible level range.
							table.insert(t, {
								mob = v.mob,
								arid = row.arid,
								roomid = row.roomid,
								roomName = row.roomName,
								qty = v.qty,
								is_dead = dead,--v.is_dead,
								color = cx,	--((v.is_dead == false) and "#E0E0E0" or "#484848"),
								minlvl = area_min_lvl,
								maxlvl = area_max_lvl,
								link_type = lt,	--((v.is_dead == false) and "room" or "area"),	-- deals with dead mobs when area contains roomnames same as area name e.g. Aardington Estate
								index = #t+1,
								ord = v.ord	} )
								table.sort(t, function (a,b) return a.arid < b.arid end)
						else	
							table.insert(ig, {	-- build table of search results for areas out of your level range. 
								mob = v.mob,	-- Usually invalid, but valid links can wind up here if area's level range is too broad, or wrong.
								arid = row.arid,
								roomid = row.roomid,
								roomName = row.roomName,
								qty = v.qty,
								is_dead = dead,
								color = "#002460",
								minlvl = area_min_lvl,
								maxlvl = area_max_lvl,
								link_type = "ignored",
								index = #ig+1,
								ord = v.ord } )
								table.sort(t, function (a,b) return a.arid > b.arid end)
						end
					end
				end
			end
			if (results_found == false) then	-- no results were returned: either the mob is dead, or the location is unknown.
				if (dead == "yes") then	-- mob is dead
					local results_found = false
					local select = string.format(sqla, fixsql(v.loc))	-- dead mobs only give area name (even in room cp's) so search area info only.
					for dead_row in db:nrows(select) do	-- mob is dead, location is known
						results_found = true
						table.insert(t, { mob=v.mob, arid=dead_row.arid, qty = v.qty, is_dead="yes", color="#484848", link_type="area", index=#t+1, ord=v.ord } )
					end
					if (results_found == false) then	-- mob is dead, location is unknown
						table.insert(t, { mob=v.mob, arid="-1", location=v.loc, qty = v.qty, is_dead="yes", color="#900000", link_type="unknown", index=#t+1, ord=v.ord } )
					end
				else	-- mob is alive, but location is unknown
					table.insert(t, { mob=v.mob, arid="-1", location=v.loc, qty = v.qty, is_dead="no", color="#FF0000", link_type="unknown", index=#t+1, ord=v.ord } )
				end
			end
		end
		db:close_vm()
		for i,v in ipairs (t) do
			v.kw = gmkw(v.mob, v.arid)
		end
		return t, ig
	end
	
--	[[ Display target links in MUD window ]]
	function print_target_links(list)
		if (#room_targets_ignored > 0) then
			print_room_links_ignored()
		end
		if (#list > 0) then
			ColourNote("#808080", "", string.rep("-", 90))
			--[[if list[1].link_type == "room" then
				for _,v in ipairs(list) do
					if string.match(v.roomName, "^Hiding from") then
						v.arid = "zz" .. v.arid ]]--
						
			for i,v in ipairs (list) do
				local mob_text = v.mob .. ((v.is_dead == "no") and "" or " [Dead]")
				local link_text
				local tooltip
				local notehelp = "Show notes for item " .. i
				if (v.link_type == "area") then
					link_text = string.format(" %2d  %s - %s", padRight(i, 6, " "), padRight(mob_text, 32, " "), padRight(v.arid, 10, " "))
					tooltip = "Target cp mob " .. i .. " - " .. mob_text .. " (" .. v.arid .. ")"
					Hyperlink("xcp " .. i, link_text, tooltip, v.color, "", 0)
					Hyperlink("roomnote area " .. v.arid, "  [notes]", notehelp, ((v.is_dead == "yes") and "#006000" or "lightgreen"), "", 0)
				elseif (v.link_type == "room") then
					local roomText = string.format("%5s", v.roomid) .. ": '" .. v.roomName .. "'"
					link_text = string.format(" %2d  %s - %s  %s", padRight(i, 4, " "), padRight(mob_text, 32, " "), padRight(v.arid, 10, " "), padRight(roomText, 40, " "))
					tooltip = "Target cp mob " .. i .. " - " .. mob_text .. " (" .. v.arid .. ")"
					Hyperlink("xcp " .. i, link_text, tooltip, v.color, "", 0)
				elseif (v.link_type == "unknown") then
					link_text = string.format(" %2d  %s - unknown: '%s'", padRight(i, 4, " "), padRight(mob_text, 32, " "), v.location)
					tooltip = "Location not found in mapper database"
					Hyperlink(" ", link_text, tooltip, v.color, "", 0)
				end		
				print("")
			end
				ColourNote("#808080", "", string.rep("-", 90))
				ColourNote("#808080", "", "Type 'xcp <index>' or click link to go to that target.")
		else
			ColourNote("#FF5000", "", "   No target items to show.")
		end
	end

	function print_room_links_ignored()
		local ig = room_targets_ignored
		ColourNote("#808080", "", string.rep("-", 90))
		for i,v in ipairs (ig) do			
			local link = string.format(" ** Ignoring due to level: %s - %5s '%s' (%s) [%s-%s]", v.mob, v.roomid, v.roomName, v.arid, v.minlvl, v.maxlvl)
			Hyperlink("xmapper move " .. v.roomid, link, "Move to room " .. v.roomid, "#002460", "", 0)
			print("")
		end
	end

	
-- [[ "xcp" command ]]
	function xcp_noarg()	-- xcp with no argument given, so find the first available mob (alive, location known) and go to it.
		local t = main_target_list
		if (area_room_type == "none") then	-- abort if not on cp
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'xcp' aborted - you're not on a cp.\n")
		elseif (#t == 0) then	-- abort if on a cp, but target list is empty
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'xcp' aborted - cp is active but target list is empty.\n")
		else
			for i,v in ipairs (t) do	-- loop through list and try to find something to kill.
				if (v.is_dead == "no") and (v.link_type == "area" or v.link_type == "room") then	-- if mob is alive and location known, go to it.
					xcp_index = i
					xg_draw_window()
					xcp_goto_target(i)
					break
				else
					local index = i + 1
					if (index > #t) then 	-- if we reach this step, all mobs are dead and/or unknown.
						ColourNote("#FF5000", "", "\nSearch and Destroy: 'xcp' aborted - lack of targets (dead, or location unknown)")
					end
				end
			end
		end
	end
	
	function xcp_arg(name, line, wildcards)
		local index = tonumber(wildcards.index)
		local cp_list = main_target_list
		if (area_room_type == "none") then
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'xcp' aborted - you're not on a cp.\n")
		elseif (#cp_list == 0) then
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'xcp' aborted - cp is active but target list is empty.\n")
		elseif (index > #cp_list) or (index < 0) then	-- index doesn't exist
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'xcp' aborted - index doesn't exist (".. index .. ")\n")
		elseif (index == 0) then	-- clear xcp target
			xcp_clear_target(true)
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'xcp' current target cleared.\n")
		elseif (cp_list[index].link_type == "unknown") then -- or (cp_list[index].link_type == "unknown_room") then	-- abort if unknown
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'xcp' aborted - no mapper data for target (#" .. index .. ").\n")
		else	-- everything is in order, so go to mob.
			local ch_state = current_character_state
			if (ch_state == "3") then
				xcp_index = index
				xg_draw_window()
				xcp_goto_target(index)
			elseif (ch_state == "8") then
				ColourNote("#FF5000", "", "\nNot while you're fighting!")
			elseif (ch_state == "12") then
				ColourNote("#FF5000", "", "\nYou are already running!")
			end
		end
	end
	
	function xcp_goto_target(index)
		if (xcp_retry_stat == 0) then
			local t = main_target_list[index]
			local ri = current_room
			local action = xcp_action_mode
			gotoArea = -1
			gotoIndex = 1
			gotoList = {}
			if (t ~= nil) and (ri.rmid ~= nil) then
				full_mob_name = t.mob
				short_mob_name = t.kw
				if (t.link_type == "area") then	-- Area cp links - "xcp" goes to target area, then runs Hunt Trick to get target room.
					if (action == "qw") then
						local func = function() qw_exact(t.kw) end
						execute_in_area(t.arid, func)					
					elseif (action == "ht") then		-- do hunt trick or quick where after arriving in area.
						local func = function() Execute("ht " .. t.kw) end
						execute_in_area(t.arid, func)
					elseif (action == "off") then	-- do nothing
						ColourNote("#FF5000", "", "Xcp action is off - no additional action\n")
					end
					if (ri.arid ~= t.arid) then	-- if you're not in target area, xrunto target area.
						--Execute("xrt " .. t.arid)
						xrun_to("", "", {destination=t.arid})
					end
				else	-- Room cp:  get target room from mapper, but don't move yet.  "go" takes you to room.
					search_rooms(t.roomName .. "|" .. t.arid, "area", t.kw)
				end
			else
				ColourNote("#FF5000", "", "No item exists, or data is busy")
			end
		else
			xcp_retry_stat = 2
		end
	end
	
	function xcp_clear_target(bool)
		short_mob_name = -1
		full_mob_name = -1
		xcp_index = 0
		gotoArea = -1
		gotoIndex = 0
		gotoList = {}
		if (bool == true) then
			xg_draw_window()
		end
	end
	
	function xcp_set_action_mode(name, line, wildcards)
			local opt = wildcards.option or ""
			local options = {
				["ht"] = "ht - do hunt trick",
				["qw"] = "qw - do quick where",
				["off"] = "off - no additional action",
				}
			if (opt == "ht") or (opt == "qw") or (opt == "off") then
				xcp_action_mode = opt
				SetVariable("mcvar_xcp_action_mode", opt)
				ColourNote("#00C040", "", "Set 'xcp' mode to: " .. options[opt] .. ".")
			elseif (opt == "") then
				ColourNote("#FF5000", "", "Current 'xcp' mode: " .. options[xcp_action_mode] .. ".")
				ColourNote("#FF5000", "", "Syntax: 'xcp mode [ht|qw|off]'")
			else
				ColourNote("#FF5000", "", "Invalid 'xcp' mode given.  Syntax: 'xcp mode [ht|qw|off]'")
			end
			print("")
	end

-- [[  Goto area (xrt), goto room (go), goto next (nx), goto previous (nx-) ]]
	local xrun_to_sql_uid =  "SELECT r.uid, r.name as room, r.area " .. "FROM rooms r " .. "WHERE r.area like %s " .. "ORDER BY r.name "
	local xrun_to_sql_name = "SELECT r.uid, r.name as room, r.area " .. "FROM rooms r " .. "INNER JOIN areas a ON a.uid = r.area " .. "WHERE r.area like %s OR a.name like %s " .. "ORDER BY r.name "

	function xrun_to(name, line, wildcards)
		local ri = current_room
		local arid = wildcards.destination
		if (arid == "ft2") then arid = "ftii" end
		local rmid = get_start_room(arid)
		if (rmid == "-1") then		-- area has no start room defined.
			ColourNote("#FF5000", "", "X-runto: No default start room is defined for area: " .. arid .. ".\n")
			SendNoEcho("areas 1 299 keywords " .. arid)
		else
			ColourNote("#FF5000", "", "X-runto: " .. arid .. ", room ID: " .. rmid .. " (" .. start_room_type .. ")\n")
			goto_room_id(rmid, arid)
		end	
	end
	
	function goto_room_id(rmid, arid)	-- go to specific room id (do not confuse with goto_number, see below)
		local ri = current_room
		local rmid = rmid
		local arid = arid or getAreaFromRoomId(rmid)
		if (is_vidblain_area(rmid) == true) then -- if target is in a vidblain area,
			if(is_vidblain_area(ri.rmid) == false) then	-- but if you are not
				vidblain_nav(rmid, arid)
			else
				do_mapper_goto(rmid, "walk")
			end
		else
			do_mapper_goto(rmid)
		end
	end

function goto_number(name, line, wildcards)
		local ch_state = current_character_state
		if (ch_state == "3") then
			gotoIndex = tonumber(wildcards.index) or 1
			if gotoList[gotoIndex] then
				if (tonumber(gotoList[gotoIndex]) == nil) then
					xrun_to("", "", {destination=gotoList[gotoIndex]})
					quick_scan()
				else
					next_room = gotoList[gotoIndex]
					goto_room_id(gotoList[gotoIndex])
					quick_scan()
				end
			else
				ColourNote("#FF5000", "", "Goto room result (go) aborted - No destination yet.")
			end
		elseif (ch_state == "8") then
			ColourNote("#FF5000", "", "\nNot while you're fighting!")
		elseif (ch_state == "12") then
			ColourNote("#FF5000", "", "\nYou are already running!")
		else
			ColourNote("#FF5000", "", "\nGoto room result (go):  Can't do that now - you must be standing and ready.")
		end
	end
	
	function goto_next(name, line, wildcards)
		local ch_state = current_character_state
		if (ch_state == "3") then
			if (next_room == nil) or (next_room == "") or (not tonumber(next_room)) then
				ColourNote("#FF5000", "", "Goto next (nx) aborted - No data yet.")
			else
				if (tonumber(next_room) == tonumber(gmcp("room.info.num"))) and (gotoIndex < #gotoList) then
					gotoIndex = gotoIndex + 1
				end
				if gotoList[gotoIndex] then
					ColourNote("#00C040", "", "Next room (nx) - " .. gotoIndex .. " of " .. #gotoList)
					next_room = gotoList[gotoIndex]
					do_mapper_goto(next_room)
					quick_scan()
				else
					ColourNote("#FF5000", "", "Goto next (nx) aborted - No more rooms.")
				end
			end
		elseif (ch_state == "8") then
			ColourNote("#FF5000", "", "\nNot while you're fighting!")
		elseif (ch_state == "12") then
			ColourNote("#FF5000", "", "\nYou are already running!")
		else
			ColourNote("#FF5000", "", "\nGoto next room (nx):  Can't do that now - you must be standing and ready.")
		end
	end	
	
	function goto_previous(name, line, wildcards)
		local ch_state = current_character_state
		if (ch_state == "3") then
			if (next_room == nil) or (next_room == "") or (not tonumber(next_room)) then
				ColourNote("#FF5000", "", "Goto previous (nx-) aborted - No data yet.")
			else
				if (tonumber(next_room) == tonumber(gmcp("room.info.num"))) and (gotoIndex > 1) then
					gotoIndex = gotoIndex - 1
				end
				if gotoList[gotoIndex] then
					ColourNote("#00C040", "", "Previous room (nx-) - " .. gotoIndex .. " of " .. #gotoList)
					next_room = gotoList[gotoIndex]
					do_mapper_goto(next_room)
					quick_scan()
				else
					ColourNote("#FF5000", "", "Goto previous (nx-) aborted - No more rooms.")
				end
			end
		elseif (ch_state == "8") then
			ColourNote("#FF5000", "", "\nNot while you're fighting!")
		elseif (ch_state == "12") then
			ColourNote("#FF5000", "", "\nYou are already running!")
		else
			ColourNote("#FF5000", "", "\nGoto previous room (nx-):  Can't do that now - you must be standing and ready.")
		end
	end	
	
--	[[ Vidblain navigation ]]
	function vidblain_nav(rmid, arid)
		local ch_state = current_character_state
		vidblain_nav_tbl = { i=0, j=0, rmid=rmid, arid=arid, stat=ch_state }
		EnableTimer("execute_in_area_timer", false)
		EnableTimer("vidblain_nav_timer", true)
		Execute("mapper goto 11910") -- move to vidblain and enter the portal
		Execute("enter hole")
	end 

	function vidblain_nav_tick()
		local ri = current_room
		local ch_state = current_character_state
		local vnt = vidblain_nav_tbl
		local eiat = execute_in_area_tbl
		if (ri.arid ~= nil) and (ch_state ~= nil) then
			if (ri.arid ~= "vidblain") then	-- not in vidblain yet
				vnt.i = vnt.i + 1
				if (vnt.i > 200) then
					EnableTimer("vidblain_nav_timer", false)
					xcp_clear_target(true)
					ColourNote("#FF5000", "", "** vidblain nav:  abort timer - took too long to get to destination.")
					vidblain_nav_tbl = { i=0, j=0, rmid="", arid="", stat=1 }
				end
			else  -- arrived in vidblain proper
				if (ch_state == "3") and (ch_state == vnt.stat) then  -- monitor char state for 3 ticks, if stable, start EIA timer and run to target area 
					vnt.j = vnt.j + 1
					if (vnt.j > 3) then
						EnableTimer("vidblain_nav_timer", false) -- stop vidblain timer
						do_mapper_goto(vnt.rmid, "walk")
						execute_in_area(vnt.arid, eiat.f)	-- start EIA timer
						vidblain_nav_tbl = { i=0, j=0, rmid="", arid="", stat=1 }
					end
				else
					vnt.stat = ch_state
				end
			end
		end
	end
	
--	[[ Execute in Area ]]	
	function execute_in_area(arid, func)	-- id is the process or function calling this one.
		local ri = current_room
		local ch_state = current_character_state
		local fn
		if (type(func) == "function") then
			fn = func
		else
			fn = function () end
		end
		execute_in_area_tbl = { i=0, j=0, arid=arid, f=fn, stat=ch_state }
		if (ri.arid == arid) then	-- in target area
			func()
			execute_in_area_tbl = { i=0, j=0, arid="", f="", stat=1 }
		elseif (ri.arid == nil) then	--
			print("execute_in_area - nil area name")
			send_gmcp_packet("request room")
		else
			EnableTimer("execute_in_area_timer", true)
		end
	end
	
	function execute_in_area_tick()
		local ri = current_room
		local ch_state = current_character_state
		local eiat = execute_in_area_tbl
		if (ri.arid ~= nil) and (ch_state ~= nil) then
			if (ri.arid ~= eiat.arid) then
				eiat.i = eiat.i + 1
				if (eiat.i > 200) then
					EnableTimer("execute_in_area_timer", false)
					xcp_clear_target(true)
					ColourNote("#FF5000", "", "** execute-in-area:  abort timer - took too long to get to destination.")
					execute_in_area_tbl = { i=0, j=0, arid="", f="", stat=1 }
				end
			else
				if (ch_state == "3") and (ch_state == eiat.stat) then
					eiat.j = eiat.j + 1
					if (eiat.j > 3) then
						EnableTimer("execute_in_area_timer", false)
						eiat.f()
						--eiat.f()
					end
				else
					eiat.stat = ch_state
					if (ch_state == "8") then
						EnableTimer("execute_in_area_timer", false)	--ColourNote("#FF5000", "", "** execute-in-area:  in combat -> reduce timer rate")
						DoAfterSpecial(1.5, [[ EnableTimer("execute_in_area_timer", true) ]], 12)
					end
				end
			end
		end
	end
	
	function execute_in_room(rmid, func)
	
	end
	
	function execute_in_room_tick()
	
	end
	
--	[[ quick where ]]
	function qw_reset(bool)
		EnableTrigger("trg_quick_where_match", false)
		EnableTrigger("trg_quick_where_no_match", false)
		if (bool == true) then
			qw = { index = 1, exact = true }
		else
			qw = { index = 1, exact = false }
		end
	end
	
	function qw_noarg()
		local ix = qw.index or 1
		local s = short_mob_name or -1
		if (s == -1) then
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'Quick-where' has no target.")
			ColourNote("#FF5000", "", "Use 'xcp', 'qw <mob>, or 'ht <mob>' to get target info.\n")
		else
			if (qw.exact == true) then
				qw_exact()
			else
				do_quick_where(ix, s)
			end
		end
	end
	
	function qw_arg(name, line, wildcards)
		local t = main_target_list
		local s = wildcards.mob
		local ix = tonumber(wildcards.index) or 1
		short_mob_name = s
		qw.index = ix
		qw.exact = false
		do_quick_where(ix, s)
	end
	
	function qw_exact()  -- called from code, e.g. xcp function
		local t = main_target_list[xcp_index]
		if (t) then
			local f = t.mob
			local s = t.kw
			full_mob_name = f
			short_mob_name = s
			local ix = qw.index or 1
			local p1 = split(f, "[^ ]+")
			local p2
				for i,v in ipairs (p1) do
					if gmkw_omit[v] then
						-- do nothing
					else
						p2 = (p2 == nil) and v or p2 .. " " .. v
					end
				end	
			qw.exact = true
			qw.match = p2
			do_quick_where(ix, s)
		else
			print("\nqw exact: You have no 'xcp' target.")
		end
	end
		
	function do_quick_where(ix, s)
		EnableTrigger("trg_quick_where_match", true)
		EnableTrigger("trg_quick_where_no_match", true)
		if (ix == 1) then	-- don't use 1.mob
			Send(string.format("where %s", s))
		else
			Send(string.format("where %s.%s", ix, s))
		end
	end

	function qw_match(name, line, wildcards)
		local mob = wildcards.mobname
		local room = wildcards.roomname
		local parts
		local found = false
		qw.index = qw.index or 1
		if (qw.exact == true) then	-- tells this function to look for an exact match for the current xcp target mob name.
			if (Trim(mob) == Trim(string.sub(full_mob_name, 1, 30))) then
				found = true
			end
		else
			parts = split(string.lower(short_mob_name), "[^ ]+")
			for i=1, #parts do
				if (string.find(string.lower(mob), parts[i], 1, true) ~= nil) then
					found = true
					break -- leave loop
				end
			end
		end
		if (found == false) then	-- not our line, keep looking
			qw.index = qw.index + 1
			if (qw.index < 101) then
				SendNoEcho(string.format("where %s.%s", qw.index, short_mob_name))
				return
			else
				print("qw: too many fails")
				found = true
				return
			end
		end
		qw_reset(qw.exact)
		local cmd = "xm { } " .. room
		Execute(cmd)
	end
		
	function qw_no_match()	-- responds to "There is no <mob name> around here."
		qw_reset(qw.exact)
	end
		
--	[[ Hunt trick ]]
	function ht_reset()
		EnableTriggerGroup("HuntTrick", false)
		ht = { index = 1 }
	end
	
	function ht_noarg()
		local s = short_mob_name or -1
		local ix = ht.index or 1
		if (s == -1) then
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'Hunt trick' has no target.")
			ColourNote("#FF5000", "", "Use 'xcp', ht <mob>', or 'qw <mob>' to pick a target.\n")
			return
		end
		do_hunt_trick(ix, s)
	end	
	
	function ht_arg(name, line, wildcards)
		local s = wildcards.mob
		local ix = tonumber(wildcards.index) or 1
		short_mob_name = s
		do_hunt_trick(ix, s)
	end 
	
	function do_hunt_trick(ix, s)
		ht.index = ix or 1
		EnableTriggerGroup("AutoHunt", false)
		EnableTriggerGroup("HuntTrick", true)
		if (ix == 1) then	-- don't use "1.mob"
			Send(string.format("hunt %s", s))
		else
			Send(string.format("hunt %s.%s", ix, s))
		end
	end
	
	function ht_continue()
		local s = short_mob_name
		local ix = (ht.index + 1) or 1
		do_hunt_trick(ix, s)
	end
	
	function ht_complete(name, line, wildcards)
		EnableTriggerGroup("AutoHunt", false)
		local s = short_mob_name
		local ix = ht.index or 1
		qw_arg("", "", {index=ix, mob=s})
		ht_reset()
	end
	
	function ht_abort(name, line, wildcards)
		EnableTriggerGroup("HuntTrick", false)
		ht = {}
		ColourNote("#FF5000", "", "Search and Destroy:  Hunt trick cancelled.")
	end

-- [[ quick scan, quick kill ("kk") ]]	
	function quick_scan()
		if (short_mob_name == nil) or (short_mob_name == "") then
			SendNoEcho("scan")
		else
			SendNoEcho(string.format("scan %s", short_mob_name))
		end
	end
	
	function quick_kill(name, line, wildcards)
		if (short_mob_name == nil) or (short_mob_name == "") or (short_mob_name == "-1") then
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'Quick-kill' has no target.  Use 'ht', 'qw', or 'xcp' to select a target.\n")
		else
			Send(quick_kill_command .. " '" .. short_mob_name .. "'")
		end
	end
	
	function xset_quick_kill_command(name, line, wildcards)		-- user-defined attack to use with qk/kk
		if (wildcards.arg == "") then
			ColourNote("#FF5000", "", "Search and Destroy: Quick-kill command currently set to: '" .. quick_kill_command .. "'")
		else
			quick_kill_command = wildcards.arg
			SetVariable("mcvar_quick_kill_command", quick_kill_command)
			ColourNote("#FF5000", "", "Search and Destroy: Quick-kill command is now set to: '" .. quick_kill_command .. "'")
		end
	end 
	
-- [[ Room search processes ]]	
	local search_rooms_sql = 
		"SELECT r.uid as uid, r.name as name, info, r.area as area, " ..
		"ifnull(a.name, r.area) as area_name, 1 as DisplayOrder " .. 
		"FROM rooms r " ..
		"LEFT OUTER JOIN areas a ON r.area = a.uid " ..
		"WHERE r.name = %s " .. -- room
		"AND (%s = 'all' OR (a.name = %s OR r.area = %s)) " .. -- area_id x3
		"UNION " ..
		"SELECT r.uid, r.name, info, r.area, " ..
		"ifnull(a.name, r.area) as area_name, 0 as DisplayOrder " .. 
		"FROM rooms r " ..
		"LEFT OUTER JOIN areas a ON r.area = a.uid " ..
		"WHERE r.name <> %s " ..	-- room
		"AND r.name LIKE %s " .. 	-- like
		"AND (%s = 'all' OR (a.name = %s OR r.area = %s)) " .. -- area_id x3
		"ORDER BY area, DisplayOrder DESC "
			
	function search_rooms(room_name, searchType, fullMobName)
		if (room_name == nil) or (room_name == "") then
			Note("map_area() error : room name isn't known")
		else
			local ri = current_room
			local parts = split(room_name, "[^|]+") -- pipe delimited:  room|area
			local room = parts[1]
			local arid
			if (#parts == 2) then
				arid = parts[2]
			else
				if (current_room ~= nil) then
					arid = ri.arid
				else
					ColourNote("#FF5000", "", "Area not known, falling back to mapper list")
					Execute("mapper list " .. parts[1])
				end
			end
			if (room == nil) then
				Note("map_area() - Room not known")
				return
			end
			local like = "%"..room.."%"
			-- i forget what this does? Strip out a leading " ?
			--if string.sub(room,1,1) == "\"" and string.sub(room,-1) == "\"" then
			--	like = string.sub(room,2,-2)
			--end
			local select = string.format(search_rooms_sql,	fixsql(room), 
															fixsql(arid), fixsql(arid), fixsql(arid), 
															fixsql(room), 
															fixsql(like), 
															fixsql(arid), fixsql(arid), fixsql(arid))
			local db = assert(sqlite3.open(mapper_db_file))
			local results = {}
			local roomid_list = {}
			for row in db:nrows(select) do
				local id = (tonumber(row.uid) or -1) -- sanitize text room ids for "unmappable" (nomap) rooms that are now being mapped
				results[#results + 1] = { 
					rmid = id, 
					name = row.name,
					info = row.info,
					area = row.area_name,
					arid = row.area } --or row.area_name } -- make safe against bad dbs			
				if (id > 0) then	-- make a list of room ids
					roomid_list[#roomid_list + 1] = id
				end
				
			end   -- finding rooms
			db:close_vm()
			search_rooms_results(results)
		end
	end
	
	function search_rooms_results(results)	-- Display list of 'go' links from hunt-trick, quick-where, etc.
		gotoArea = -1
		gotoIndex = 1
		gotoList = {}
		mapper_area_index = 0
		local last_area = ""
			ColourNote("#808080", "", "\nIndex    Location     (uid)")
			ColourNote("#808080", "", string.rep("-", 67))
		for i,v in ipairs (results) do
			if (last_area ~= v.arid) then
				if (mapper_area_index == 0) then
					local areaLine = string.format("~~~ %2d   %s", mapper_area_index, v.arid)
					Hyperlink("go " .. mapper_area_index, areaLine, "go to area " .. v.arid, "silver", "", 0)
					gotoList[mapper_area_index] = v.arid
					gotoArea = v.arid
					mapper_area_index = mapper_area_index + 1
				else
					local areaLine = string.format("~~~   %s", v.arid)
					Hyperlink("xrt " .. v.arid, areaLine, "go to area " .. v.arid, "silver", "", 0)
				end				
				print("")
				last_area = v.arid				
			end
			local line1 = string.format("~~~ %2d   ", mapper_area_index)
			Hyperlink("go " .. mapper_area_index, line1, "go to item " .. mapper_area_index, "lightblue", "", 0)
			local line2 = string.format("%s  (%s) ", padRight(string.gsub(v.name, "@[a-zA-Z]", ""), 40, " "), v.rmid)
			Hyperlink("go " .. mapper_area_index, line2, "go to item " .. mapper_area_index, "lightblue", "", 0)
			Hyperlink("mapper where " .. v.rmid, "   {sw}", "click for speedwalk to this room", "#FF5000", "", 0)
			gotoList[mapper_area_index] = v.rmid
			print("")
			mapper_area_index = mapper_area_index + 1
		end
		if (mapper_area_index == 0) then 
			ColourNote("#FF5000", "", "No matching rooms found.")
		end
		ColourNote("#808080", "", string.rep("-", 67))
		ColourNote("#808080", "", "Type 'go <index>' or click link to go to that room.\n")
	end
	
	function map_area(name, line, wildcards)
		search_rooms(wildcards.loc, 'area', wildcards.mob)
	end
	
	function map_area_all(name, line, wildcards)
		search_rooms(wildcards.loc .. "|all", 'all', wildcards.mob)
	end

--	[[ "xwhere" command ]]
	function do_xwhere(name, line, wildcards)
		local n1 = tonumber(wildcards.n1) or 12	-- if no number given, default to 12
		local n2 = tonumber(wildcards.n2) or ""
		local mob = wildcards.mob or ""
		if (mob == "") then						-- user entered no numbers, no mobname, or no args at all
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'xwhere' required parameter missing.\n")
			ColourNote("#FF5000", "", "              Syntax: 'xwhere <mobname>'")		-- default to 10
			ColourNote("#FF5000", "", "                      'xwhere <n1> <mobname>'")	-- where 1.mobname to n1.mobname
			ColourNote("#FF5000", "", "                      'xwhere <n1> <n2> <mobname>'")	-- where 1.mobname to n2.mobname
			return
		elseif (n2 == "") then	-- user entered one number (n1) and a mobname, but no second number (n2)
			ColourNote("#00C040", "", "\nSearch and Destroy: 'xwhere" .. " " .. n1 .. " " .. mob .. "'")
			for i = 1, n1, 1 do
				if (i == 1) then
					Send("where " .. mob)
				else
					Send("where " .. i .. "." .. mob)
				end
			end
		elseif (mob ~= "") and (n2 ~= "") then	-- user entered n1, n2, and mobname
			ColourNote("#00C040", "", "Search and Destroy: 'xwhere" .. " " .. n1 .. " " .. n2 .. " " .. mob .. "'")
			for i = n1, n2, 1 do
				if (i == 1) then
					Send("where " .. mob)
				else
					Send("where " .. i .. "." .. mob)
				end
			end
		else
			ColourNote("#FF1000", "", "Search and Destroy: 'xwhere' data entry problem!")
		end
	end
	
--	[[ Autohunt ]]
	function auto_hunt(name, line, wildcards)
		local s = string.lower(wildcards.arg)
		if (s == "abort") or (s == "cancel") or (s == "0") then
			auto_hunt_abort()
		else
			ht_reset()
			EnableTriggerGroup("AutoHunt", true)				auto_hunt_mob = s
			Send("hunt " .. s)
		end
	end 
	
	function auto_hunt_abort()
		auto_hunt_reset()
		ColourNote("#FF5000", "", "Search and Destroy:  Auto-hunt cancelled.\n")
	end 

	function auto_hunt_complete()
		auto_hunt_reset()
		ColourNote("#00C040", "", "Search and Destroy: Auto-hunt complete.\n")
	end
	
	function auto_hunt_lowskill()
		ColourNote("#FF5000", "", "\nSearch and Destroy:  Autohunt not available - hunt skill is too low.")
		ColourNote("#FF5000", "", "                     If hunt skill is available, practice it to 85% or higher.")
		auto_hunt_reset()
	end

	function auto_hunt_move(direction)
		local ri = current_room
		local dir = dir_map[direction]
		auto_hunt_direction = dir
		if (ri) then	-- don't know our gmcp exits, so just go with it
			if (ri.exits[dir] == nil ) then	-- exit is visible in gmcp
				Send("open " .. dir)	
			end		
		end
		Send(dir)
	end
			
	function auto_hunt_next(name, line, wildcards)
		local dir = wildcards.dir
		auto_hunt_move(dir)
		Send("hunt " .. auto_hunt_mob)
	end
	
	function auto_hunt_door()
		EnableTrigger("trg_autohunt_next_1", false)
		EnableTrigger("trg_autohunt_next_2", false)
		Send("open " .. auto_hunt_direction)
	end

	function auto_hunt_door_open()
		EnableTrigger("trg_autohunt_next_1", true)
		EnableTrigger("trg_autohunt_next_2", true)
		Send(auto_hunt_direction)
		Send("hunt " .. auto_hunt_mob)
	end
	
	function auto_hunt_portal()
		ColourNote("#00C040", "", "\nSearch and Destroy: Auto-hunt through portals not working yet.  Enter portal manually and then autohunt again.")
		auto_hunt_reset()
	end
			
	function auto_hunt_reset()
		EnableTriggerGroup("AutoHunt", false)
		auto_hunt_mob = ""
		auto_hunt_direction = ""
		autoHuntData = { count = 0, north = 0, south = 0, east = 0, west = 0, up = 0, down = 0 }
	end

--	[[ Automatic noexp ]]
	function xset_noexp_tnl(name, line, wildcards)		-- called by alias: "xset noexp" when argument given
		local set_tnl = wildcards.arg or "-1"
		if (anex_automatic_onoff == "on") then
			if (wildcards.arg == "-1") or (wildcards.arg == "") or (wildcards.arg == nil) then
				if (anex_tnl_cutoff == 0) then
					ColourNote("#FF5000", "", "Search and Destroy: Auto 'noexp' is currently OFF.")
				else
					ColourNote("#FF5000", "", "Search and Destroy: Auto 'noexp' is ON and set to " .. anex_tnl_cutoff .. " TNL.\n")
				end
			elseif (wildcards.arg == "off") or (wildcards.arg == "0") then	-- "xset noexp off" and "xset noexp 0" turn auto-noexp off.
				EnableTrigger("trg_anex_mobdeath_xp1", false)
				anex_tnl_cutoff = 0
				SetVariable("mcvar_anex_tnl_cutoff", anex_tnl_cutoff)
				ColourNote("#FF5000", "", "\nSearch and Destroy: Auto 'noexp' is now OFF.\n")
			else											-- xset with any other (positive) number turns auto-noexp on.
				EnableTrigger("trg_anex_mobdeath_xp1", true)
				anex_tnl_cutoff = tonumber(set_tnl)
				SetVariable("mcvar_anex_tnl_cutoff", anex_tnl_cutoff)
				ColourNote("#FF5000", "", "\nSearch and Destroy: Auto 'noexp' now set to " .. anex_tnl_cutoff .. " TNL.\n")
			end
		else
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'noexp' is *manually* OFF." ..
									"\nType 'noexp' again to turn it back on.")
		end
		xg_draw_window()
	end
	
	function anex_set_noexp(x)
		if (anex_automatic_onoff) == "on" then
			if (x == "on") or (x == "off") then
				noexp_onoff = x
				send_gmcp_packet("config noexp " .. x)
				print("noexp: " .. noexp_onoff)
			end
		else
			noexp_onoff = "off"
		end
		xg_draw_window()
	end
	
	function anex_can_get_new_cp()		-- called by line 'You may take campaign this level.' in 'cp check'
		if (anex_automatic_onoff == "on") then
			if (anex_tnl_cutoff > 0) then	-- if anex_tnl_cutoff > 0 then auto-noexp is on.
				local level = tonumber(gmcp("char.status.level"))
				if (level < 200) then
					local tnl = tonumber(gmcp("char.status.tnl"))
					if (tnl < anex_tnl_cutoff) and (noexp_onoff == "off") then		-- tnl less than set point and noexp is off --> turn that shit on
						anex_set_noexp("on")
						ColourNote("#FF5000", "", "\nSearch and Destroy: Turning 'noexp' ON (Your TNL is less than " .. anex_tnl_cutoff .. ")")
					elseif (tnl > anex_tnl_cutoff) and (noexp_onoff == "on") then	-- if over min TNL and noexp is on --> turn noexp off regardless
						anex_set_noexp("off")
						ColourNote("#FF5000", "", "\nSearch and Destroy: Turning 'noexp' OFF (your TNL is greater than " .. anex_tnl_cutoff .. ")")
					end
				else
					if (noexp_onoff == "on") then
						anex_set_noexp("off")
						ColourNote("#FF5000", "#000000", "\nSearch and Destroy: Turning noexp OFF (you have reached level ".. plevel ..")")
					end
				end
			else 	-- feature is turned off, just show reminder
				anex_tnl_cutoff = 0	-- set to 0 if somehow negative
				ColourNote("#FF5000", "", "Automatic 'noexp' is currently turned OFF.\n")
			end
		end
	end
	
	function anex_must_level_new_cp()	-- called by trigger:  You must level to get a new campaign
		if anex_automatic_onoff == "on" then
			if (anex_tnl_cutoff > 0) then
				local level = tonumber(gmcp("char.status.level"))
				if (level < 200) then	
					if (noexp_onoff == "on") and (player_on_cp == "yes") then			
						ColourNote("#FF5000", "", "Search and Destroy: Turning noexp OFF (must level to get new cp)")
						anex_set_noexp("off")
					end
				else
					if (noexp_onoff == "on") then
						anex_set_noexp("off")
						ColourNote("#FF5000", "", "Search and Destroy: Turning noexp OFF (you have reached level ".. level ..")")
					end
				end
			end
		end
	end
	
	function anex_mobdeath_xp1(name, line, wildcards)	-- called when mob kill awards xp
		if (anex_automatic_onoff == "on") then
			local level = tonumber(gmcp("char.status.level"))
			if (anex_tnl_cutoff > 0) then
				if (level < 200) then
					DoAfterSpecial(0.1, [[ anex_mobdeath_xp2() ]], 12)
				else
					if (noexp_onoff == "on") then
						anex_set_noexp("off")
						ColourNote("#FF5000", "", "Search and Destroy: Turning noexp OFF (you have reached level ".. level ..")")
						ColourNote("#FF5000", "", "                    Use 'xset noexp off' to override.")
					end
				end
			end
		end
	end
	
	function anex_mobdeath_xp2()	-- called via timer set by function anex_mobdeath_xp1
		if (anex_automatic_onoff == "on") then
		local tnl = tonumber(gmcp("char.status.tnl"))
		if (can_get_new_cp == "yes") then
			if (tnl < anex_tnl_cutoff) then
				if (noexp_onoff == "off") then
					anex_set_noexp("on")
					ColourNote("#FF5000", "", "\nSearch and Destroy: Turning 'noexp' ON (your TNL is less than " .. anex_tnl_cutoff .. ")")
				end
			else
				if (noexp_onoff == "on") then
					anex_set_noexp("off")
					ColourNote("#FF5000", "", "\nSearch and Destroy: Turning 'noexp' OFF (your TNL is greater than " .. anex_tnl_cutoff .. ")")
				end
			end
		else
			if (noexp_onoff == "on") then
				anex_set_noexp("off")
				ColourNote("#FF5000", "", "\nSearch and Destroy: Turning 'noexp' OFF (you must level before taking a new campaign)")
			end
		end
		end
	end
	
	function anex_check_tnl_silent()	-- used by the window's clickable TNL cutoff changer
		local tnl = tonumber(gmcp("char.status.tnl"))
		if (can_get_new_cp == "yes") then
			if (tnl < anex_tnl_cutoff) then
				if (noexp_onoff == "off") then
					anex_set_noexp("on")
				end
			else
				if (noexp_onoff == "on") then
					anex_set_noexp("off")
				end
			end
		else
			if (noexp_onoff == "on") then
				anex_set_noexp("off")
			end
		end
	end
	
	function anex_automatic_on()	-- Noexp will toggle automatically according to the TNL setting.
		anex_automatic_onoff = "on"
		noexp_onoff = "off"
		SetVariable("mcvar_anex_automatic_onoff", "on")
		xg_draw_window()
	end
	
	function anex_automatic_off()	-- Manually turns off experience and disables automatic toggling.  Typing noexp again turns the automatics back on.
		anex_automatic_onoff = "off"
		noexp_onoff = "on"
		SetVariable("mcvar_anex_automatic_onoff", "off")
		xg_draw_window()
	end
	
--	[[ ****** WHERE TRICK FUNCTIONS ***** ]]
	--[[local wt = { index = 1, name = "", match = "" }	
		function wt_continue(name, line, wildcards)	
			wt.index = wt.index + 1
			Send("wt " .. wt.index .. "." .. wt.name)
		end	
		function wt_fail(name, line, wildcards)	
			EnableTriggerGroup("wt", false)
			Note("Search and Destroy: Aborting where trick...")
		end	]]

 	
	function xset_to_mark(name, line, wildcards)
		local ri = current_room
		area_start_rooms[ri.arid] = {}
		area_start_rooms[ri.arid].roomid = ri.rmid
		tprint(area_start_rooms)
		local serial = serialize.save_simple(area_start_rooms)
		SetVariable("mcvar_areaStartRooms", serial)
		ColourNote("#FF5000", "", "\nxset mark: Room ",
				"#00C040", "", ri.rmid,
				"#FF5000", "", " set as start of area ",
				"#00C040", "", ri.arid,
				"#FF5000", "", ".\n")
	end
 	
	function get_start_room(area_id)
		local arid = string.lower(area_id)		
		start_room_type = "xset mark"					-- If 'xset mark' was set, xrunto will go there.
		if (area_start_rooms[arid] ~= nil) then 			-- Function exits as soon as any 'return' statement is encountered.
			return area_start_rooms[arid].roomid			-- Exact match on area id
		end
		for k,v in pairs (area_start_rooms) do			
			if (string.match(string.lower(k), arid) ~= nil) then 				
				return v.roomid	-- string match on key
			end
		end
		start_room_type = "default"						-- If 'xset mark' isn't set, look up start room from the table areaDefaultStartRooms.
		if (areaDefaultStartRooms[arid] ~= nil) then 	-- Note, Upper/Lower Planes have the same default room.  More development needed here.	
			return areaDefaultStartRooms[arid].start		-- exact match on area id
		end
		for k,v in pairs (areaDefaultStartRooms) do
			if (string.match(string.lower(k), arid) ~= nil) then 				
				return v.start	-- string match on key
			end
		end		
		return "-1"
	end
 	
--	[[ "xset vidblain" ]]
	function xset_vidblain(name, line, wildcards)
		local x = xset_vidblain_onoff
		x = (x == "on") and "off" or "on"
		xset_vidblain_onoff = x
		SetVariable("mcvar_xset_vidblain_onoff", x)
		ColourTell ("#FF5000", "", "\nVidblain navigation is now ",
					"#00C040", "", string.upper(x) .. "\n")
	end
 	
	function xset_vidblain_setlevel(name, line, wildcards)
		local x = tonumber(wildcards.level) or "check"
		if (x == "check") then
			ColourTell ("#FF5000", "", "\n'xset vidblain' portal level is ",
						"#00C040", "", xset_vidblain_level .. "\n")
		else
			xset_vidblain_level = x
			SetVariable("mcvar_xset_vidblain_level", x)
			ColourTell ("#FF5000", "", "\n'xset vidblain' portal level set to ", 
						"#00C040", "", x .. "\n")
		end
	end
	
	local is_vidblain_area_sql = "SELECT area " .. "FROM rooms " .. "WHERE uid = %s "
	
	function is_vidblain_area(roomid)
		local level = tier_level()--tonumber(gmcp("char.status.level")) + 10 * tonumber(gmcp("char.base.tier"))
		if (xset_vidblain_onoff == "on") and (level < xset_vidblain_level) then
			--local worldPath = GetInfo(66) .. Trim(sanitize_filename(WorldName()))
			--local db = assert(sqlite3.open(worldPath .. ".db"))
			local db = assert(sqlite3.open(mapper_db_file))
			local select = string.format (is_vidblain_area_sql, fixsql(roomid))
			local ar
			for row in db:nrows(select) do
				ar = row.area
			end
			db:close_vm()
			if (vidblain_area_list[ar]) then
				return true
			else
				return false	
			end
		else
			return false
		end
	end
	
--	[[ Simulate cp ]]
	local cp_simulate_toggle = "0"
	function simulate_cp(name, line, wildcards)
		if (wildcards.type == "") then
			area_room_type = "area"
			current_activity = "cp"
		else
			area_room_type = wildcards.type
			current_activity = "cp"
		end
		local time_check = os.clock()					-- prevent double cp checks from different plugins
		if ((time_check - last_cp_check) < 1.0) then
			return
		end
		last_cp_check = time_check
		cp_check_list = {}
		EnableTrigger("trg_cp_check_line", true)
		Simulate("\n")	
		if (cp_simulate_toggle == "0") then
			Simulate("You still have to kill * A test mob (A Cold Path)\n")	--dead
			Simulate("You still have to kill * the head necromancer's assistant (Necromancers' Guild)\n")
			Simulate("You still have to kill * Isscheburqua (Insanitaria)\n")
			Simulate("You still have to kill * a rook citizen (Avian Kingdom - Dead)\n")
			Simulate("You still have to kill * Lea, the farmer's daughter (Farmyard)\n")
			Simulate("You still have to kill * a rook citizen (Nesting Home)\n")
			Simulate("You still have to kill * a demon school student (The School of Horror)\n")
			Simulate("You still have to kill * a hookle fish (Black Lagoon)\n")
			Simulate("You still have to kill * Harry (Unknown Tower)\n")		--dead
			Simulate("You still have to kill * a former court jester (The Labyrinth)\n")
			Simulate("You still have to kill * Parent (A Cold Path - Dead)\n")
			Simulate("You still have to kill * a wealth redistribution specialist (Empyrean, Streets of Downfall)\n")
			Simulate("You still have to kill * the reaching thorns (Eternal Autumn)\n")
			Simulate("You still have to kill * Redtooth (Mossflower Wood - Dead)\n")	--dead
			Simulate("You still have to kill * Castle Guard (Rebellion of the Nix)\n")
			Simulate("You still have to kill * Jules (The Amazon Nation)\n")
			Simulate("You still have to kill * an earth fiend (The Broken Halls of Horath)\n")
			Simulate("You still have to kill * the spirit of Bakarne (The Empire of Aiighialla)\n")
			Simulate("You still have to kill * Elfgar Sous-Fled (Some Place)\n")
			Simulate("You still have to kill * the heart of a sandstorm (Living Mines of Dak'Tai)\n")
			cp_simulate_toggle = "1"
		else
			Simulate("You still have to kill * a former court jester (The Labyrinth)\n")
			Simulate("You still have to kill * the heart of a sandstorm (Buried in the Great Desert's unrelenting dunes)\n")
			Simulate("You still have to kill * Parent (The Kitchen)\n")
			Simulate("You still have to kill * a rhino seraph (A Corridor of Cinnamon and Silver)\n")
			Simulate("You still have to kill * A sprite prisoner (A cell)\n")
			cp_simulate_toggle = "0"
		end
		Simulate("Note: Dead means that the target is dead, not that you have killed it.\n")
		Simulate("\n")
		Simulate("You have 6 days, 23 hours and 56 minutes left to finish this campaign.\n")
		Simulate("\n")
		
	end
	
-- [[ Room notes ]]
	function room_note_area(name, line, wildcards)
		if (wildcards.arid == "") then
			--get_notes(current_room.arid, nil)
			get_notes(gmcp("room.info.zone"), nil)
		else
			get_notes(wildcards.arid, nil)
		end
	end
	
	function room_note(name, line, wildcards)
		--get_notes(nil, current_room.rmid)
		get_notes(nil, gmcp("room.info.num"))
	end
	
	function get_notes(arid, roomid, text_only)
		--local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		--local db = assert(sqlite3.open(worldPath .. ".db"))
		local db = assert(sqlite3.open(mapper_db_file))
		local sql =  " SELECT b.uid, b.notes "
		sql = sql .. " FROM bookmarks b "
		if (arid ~= nil) then
			sql = sql .. " INNER JOIN rooms r ON b.uid = r.uid "
			sql = sql .. " WHERE r.area = " .. fixsql(arid)
		else
			sql = sql .. " WHERE b.uid = " .. fixsql(roomid)
		end
		sql = sql .. " ORDER BY b.uid "
		local index = 0
		if (arid ~= nil) then
			Simulate("\nNotes for " .. getAreaNameFromId(arid) .. "\n")
		end
		for row in db:nrows(sql) do
			index = index + 1
			if (text_only == true) then
				local line = string.format("    note:'%s'", row.notes)
				Hyperlink("xmapper move " .. row.uid, line, "go to room " .. row.uid, "lightblue", "black", 0)		
			else
				local line = string.format("    (%s) %s", row.uid, row.notes)
				Hyperlink("xmapper move " .. row.uid, line, "go to room " .. row.uid, "lightblue", "black", 0)
				print("")
			end		
		end
		db:close_vm()
		if (arid ~= nil and index == 0 and text_only ~= true) then
			Simulate("\tNo notes.\n")
		end
	end
	
	function getAreaIdFromName(name)
		local db = assert(sqlite3.open(mapper_db_file))
		local sql =  "SELECT uid FROM areas WHERE name = %s"
		for row in db:nrows(string.format (sql, fixsql(name))) do
			db:close_vm()
			return row.uid
		end
		db:close_vm()
		return name
	end
	
	function getAreaNameFromId(arid)
		local db = assert(sqlite3.open(mapper_db_file))
		local sql =  "SELECT name FROM areas WHERE uid = %s"
		for row in db:nrows(string.format (sql, fixsql(arid))) do
			db:close_vm()
			return row.name
		end
		db:close_vm()
		return arid
	end

	function getAreaFromRoomId(room_id)
		local db = assert(sqlite3.open(mapper_db_file))
		local sql =  "SELECT area FROM rooms WHERE uid = %s"
		for row in db:nrows(string.format(sql, fixsql(room_id))) do
			db:close_vm()
			return row.area
		end
		db:close_vm()
		return room_id
	end
	
	function getAreaUid(name)
		local db = assert(sqlite3.open(mapper_db_file))
		local sql =  "SELECT uid FROM areas WHERE name = %s order by uid "
		local areas = {}
		local index = 0
		for row in db:nrows(string.format (sql, fixsql(name))) do
			index = index + 1
			areas[index] = {uid = row.uid, name = name}
		end
		db:close_vm()
		return areas
	end
	
--	[[ SQL execution ]]
	function RunSql(name, line, wildcards)
		local worldPath = GetInfo(66) .. "/worlds/plugins/"
		local db = assert(sqlite3.open(worldPath .. "sddb.db"))
		local index = 0
		local sql = wildcards.sql
		ColourNote("#00C040", "", "\nrunning sql: " .. sql)
		for row in db:nrows(sql) do
			index = index + 1
			print("----------- record " .. index .. " -----------" )
			--tprint(row)
	--		print (serialize.save ("row", row))
		end
		db:close_vm()
	end
	
	function ExecSql (name, line, wildcards)
		local db = assert(sqlite3.open(mapper_db_file))
		Note("executing " .. wildcards.sql)
	--	dbcheck (db:execute (fixsql(wildcards.sql)))
		db:execute(fixsql(wildcards.sql))
		db:close_vm()
		Note("ok")
	end
	
	
--	[[ page size functions ]]
	local page_size = 0
	local page_size_suspended = false
	
	function capture_page_size(name, line, wildcards)
		EnableTrigger("trg_capture_page_size", false)
		local size = tonumber(wildcards[1])
		page_size = size or 0
		SendNoEcho("pagesize 0")
	end
	
	function suspend_page_size(name, line, wildcards)
		if (page_size_suspended == false) then
			page_size_suspended = true
			ColourNote("#FF3030", "", "\nSearch and Destroy: Temporarily disabling pagesize (area index process)\n")
			EnableTrigger("trg_capture_page_size", true)
			EnableTrigger("trg_pagesize_gag_1", true)
			SendNoEcho("pagesize")
		end
	end	 
	
	function resume_page_size(name, line, wildcards)
		ColourNote("#FF3030", "", "\nSearch and Destroy: Area index complete. Pagesize re-enabled (if >0)\n")
		EnableTrigger("trg_capture_page_size", false)
		if (page_size ~= 0) then
			SendNoEcho("pagesize " .. page_size)
		end
		page_size_suspended = false
	end	
	
	function xmapper_move(name, line, wildcards)
		local r = wildcards.roomid
		local s = wildcards.speed
		if (r == "-1") then
			ColourNote("#FF5000", "", "\nSearch and Destroy:  Can't go to room id -1 (nomap room)\n")
		elseif (r ~= "") then
			do_mapper_goto(r, s)
		end	
	end 
	
	function do_mapper_goto(r, s)
		if (s == nil or s == "") then
			s = speed
		end
		if (s == "walk") then
			--Note("walking to " .. r)
			Execute("mapper walkto " .. r)
		else
			Execute("mapper goto " .. r)
		end
	end
	
--	[[ Former plugin - S&D GUI ]]
	local window_fonts = {
		["title"]	= { f="Consolas",				 s=10, 				b=false, 	i=false, 	u=false },
		["bt1"]	 	= { f="Segoe",					 s=10, 				b=true, 	i=false, 	u=false },
		["bt2"] 	= { f="Segoe",					 s=10, 				b=true, 	i=false, 	u=false },
		["circ1"] 	= { f="Consolas",				 s=11, 				b=false, 	i=false, 	u=false },
		["circ2"]	= { f="Consolas",				 s= 9, 				b=false, 	i=false, 	u=false },
		["cplevel"] = { f="Consolas",				 s=11, 				b=false, 	i=false, 	u=false },
		["noexp"]	= { f="Consolas",				 s=11, 				b=false, 	i=false, 	u=false }, --noexp tnl
		["noexp2"]	= { f="Consolas",				 s= 9, 				b=false, 	i=false, 	u=false },
		["cplist_area"] = { f="Lucida Sans Unicode", s=win_font_size, 	b=false, 	i=false, 	u=false },
		["cplist_room"] = { f="Segoe", 				 s=win_font_size, 	b=false, 	i=false, 	u=false } }
	
	function xg_create_window()
		if (win_init == false) then
			win_init = true
			local width = win_width
			local height = win_height
			WindowCreate(win, windowinfo.window_left, windowinfo.window_top, width, height, windowinfo.window_mode, windowinfo.window_flags, win_bgcolor)  -- create window
			for k,v in pairs (window_fonts) do
				WindowFont(win, k, v.f, v.s, v.b, v.i, v.u, false)
			end
			WindowShow(win, true)  -- show it 
			if (win_state == "min") then
				mouseup_drag(0, "hsMinimize")
			end		
			if (IsPluginInstalled(plugin_id_z_order) and GetPluginInfo(plugin_id_z_order, 17)) then
				CallPlugin(plugin_id_z_order, "registerMiniwindow", win)
			end		
			xg_draw_window()	
		end
	end

	function xg_draw_window()
		WindowRectOp (win, miniwin.rect_fill, 0, 0, 0, 0, win_bgcolor)			-- Clear the window, which is the first step in updating it
		WindowRectOp (win, 2, 0, 0, 0, 17, 0x000000)						 	-- Draw title bar background and set color (almost black, "17" is height)
		WindowRectOp (win, 4, 0, 0, 0, 17, 0xE0E0E0, 0x909090)					-- Draw title bar border (left/top = light grey, right/bottom = darker grey, "17" is height)
		WindowRectOp (win, 1, 0, 0, 0, 0, 0xC0C0C0, 15)							-- Draw window border.
		WindowRectOp (win, 1, 1, 17, -1, -1, 0x000000, 15)						-- Draw colored perimeter line.
		WindowText (win, "title", 		-- draw the window title text and set its color
					current_sd_version,			-- window title text
					5, 0, 255, 15,				-- left (x1), top (y1), right (x2), bottom (y2) values for window title text
					0xA0FFFF, 					-- colour (light yellow)
					false)						-- not unicode
		if (win_hotspots["hsDrag1"] == nil) then	-- make the title bar draggable
			win_hotspots["hsDrag1"] = WindowAddHotspot(win, "hsDrag1", 0, 0, win_width-1, 16, -- hotspot id, rectangle (left, top, right, bottom)
						"", "", "mousedown_drag", "", "mouseup_drag",
						"Left click = Drag title bar to move\nRight click = Send window to front/back", miniwin.cursor_arrow, 0)
			WindowDragHandler(win, "hsDrag1", "dragmove", "dragrelease", 0)
		end
		
		draw_b1_action_buttons(47, 20)	-- draw xcp, go, etc. buttons
		draw_circle_readout(5, 20)		-- add circle text/level readout
		draw_noexp_readout(206, 22)	-- add noexp on/off and TNL indicator
		draw_resize_tag()
		xg_show_target_links()
		Redraw()
	end
	
	local button_1_list = {
--[[ 1 ]]	["hsXCP"] = { L=  0, text="xcp", tdx=3, tdy=3, exec1=     "xcp", exec2=   "xcp 0", tooltip="Left click = get target\nRight click = clear target" },
--[[ 2 ]]	["hsGO"]  = { L= 31, text= "go", tdx=7, tdy=3, exec1=      "go", exec2=    "go 0", tooltip="Left click = Go to room 1\nRight click = Go to area start" },
--[[ 3 ]]	["hsKK"]  = { L= 62, text= "kk", tdx=8, tdy=3, exec1=      "kk", exec2=      "kk", tooltip="Left click = 'kill' target mob\nRight click = kill with special" },			
--[[ 4 ]]	["hsNX"]  = { L= 93, text= "nx", tdx=7, tdy=3, exec1=      "nx", exec2=     "nx-", tooltip="Left click = goto next\nRight click = goto prev" },
--[[ 5 ]]	["hsQS"]  = { L=124, text= "qs", tdx=8, tdy=3, exec1=      "qs", exec2=      "qs", tooltip="Quick-scan for current target (cp, quest, ht, qw)" },
--[[ 6 ]]	["hsQW"]  = { L=219, text= "qw", tdx=5, tdy=3, exec1=      "qw", exec2=     "qwx", tooltip="Left click = Quick-where\nRight click = Quick-where exact" },
--[[ 7 ]]	["hsHT"]  = { L=248, text= "ht", tdx=9, tdy=3, exec1=      "ht", exec2=     "hta", tooltip="Left click = Do hunt trick\nRight click = Cancel hunt trick" },
--[[ 8 ]]	["hsREF"] = { L=277, text="ref", tdx=6, tdy=3, exec1="xgui ref", exec2="xgui rel", tooltip="Left click = Refresh target list - cp (gq) check\nRight click = Reload target data - cp (gq) info" } }
	
	function draw_b1_action_buttons(left, top)
		local b1 = button_1_list
		for hs,b in pairs (b1) do
			draw_button_1_A(left+b.L, top, b.text, hs, b.tooltip, b.tdx, b.tdy)
		end
	end
	
	function draw_button_1_A(L, T, text, hsName, tooltip, tdx, tdy)
		local x,y,w,z = L, T, L+30, T+25
		local tx,ty = (x+tdx), (y+tdy)	-- x and y values for text location
		local bgcolor = 0x000000
		local color_1 = 0xE0E0E0
		local color_2 = 0x808080
		WindowRectOp(win,2, x,y,w,z, bgcolor)													-- Draw background and set color (black)
		WindowRectOp(win,4, x,y,w,z, color_1, color_2)											-- Draw button border (left/top = light grey, right/bottom = darker grey)
		WindowText(win, "bt1", text, tx,ty,w-1,z-1, color_1, false)								-- Draw button text ("button" font, light grey)
		if (win_hotspots[hsName] == nil) then																-- Make button clickable by defining a hotspot
			win_hotspots[hsName] = WindowAddHotspot(win, hsName, x, y, w, z,							-- Hotspot name and location info
				"", "", "mousedown_b1", "cancelmousedown_b1", "mouseup_b1",				-- Mouse actions
				"" .. (tooltip or text), miniwin.cursor_arrow, 0)											-- Tooltip text, cursor shape (hand)
		end
	end
	
	function draw_button_1_B(L, T, text, hsName, tooltip, tdx, tdy)
		local x,y,w,z = L, T, L+30, T+25											-- x and y values for button boundaries
		local tx,ty = (x+tdx), (y+tdy)	-- x and y values for text location
		local bgcolor = 0x000060	-- red
		local color_1 = 0x80E0E0	-- yellow
		local color_2 = 0x80E0E0	-- yellow
		WindowRectOp (win,2, x,y,w,z, bgcolor)												-- Draw background and set color (black)
		WindowRectOp (win,4, x,y,w,z, color_1, color_2)										-- Draw button border (left/top = light grey, right/bottom = darker grey)
		WindowText(win, "bt1", text, tx,ty,w-1,z-1, color_1, false)								-- Draw button text ("button" font, light grey)
			---win_hotspots[hsName] = WindowAddHotspot(win, hsName, x,y,w,z,					-- Hotspot name and location info
				--"", "", "", "", "",	-- "mouseover", "cancelmouseover", "mousedown", "cancelmousedown", "mouseup"
			--	"" .. (tooltip or text), miniwin.cursor_arrow, 0)	-- Tooltip text, cursor shape (hand)
	end

		

		
	local win_circle_readout_vars = {
			["cp"] 	 = { cc, cc1="r", cc2y="", tc1="", tc2="", tdx="", tdy="", text="" }, 
			["gq"] 	 = { cc1n="", cc2n="", cc1y="", cc2y="", tc1="", tc2="", tdx="", tdy="", text="" },
			["init"] = { cc1n="", cc2n="", cc1y="", cc2y="", tc1="", tc2="", tdx="", tdy="", text="" },
			["none"] = { cc1n="", cc2n="", cc1y="", cc2y="", tc1="", tc2="", tdx="", tdy="", text="" }, }
			
	
	--local win_circle_readout_colors = { g1=0x30C000, g2=0x004000, r1=0x0040F0, r2=0x000080, u1=0xC08800, u2=0x403000, v1=0xC000C0, v2=0x400040 }
	local win_circle_border_colors = { g={0x30C000,0x004000}, r={0x0040F0,0x000080}, u={0xC08800,0x403000}, v={0xC000C0,0x400040} }
	local win_circle_text_colors
	
	function draw_circle_readout(left, top)
		local level, ar_rm, get_new = cp_info_level, area_room_type, can_get_new_cp
		local activity = current_activity
		local width, height = 36, 36
		local cx1,cy1 = left+1, top+1; local cx2,cy2 = (cx1+width), (cy1+height)
		local g1,g2, r1,r2, u1,u2, v1,v2 = 0x30C000,0x004000, 0x0040F0,0x000080, 0xC08800,0x403000, 0xC000C0,0x400040	-- green, red, blue, violet
		local tdx, tdy = 6, 8
		local circle_color_1, circle_color_2, text_color, text
		local font = "circ1"
		if(activity == "cp") then
			circle_color_1 = (get_new == "yes") and g1 or r1; circle_color_2 = (get_new == "yes") and g2 or r2
			text_color_1 = 0xA0FFFF; text_color_2 = 0x0C1830
			text = tostring(level)
			local llen = string.len(text)
			--if (llen == 3) then tdx = 6
			if (llen == 2) then tdx = 10
			elseif (llen == 1) then tdx = 14
			end
		elseif (activity == "none") then
			circle_color_1 = (get_new == "yes") and g1 or r1; circle_color_2 = (get_new == "yes") and g2 or r2			
			text_color_1 = (get_new == "yes") and 0x0050FF or 0x0070FF; text_color_2 = 0x000040
			text = "off"
		elseif (activity == "gq") then
			circle_color_1 = v1; circle_color_2 = v2
			text_color_1 = 0xA0FFFF; text_color_2 = 0x0C1830
			text = "gq"
			tdx = 10; tdy = 6			
		elseif (activity == "init") then
			circle_color_1 = u1; circle_color_2 = u2
			text_color_1 = 0xB0B0B0; text_color_2 = 0x080808
			text = "init"
			font = "circ2"
			tdx = 4; tdy = 10	
		end
		
		--if (ar_rm == "none") then	-- player not on cp
		--	circle_color_1 = (get_new == "yes") and g1 or r1
		--	circle_color_2 = (get_new == "yes") and g2 or r2
		--	text_color_1 = (get_new == "yes") and 0x0050FF or 0x0070FF
		--	text_color_2 = 0x000040
		--	tdx = 6
		--	tdy = 8
		--	text = "off"
		--elseif (ar_rm == "init") then		-- plugin is loading, no info yet
		--	circle_color_1 = u1
		--	circle_color_2 = u2
		--	text_color_1 = 0xB0B0B0
		--	text_color_2 = 0x080808
		--	tdx = 4
		--	tdy = 10
		--	text = "init"
		--	font = "circ2"				-- show "init" in circle while plugin installs
	--	else							-- player is on cp or gq
	--		if (current_activity == "gq") then
	--			circle_color_1 = v1
	--			circle_color_2 = v2
	--			text_color_1 = 0xA0FFFF
	--			text_color_2 = 0x0C1830
	--			text = "gq"
	--			tdx = 10
	--			tdy = 6
	--		elseif (current_activity == "cp") then
	--			circle_color_1 = (get_new == "yes") and g1 or r1
	--			circle_color_2 = (get_new == "yes") and g2 or r2
	--			text_color_1 = 0xA0FFFF
	--			text_color_2 = 0x0C1830
	--			text = tostring(level)
	--			local llen = string.len(text)
	--			if (llen == 3) then tdx = 6
	--			elseif (llen == 2) then tdx = 10
	--			elseif (llen == 1) then tdx = 14
	--			else
	--				tdx = 6
	--				text = "err"
	--			end
	--		end
	--	end 
		WindowCircleOp(win, 1, cx1+1, cy1+1, cx2-1, cy2-1, circle_color_2, 0, 2, win_bgcolor, 1)	-- inner circle (dark)
		WindowCircleOp(win, 1, cx1-1, cy1-1, cx2+1, cy2+1, circle_color_2, 0, 2, win_bgcolor, 1)	-- outer circle (dark)
		WindowCircleOp(win, 1, cx1, cy1, cx2, cy2, circle_color_1, 0, 2, win_bgcolor, 1)			-- main circle (bright)
		local tx1,tx2, ty1,ty2 = (cx1+tdx),(cx2), (cy1+tdy),(cy2)
		WindowText(win, font, string.format("%s", text), tx1+1, ty1, tx2+1, ty2, text_color_2, false)		-- text shadow effect
		WindowText(win, font, string.format("%s", text), tx1+2, ty1+1, tx2+2, ty2+1, text_color_2, false)	-- text shadow effect
		WindowText(win, font, string.format("%s", text), tx1, ty1, tx2, ty2, text_color_1, false)			-- actual text and color
	end
	
	function draw_noexp_readout(left, top)
		WindowDeleteHotspot(win, "hs_noexp")
		local symbol = {
			{ x1= 0, y1= 0, x2=12, y2= 0, c0=0x30FF00, c1=0x0030FF, th=2 },		-- top bar
			{ x1= 0, y1= 3, x2=12, y2= 3, c0=0x000000, c1=0x0030FF, th=2 },		-- second bar
			{ x1= 7, y1= 6, x2= 7, y2=21, c0=0x303030, c1=0x00073F, th=1 },		-- shadow vertical
			{ x1= 6, y1= 6, x2= 6, y2=21, c0=0xC0C0C0, c1=0x0060FF, th=2 },		-- vertical
			{ x1= 0, y1=10, x2= 5, y2= 5, c0=0xC0C0C0, c1=0x0060FF, th=2 }, 	-- left diagonal
			{ x1=11, y1=10, x2= 6, y2= 5, c0=0xC0C0C0, c1=0x0060FF, th=2 } }	-- right diagonal
		local text_color_1 = 0xA0FFFF
		local text_color_2 = 0x0C1830
		local tooltip = "Left click: +100 \nRight click: -100"
		for i,v in ipairs (symbol) do
				local color = (noexp_onoff == "on") and v.c1 or v.c0
				WindowLine(win, left+v.x1,top+v.y1,left+v.x2,top+v.y2, color, 256, v.th)
		end
		if (anex_automatic_onoff == "on") then
			WindowText(win, "noexp", string.format("%s", anex_tnl_cutoff), left+18, top+4, left+62, top+21, text_color_2, false)
			WindowText(win, "noexp", string.format("%s", anex_tnl_cutoff), left+17, top+4, left+61, top+20, text_color_2, false)
			WindowText(win, "noexp", string.format("%s", anex_tnl_cutoff), left+16, top+3, left+60, top+20, text_color_1, false)			
			--if (win_hotspots["hs_noexp"] == nil) then																-- Make button clickable by defining a hotspot
				win_hotspots["hs_noexp"] = WindowAddHotspot(win, "hs_noexp", left, top, left+55, top+25,							-- Hotspot name and location info
					"", "", "", "", "mouseup_noexp",				-- Mouse actions
					"" .. (tooltip), miniwin.cursor_arrow, 0)											-- Tooltip text, cursor shape (hand)
			--end
		else
			WindowText(win, "noexp2", string.format("%s", "manual"), left+17, top+4, left+61, top+21, text_color_2, false)
			WindowText(win, "noexp2", string.format("%s", "manual"), left+16, top+4, left+60, top+20, text_color_2, false)
			WindowText(win, "noexp2", string.format("%s", "manual"), left+15, top+3, left+59, top+20, text_color_1, false)			
			--if (win_hotspots["hs_noexp"] == nil) then																-- Make button clickable by defining a hotspot
				win_hotspots["hs_noexp"] = WindowAddHotspot(win, "hs_noexp", left, top, left+55, top+25,							-- Hotspot name and location info
					"", "", "", "", "mouseup_noexp",				-- Mouse actions
					"" .. ("Noexp is manually off, type 'noexp' again to turn on"), miniwin.cursor_arrow, 0)
			--end
		end
	end
	
	function draw_resize_tag()
		local w = win_width
		local h = win_height
		local rts = 13
		local c1,c2 = 0x707070, 0xF0F0F0
		local x,y = w-4, h-4		-- bottom of resize widget tag
		for i=0,9,3 do
			WindowLine(win, x-(i+2), y, x+1, y-(i+3), c2, 0, 1)	-- dark lines
			WindowLine(win, x-i, y, x+1, y-(i+1), c1, 0, 1)	-- bright lines
		end
		WindowSetPixel (win, x, y, 0xF0F0F0)
		if (WindowHotspotInfo(win, "hsResize", 1) == nil) then
			WindowAddHotspot(win, "hsResize", w-rts, h-rts, win_width, h, "", "", "mousedown_resize_window", "", "", "", 6, 0)
			WindowDragHandler(win, "hsResize", "ResizeMoveCallback", "ResizeReleaseCallback", 0)
		else
			WindowMoveHotspot(win, "hsResize", w-rts, h-rts, 0, 0)
		end
	end


	
	function xg_show_target_links()
		for i,v in ipairs (win_target_hotspots) do
			WindowDeleteHotspot(win, v)
		end
		win_target_hotspots = {}
		if (win_state == "min") then return	end
		local list = main_target_list
		local font = "cplist_" .. area_room_type
		local index = 0
		local resize_tag = 13
		local targ_list_top = 59
		local targ_list_bottom = win_height - 5
		for i,v in ipairs (list) do
			index = i
			if (((index-1) * win_line_space + targ_list_top) > targ_list_bottom) then break end		-- Abort loop if printed item would not be visible.
			local mob = v.mob .. ((v.is_dead == "yes") and " [Dead]" or "")
			local ar = v.arid
			local ct = v.link_type
			local location
			local eventHandler = "win_mouseup_target_link"
			if (ct == "area") then
				location = string.format("%s", ar)	
			elseif (ct == "room") then
				location = string.format("'%s' (%s)", v.roomName, ar)
			elseif (ct == "unknown") then
				location = string.format("'%s' (unknown)", v.location)
				eventHandler = ""
			end
			local qty = ((player_on_gq == "yes") and v.qty .. "* " or "")
			local link = string.format("%s)  %s%s - %s", index, qty, mob, location)
			local color = ((index == xcp_index) and "0x0040FF" or convert_color_format(v.color))
			
			local font_height = WindowFontInfo (win, font, 1) -- WindowFontInfo (win, font, 4)
			local hs_left = (index < 10) and 13 or 6
			local hs_top = (targ_list_top + ((index-1) * win_line_space))
			local hs_right = (hs_left + WindowTextWidth(win, font, link))
			local hs_bottom = (hs_top + font_height + 1) --(hs_top + win_line_space )
			
			if (hs_right > win_width - 5) then hs_right = (win_width - 5) end
			WindowText(win, font, link, hs_left, hs_top, 0, 0, color, false)
			if (hs_bottom > win_height - resize_tag) then		-- Prevent list item's hotspot from overlapping with the resize tag
				if (hs_right > win_width - resize_tag - 5) then 
					hs_right = win_width - resize_tag - 5
				end
			end 
			win_target_hotspots[#win_target_hotspots+1] = index
			--WindowRectOp (win, 1, 
			--				hs_left-1, hs_top+2, hs_right+2, hs_bottom, 0x000080, 15)
			WindowAddHotspot(win, index,
							hs_left-1, hs_top+2, hs_right+2, hs_bottom,		-- hotspot boundary rectangle
							"", "", "", "",								-- "mouseover", "cancelmouseover", "mousedown", "cancelmousedown"
							eventHandler, "", miniwin.cursor_arrow, 0)	-- "mouseup", tooltip, cursor type
		end
	end

-- [[ GUI window mouse click functions (buttons, links, etc.) ]]
	function mouseup_b1(flags, hotspot_id)	-- when mouse button is released, redraw the buttons to normal appearance.
		local b = button_1_list[hotspot_id]
		local click = ((bit.band(flags, 0x20) == 0) and "L" or "R")
		local left = WindowHotspotInfo(win, hotspot_id, 1)
		local top = WindowHotspotInfo(win, hotspot_id, 2)
		draw_button_1_A(left, top, b.text, hotspot_id, b.tooltip, b.tdx, b.tdy)
		Redraw()
		Execute(((click == "L") and b.exec1 or b.exec2))
	end
	
	function mousedown_b1(flags, hotspot_id)	-- when mouse button is pressed:  
		local b = button_1_list[hotspot_id]
		local click = ((bit.band(flags, 0x20) == 0) and "L" or "R")
		local left = WindowHotspotInfo(win, hotspot_id, 1)
		local top = WindowHotspotInfo(win, hotspot_id, 2)
		draw_button_1_B(left, top, b.text, hotspot_id.."2", "", b.tdx, b.tdy)
		Redraw()
	end
	
	function cancelmousedown_b1(flags, hotspot_id)
		local b = button_1_list[hotspot_id]
		local click = ((bit.band(flags, 0x20) == 0) and "L" or "R")
		local left = WindowHotspotInfo(win, hotspot_id, 1)
		local top = WindowHotspotInfo(win, hotspot_id, 2)
		draw_button_1_A(left, top, b.text, hotspot_id, b.tooltip, b.tdx, b.tdy)
		Redraw()
	end
	
	function mousedown_resize_window(flags, hotspot_id)
	if (hotspot_id == "hsResize") then
		startx, starty = WindowInfo (win, 17), WindowInfo (win, 18)
	end
	end	
	
	function mouseup_noexp(flags)
		local f = flags
		local hs = "hs_noexp"
		local click = ((bit.band(f, 0x20) == 0) and "L" or "R")
		if (anex_automatic_onoff == "on") then
			if (click == "L") then
				anex_tnl_cutoff = anex_tnl_cutoff + 100
				if (anex_tnl_cutoff > 9900) then anex_tnl_cutoff = 9900 end
			elseif (click == "R") then
				anex_tnl_cutoff = anex_tnl_cutoff - 100
				if (anex_tnl_cutoff < 0 ) then anex_tnl_cutoff = 0 end
			else
				-- do nothing
			end
			SetVariable("mcvar_anex_tnl_cutoff", anex_tnl_cutoff)
			anex_check_tnl_silent()
			xg_draw_window()
		end
	end
	
	function mousedown_drag(flags, hotspot_id)
		win_dragmove_start_x = WindowInfo(win, 14)
		win_dragmove_start_y = WindowInfo (win, 15)
	end
	
	function mouseup_drag(flags, hotspot_id)
		local f = flags
		local click = ((bit.band(f, 0x20) == 0) and "L" or "R")
		if (hotspot_id == "hsDrag1") then
			if (click == "R") then
				right_click_menu()
			end
		end
	end
	
	function win_mouseup_target_link(flags, hotspot_id)
		if (tonumber(hotspot_id) ~= nil) then
			xcp_arg("", "", {index=hotspot_id})
		end
	end

--	[[ Window dragging / moving ]]
	function dragmove(flags, hotspot_id)
		if (bit.band(flags, 0x20) == 0) then
			win_pos_x = WindowInfo(win, 17) -- - 50
			win_pos_y = WindowInfo(win, 18) -- - 7
			local delta_x = win_pos_x - win_dragmove_start_x
			local delta_y = win_pos_y - win_dragmove_start_y
			local max_x = GetInfo(281) - 100
			local max_y = GetInfo(280) - 60
			if (delta_x <= 1) then 			-- Prevents window from leaving the screen.  The bug that got me started on all this.  
				delta_x = 1
			elseif (delta_x >= max_x) then 	
				delta_x = max_x
			end
			if (delta_y <= 1) then 			
				delta_y = 1
			elseif (delta_y >= max_y) then 	
				delta_y = max_y
			end
			WindowPosition(win, delta_x, delta_y, miniwin.pos_stretch_to_view, miniwin.create_absolute_location) -- move window to new location
		else
			return
		end
	end

	function dragrelease(flags, hotspot_id)
	--  print ("mouse drag release for " .. hotspot_id)
	--  print ("released at position", WindowInfo (win, 17), WindowInfo (win, 18))
	end

--	[[ Window resize functions ]]
	
	local lastRefresh = 0
	
	function ResizeMoveCallback()
		local screen_width = GetInfo(281) - 100
		local screen_height = GetInfo(280) - 60
		if (GetPluginVariable("c293f9e7f04dde889f65cb90", "lock_down_miniwindows") == "1") then
			return
		end
		local x, y = WindowInfo (win, 17), WindowInfo (win, 18)
		win_width = win_width + x - startx
		startx = x
		if (win_width < win_width_min) then
			win_width = win_width_min
			startx = windowinfo.window_left+win_width
		elseif (win_width > screen_width) then
			win_width = screen_width
			startx = windowinfo.window_left+win_width
		end
		win_height = win_height + y - starty
		starty = y
		if (win_height < win_height_min) then
			win_height = win_height_min
			starty = windowinfo.window_top+win_height
		elseif (win_height > screen_height) then
			win_height = screen_height
			starty = windowinfo.window_top+win_height
		end
		WindowResize(win, win_width, win_height, win_bgcolor)
		local freq = 90
		local t = utils.timer()
		if ((t - lastRefresh) > (1/freq)) then	-- redraw rate while resizing (per second)
			xg_draw_window()
			lastRefresh = t
		end
	end
	
	function ResizeReleaseCallback()
		win_state = "max"
		w = win_width
		h = win_height
		WindowDeleteHotspot(win, "hsDrag1")
		win_hotspots["hsDrag1"] = WindowAddHotspot(win, "hsDrag1", 0, 0, w-1, 16, -- hotspot id, rectangle (left, top, right, bottom)
					"", "", "mousedown_drag", "", "mouseup_drag", --mouseover, cancelmouseover, mousedown_drag, cancelmousedown, mouseup_drag
					"Left click = Drag title bar to move\nRight click = Send window to front/back", miniwin.cursor_arrow, 0)	
		WindowDragHandler(win, "hsDrag1", "dragmove", "dragrelease", 0)
		xg_draw_window()
	end

--	[[ Window right click menu]]
	function right_click_menu()
		menustring = ("Bring To Front|Send To Back|Collapse Window|Expand Window")
		result = WindowMenu (win,
			WindowInfo (win, 14),		-- x position
			WindowInfo (win, 15),		-- y position
			menustring)					-- content
		if (result == "Bring To Front") then
			CallPlugin(plugin_id_z_order,"boostMe", win)
		elseif (result == "Send To Back") then
			CallPlugin(plugin_id_z_order,"dropMe", win)
		elseif (result == "Collapse Window") then
			win_state = "min"
			win_height = win_height_min
			WindowResize(win, win_width, win_height, ColourNameToRGB("black"))
			xg_draw_window()
			Redraw()	
		elseif (result == "Expand Window") then
			win_state = "max"
			win_height = win_height_max
			WindowResize(win, win_width, win_height, ColourNameToRGB("black"))
			xg_draw_window()
		end
	end
	
	function xgui_RefreshLinks()
		if current_activity == "gq" then
			do_gq_check()
		else
			do_cp_check()
		end
		mouseup_drag(0, "hsMaximize")
	end
	
	function xgui_ReloadLinks()
		if current_activity == "gq" then
			do_gq_info()
		else
			do_cp_info()
		end
		mouseup_drag(0, "hsMaximize")	
	end

	function xset_ToggleWindowDisplay(name, line, wildcards)
		local arg = wildcards.onoff
		if (arg == "on") or (arg == "show") or (arg == "1") then
			WindowShow(win, true)
			SetVariable("mcvar_xgui_window_onoff", "on")
		elseif (arg == "off") or (arg == "hide") or (arg == "0") then
			WindowShow(win, false)
			SetVariable("mcvar_xgui_window_onoff", "off")
		end
	end
	
	function xset_font_size(name, line, wildcards)
		if (wildcards.size == "") then
			print("Cp list font size = " .. win_font_size .. "\n")
		else
			win_font_size = tonumber(wildcards.size)
			WindowFont(win, "cplist_area", "Lucida Sans Unicode", win_font_size, false, false, false, false)		-- cp list font, area cp's
			WindowFont(win, "cplist_room", "Segoe", win_font_size, false, false, false, false)					-- cp list font, room cp's
			print("Cp list font size set to " .. win_font_size .. ".\n")
			SetVariable("mcvar_window_font_size", win_font_size)
			xg_draw_window()
		end
	end
	
	function xset_line_space(name, line, wildcards)
		local x = tonumber(wildcards.space)
		local line_space = win_line_space
		if (wildcards.space == "") then
			print("Cp list line spacing = " .. line_space .. "\n")
		else
			
			print("Cp list line spacing set to " .. x .. ".\n")
			win_line_space = x
			SetVariable("mcvar_window_line_space", x)
			xg_draw_window()
		end
	end
	
	function OnPluginSaveState()
		movewindow.save_state(win)	-- save window location
		if WindowInfo(win, 3) and WindowInfo(win, 4) then
			win_width = WindowInfo(win, 3)
			win_height = WindowInfo(win, 4)
		end
		SetVariable("mcvar_window_pos_x", win_pos_x)
		SetVariable("mcvar_window_pos_y", win_pos_y)
		SetVariable("mcvar_window_state", win_state)
		SetVariable("mcvar_window_width", win_width)
		SetVariable("mcvar_window_height", win_height)
		SetVariable("mcvar_window_width_max", win_width_max)
		SetVariable("mcvar_window_height_max", win_height_max)
	end
	
	function OnPluginClose()
		OnPluginSaveState()
		WindowShow(win, false) 			-- hide window, refresh screen
	end 
	
	function set_speed(name, line, wildcards)
		if (wildcards.speed ~= "") then
			speed = wildcards.speed
		else
			if (speed == "walk") then
				speed = "run"
			else
				speed = "walk"
			end
		end
		ColourNote("#FF5000", "", "Move speed:" .. speed)
	end
	
-- Internal Utilities
	function convert_color_format(s)	-- convert color format from #FF8800 (used by colournote, etc.) to 0x0088FF (used for window text)
		local con = "0x"
		for i=1,3,1 do
			con = con .. string.sub(s, 8-(2*i), 9-(2*i))
		end
		return con
	end
	
	--function copytable(t)
	--	local new_t = {}
	--	table.foreachi(t, 
	--		function (k, v) 
	--			table.insert (new_t, v) 
	--		end)
	--	return new_t
	--end
	
	function cprint(c1, txt)		-- colournote abbreviation
		ColourNote(c1, "", txt)
	end
	
	function dbcheck(code, query)
		if (code ~= sqlite3.OK) and    -- no error
		(code ~= sqlite3.ROW) and   -- completed OK with another row of data
		(code ~= sqlite3.DONE) then -- completed OK, no more rows
			local err = db:errmsg ()  -- the rollback will change the error message
			err = err.."\n\nCODE: "..code.."\nQUERY: "..query.."\n"
			db:exec("ROLLBACK")      -- rollback any transaction to unlock the database
			error (err, 2)            -- show error in caller's context
		end
	end
	
	function fixbool(b)
		if b then
			return 1
		else
			return 0
		end
	end
	
	function fixsql(s)
		if s then
			return "'" .. (string.gsub (s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
		else
			return "NULL"
		end
	end

	function gmcp(s)
	local ret, datastring = CallPlugin(plugin_id_gmcp_handler, "gmcpdata_as_string", s)
	pcall(loadstring("data = "..datastring))
	return data
	end

	function send_gmcp_packet(s)
	CallPlugin(plugin_id_gmcp_handler, "GMCP_send", s)
	end
		
	function int(n)
		if not tonumber(n) then
			return
		else
			return math.floor(n)
		end
	end
	
	function md5(s)
		local hash = utils.tohex(utils.md5(tostring(s)))
		return hash
	end
	
	function padRight(text, length, padChar)
		local padding = length - string.len(text)
		text = text .. string.rep(padChar, padding)
		return text
	end	
	
	function quote(text)
		return "\""..text.."\""
	end
	
	function round_banker(x)		-- round normally, but when number ends in exactly .5 round to nearest even value.
	if (x == 0) then return 0 end	-- prevent returning -0
	if (x + 0.5) % 2 == 0 then
		return math.floor(x + 0.5)
	else
		return math.ceil(x - 0.5)
	end
	end
	
	function rtrim(s)
		local n = #s
		while n > 0 and s:find("^%s", n) do n = n - 1 end
		return s:sub(1, n)
	end
	
	function sanitize_filename(str)
		str = string.gsub(str, "[^%w%s()_-]", "")
		return str
	end

	function spairs(t, f)
		local tbl = {}
		for n in pairs(t) do 
			table.insert(tbl, n)
		end
		table.sort(tbl, f)
		local i = 0      -- iterator variable
		local iter = function ()   -- iterator function
			i = i + 1
			if (tbl[i] == nil) then
				return nil
			else
				return tbl[i], t[tbl[i]]
			end
		end
		return iter
	end
 	
	function split(line, delim)
		local result = {}
		local index = 1
		for token in string.gmatch(line, delim) do
			result[index] = token
			index = index + 1
		end
		return result
	end
 	
	function trim(s)
		return s:match'^()%s*$' and '' or s:match'^%s*(.*%S)'
	end
	
	function tier_level()
		local l = tonumber(gmcp("char.status.level"))
		local t = tonumber(gmcp("char.base.tier"))
		return (l + 10*t)
	end


-- [[ Random stuff that doesn't fit anywhere else (?) ]]	
	function xtest_roomhist()
		ColourNote("#00FFFF", "", "\ni: 0    r: " .. string.format("%-5s", room_history[0].rmid) .. "  a: " .. room_history[0].arid)	
		for i,v in ipairs (room_history) do
			print("i: " .. string.format("%-3s", i) .. "  r: " .. string.format("%-5s", v.rmid) .. "  a: " .. string.format("%-10s", v.arid))
		end
		print("")
	end
	
	function xtest_areadata()
		local db = assert(sqlite3.open(mapper_db_file))
		local sql = "SELECT uid, name FROM areas"
		local ar = { }
		local dasr = areaDefaultStartRooms	-- default start rooms
		local xasr = area_start_rooms	-- xset marked start rooms
		local alr = area_range_index	-- area level range table
		--local worldPath = GetInfo(66) .. "/worlds/plugins/"
		--local db = assert(sqlite3.open(worldPath .. "sddb.db"))
		local index = 0
		ColourNote("#00C040", "", "\nrunning sql: " .. sql)
		for row in db:nrows(sql) do
			index = index + 1
			local a = row.uid
			local an = row.name
			local q = (dasr[a].noquest == true) and "0" or "1"
			local d = dasr[a].start
			local c = (xasr[a] ~= nil) and ((xasr[a].roomid ~= d) and xasr[a].roomid or "-1") or "-1"
			ar[index] = { arid=a, area_name=an, def_startroom=d, cur_startroom=c, questable=q, minlvl="-1", maxlvl="-1", lock="-1" }
		end
		db:close_vm()
		for i,v in ipairs (ar) do
			local a = v.arid
			local an = v.area_name
			if (alr[an] ~= nil) then
				v.minlvl = alr[an].min
				v.maxlvl = alr[an].max
			end
		end		
		--	if (dasr[v.arid].noquest == true) then
		--		v.questable = "0"
		--	else
		--		v.questable = "1"
		--	end
		--end
		--tprint(ar)
		--tprint(area_start_rooms)
		--tprint(alr)
	end
	
	function xtest_mcvars()
		local t = GetVariableList()
		tprint(t)
	end
	
	function xmap_rooms_linking_here(name, line, wildcards)
		local room_id = tonumber(wildcards.room_id) or tonumber(current_room.rmid) or -1
		local r1 = {}
		local list = {}
		local Q1 = string.format("SELECT uid, name, area FROM rooms WHERE uid = %s ", fixsql(room_id))
		local Q2 = string.format("SELECT exits.dir as edir, exits.fromuid as efrom, exits.touid as eto, rooms.name as name, rooms.area as arid FROM exits,rooms WHERE exits.touid = %s AND rooms.uid = exits.fromuid ORDER BY efrom ASC ", fixsql(room_id), fixsql(room_id))
		local db = assert(sqlite3.open(mapper_db_file))
		for row in db:nrows(Q1) do
			r1 = { rmid = row.uid, arid = row.area, roomname = row.name }
		end
		for row in db:nrows(Q2) do
			local ru = string.format("%5s", row.efrom)
			list[ru] = {
				roomname = row.name,
				arid = row.arid,
				exit_dir = row.edir, }
		end
		db:close_vm()
		print("\n" .. "Rooms linking to " .. r1.rmid .. ": " .. r1.roomname .. " (" .. r1.arid .. ")" .. "\n")
		for k,v in spairs (list) do
			print(k .. ": " .. v.roomname .. " (" .. v.arid .. ") - " .. v.exit_dir)
		end
		print("")
	end
	
	function xtest_loadroom(name, line, wildcards)
		local ri = current_room
		local room_id = tonumber(wildcards.room_id) or tonumber(ri.rmid) or -1
		local roomdata = {}
		local sql_roomdata = "SELECT uid, name, area, info, noportal, norecall, ignore_exits_mismatch " .. "FROM rooms " .. "WHERE uid = %s "
		local sql_exitrow = "SELECT dir, fromuid, touid, level " .. "FROM exits " .. "WHERE fromuid = %s "
		local sel_roomdata = string.format(sql_roomdata, fixsql(room_id))
		local sel_exits = string.format(sql_exitrow, fixsql(room_id))
		local db_results_found = false
		local db = assert(sqlite3.open(mapper_db_file))
		for row in db:nrows(sel_roomdata) do
			roomdata = {
				roomid = row.uid,
				roomname = row.name or "-no room name-",
				arid = row.area or "-no area-",
				--building = row.building,
				--terrain = row.terrain,
				info = row.info or "-no info-",
				--notes = row.notes,
				--x = row.x or 0,
				--y = row.y or 0,
				--z = row.z or 0,
				noportal = row.noportal or 0,
				norecall = row.norecall or 0,
				exits = {},
				exit_locks = {},
				ig_ex_mis = (row.ignore_exits_mismatch == 1)
				}
			for exitrow in db:nrows(sel_exits) do
				roomdata.exits[exitrow.dir] = tostring(exitrow.touid)
				roomdata.exit_locks[exitrow.dir] = tostring(exitrow.level)
			end -- for each ex
		end
		db:close_vm()
		
		if not (roomdata.roomid) then
			roomdata = {
				roomid = tostring(room_id),
				roomname = "-1",
				arid = "-1",
				info = "none",
				noportal = 0,
				norecall = 0,
				exits = {},
				exit_locks = {},
				ig_ex_mis = false
				}
		end
		table.insert(xtest_loadroom_table, roomdata)
		tprint(xtest_loadroom_table)
		print("")
	end

	function xtest_popmsg(name, line, wildcards)
	
	end
	
	function update_plugin()
		raw = "https://raw.githubusercontent.com/AardCrowley/Search-and-Destroy/master/Search_and_Destroy.xml"

		async_ok, async = pcall (require, "async")

		if async_ok then
			plugin_page = async.doAsyncRemoteRequest(raw, raw_get, "HTTPS")
		else
			ColourNote("white", "blue", "Error on plugin update!")
		end
	end

	function raw_get(retval, page, status, headers, full_status, request_url)
		if status == 200 then
			raw_version = tonumber(string.match(page, '<plugin version="([0-9%.]+)"'))
		end

		if raw_version == PLUGIN_VERSION then
			ColourNote("white", "blue", PLUGIN_NAME .. " is up-to-date.")
		elseif raw_version > PLUGIN_VERSION then
			ColourNote("white", "blue", "Updating from version " .. PLUGIN_VERSION .. " to " .. raw_version .. ". Do not touch anything!")
			local file = io.open(GetPluginInfo(GetPluginID(), 6), "w")
			file:write(page)
			file:close()

			if "" == GetAlphaOption("script_prefix") then
				SetAlphaOption("script_prefix", "\\\\\\")
			end

			Execute(GetAlphaOption("script_prefix") .. "DoAfterSpecial(1, \"ReloadPlugin('" .. GetPluginID() .. "')\", sendto.script)")
			ColourNote("white", "blue", "Update complete!")
		end

		raw_version = nil
	end -- end Update code

	function showHelp()
	print([[
Commands:
xset win <on|off>             --> Shows or hides the window.
xset winreset                 --> Resets the window.
xset fontsize <#>             --> Displays current font size, or changes 
                                > it to argument.
xset linespace <#>            --> Displays line spacing size, or changes
                                > it to argument.
xset speed <walk|run>         --> Displays current move speed, or changes
                                > it to argument.
xset vidblain                 --> Fixes Vidblain's "random drop" so you 
                                > can still run to areas within Vidblain.
xset mark                     --> Sets current room as "start" for the 
                                > current area.
xset index areas              --> Indexes areas. Use this if you get a lot
                                > of "red" links but you've mapped the area.

xm rlh <roomID>               --> Displays rooms linking to <roomID> or
                                > current room.
xmall <room name>             --> Displays rooms across the MUD matching 
                                > the argument.
xm <room name>                --> Displays rooms in zone matching the
                                > argument.
xmap move <roomID> <run|walk> --> Move to the room id at default speed, or
                                > walks (without portals) or runs (with 
                                > portals) based on argument.
roomnote <area|area areakey>  --> Displays roomnotes for current room, 
                                > current area, or area argument.

qw<x> <mobname>               --> Where's the current stored target or
                                > argument. Use 'x' to where exact mob name.
ht <mob|stop>                 --> Executes the 'hunt trick' for current 
                                > target or argument. Use 'stop' to abort.
ah<a> <targ>                  --> Autohunts target. Append 'a' with no 
                                > target to abort.
xset <ak|kk|qk>               --> Sets the 'quick kill' command. All options
                                > are interchangeable.
<ak|kk|qk>                    --> Executes the 'quick kill' command. All 
                                > options are interchangeable.
qs                            --> Executes a 'quick scan' for the stored target.
xq                            --> Reloads the quest info.
xset noexp <off|#>            --> Displays current setting with no argument.
                                > With argument, toggles noexp off or sets it
                                > to turn on at # exp remaining.
nx<->                         --> Moves to the next room on the list, or the 
                                > previous room with -.
go <index>                    --> Runs to the first room in the index, or to 
                                > the index number with argument.
<xrt|xrun> <area>             --> Runs to the area matching the argument.

<cp|gq> i|info                --> Displays campaign/gquest info.
<cp|gq> ch|check              --> Displays campaign/gquest check.

xcp <index>                   --> Without argument, goes to top result in
                                > cp/gq check. Otherwise heads to the index
                                > chosen.
xcp mode <ht|qw|off>          --> Sets whether you use hunt trick or quick 
                                > where upon entering an area on cp/gq. Use 
                                > 'off' to turn off this feature.

snd update                    --> Automatically updates Search & Destroy.
]])
	end

]]>
</script>
<triggers>
<!-- Gquest operations -->
	<!-- group: trg_gq -->
	<trigger match="^Quest Name\.\.\.\.\.\.\.\.\.: \[ Global quest # (?<gq_id>\d{1,4}) \]$"
		script="gq_info_quest_name"
		name="trg_gq_info_quest_name" 		group="trg_gq"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_gq_info_quest_name", false) </send> </trigger>
			
	<trigger match="^Quest Status\.\.\.\.\.\.\.: \[ (?<status>\w+) \]$"
		script="gq_info_quest_status"
		name="trg_gq_info_quest_status" 	group="trg_gq"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_gq_info_quest_status", false) </send> </trigger>	

	<trigger match="^Level range\.\.\.\.\.\.\.\.: \[\s+(?<minlvl>\d{1,3}) \] - \[\s+(?<maxlvl>\d{1,3}) \]$"
		script="gq_info_level_range"
		name="trg_gq_info_level_range" 		group="trg_gq"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_gq_info_level_range", false) 
					EnableTrigger("trg_gq_info_target_header", true) </send> </trigger>
			
	<trigger match="^To complete this quest, you must:$"
		name="trg_gq_info_target_header" 	group="trg_gq"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_gq_info_target_header", false)
					EnableTrigger("trg_gq_info_line", true)
					EnableTrigger("trg_gq_info_end", true) 
					EnableTriggerGroup("trg_gqmsg_2", true) </send> </trigger>
	
	<trigger match="^Kill at least (?<qty>[1-3]) \* (?<mob>\w[^(]+) \((?<loc>\S.+)\)\.$"
		script="gq_info_line"
		name="trg_gq_info_line" 			group="trg_gq"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^(?!Kill at least [1-3] \* \w[^(]+ \(\S.+\)\.)$"
		script="gq_info_end"
		name="trg_gq_info_end" 				group="trg_gq"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_gq_info_line", false)
					EnableTrigger("trg_gq_info_end", false) </send> </trigger>		

	<trigger match="^You still have to kill (?<qty>[1-3]) \* (?<mob>\w[^(]+) \((?<loc>\S.+?)(?<isdead> - Dead)?\)$"
		script="gq_check_line"
		name="trg_gq_check_line" 			group="trg_gq"
		enabled="n"	regexp="y" sequence="500" keep_evaluating="y" omit_from_output="y" send_to="12" > 
			<send>	EnableTrigger("trg_gq_check_end", true) </send> </trigger>

	<trigger match="^(?!You still have to kill [1-3] \* \w[^(]+ \(\S.+?(?: - Dead)?\))$" 
		script="gq_check_end"
		name="trg_gq_check_end" 			group="trg_gq"
		enabled="n"	regexp="y" sequence="500" keep_evaluating="y" omit_from_output="n" send_to="12" >
			<send>	EnableTrigger("trg_gq_check_line", false)
					EnableTrigger("trg_gq_check_end", false) </send> </trigger>

	<!-- group: trg_gqmsg_1 -->				
	<trigger match="^Global Quest: Global quest # (?<gq_id>\d{1,4}) has been declared for levels (?<min_lvl>\d{1,3}) to (?<max_lvl>\d{1,3}) (?:- (?:200|10) or fewer wins only)?\.$"
		script="gqmsg_declared"
		name="trg_gqmsg_declared" 			group="trg_gqmsg_1"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>	

	<trigger match="^You have now joined Global Quest # (?<gq_id>\d{1,4})\. See 'help gquest' for available commands\.$"
		script="gqmsg_joined"
		name="trg_gqmsg_joined" 			group="trg_gqmsg_1"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>
		
	<trigger match="^Global Quest: Global quest # (?<gq_id>\d{1,4}) for levels (?<min_lvl>\d{1,3}) to (?<max_lvl>\d{1,3})(?: - (?:200|10) or fewer wins only)? has now started\.$"
		script="gqmsg_started"
		name="trg_gqmsg_started" 			group="trg_gqmsg_1"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<!-- group: trg_gqmsg_2 -->		
	<trigger match="^You have finished this global quest\.$"
		script="player_not_on_gq"
		name="trg_gq_finished_extended" 	group="trg_gqmsg_2"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest: Global Quest # (?<gq_id>\d{1,4}) has been won by (?<winner>[A-Z][A-Za-z]+) - \d*(?:1st|2nd|3rd|\dth) win\.$"
		script="gqmsg_winner"
		name="trg_gqmsg_winner" 			group="trg_gqmsg_2"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>
	
	<trigger match="^Global Quest: Global Quest # (?<gq_id>\d{1,4}) will go into extended time for 5 more minutes\.$"
		script="gqmsg_extended_time"
		name="trg_gqmsg_extended_time" 		group="trg_gqmsg_ext"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest: Global quest # (?<gq_id>\d{1,4}) \(extended\) is now over\.$"
		script="player_not_on_gq"
		name="trg_gqmsg_extended_end" 		group="trg_gqmsg_2"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>
		
	<trigger match="^You are no longer part of Global Quest # (?<gq_id>\d{1,4}) and will be unable to rejoin\.$"
		script="player_not_on_gq"
		name="trg_gqmsg_quit" 				group="trg_gqmsg_2"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>
		
	<trigger match="^Congratulations, that was one of the GLOBAL QUEST mobs\!$"
		script="gq_mob_killed"
		name="trg_gq_mob_killed" 			group="trg_gq_status" 
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>
		
	<trigger match="^You are not in a global quest\.$"
		script="player_not_on_gq"
		name="trg_player_not_on_gq" 		group="trg_gq_status"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^There are no global quests running\.$"
		script="player_not_on_gq"
		name="trg_no_gqs_running" 			group="trg_gq_status"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest # (?<gq_id>\d{1,4}) has not yet started\.$"
		script="gq_check_not_yet_started"
		name="trg_gq_check_not_yet_started" group="trg_gq_status"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

<!-- CAMPAIGN OPERATIONS -->
	<trigger match="^Level Taken\.{8}: \[\s+(?<level>[1-2]?\d{1,2}) \]$"
		script="cp_info_level_taken"
		name="trg_cp_info_level_taken" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_info_level_taken", false) </send> </trigger>
	
	<trigger match="^The targets for this campaign are:$"
		script=""
		name="trg_cp_info_targets" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_info_targets", false)
					EnableTrigger("trg_cp_info_line", true)
					EnableTrigger("trg_cp_info_end", true) </send> </trigger>
	
	<trigger match="^Find and kill 1 \* (?<mob>\w[^(]+) \((?<loc>\S.+)\)$"
		script="cp_info_line"
		name="trg_cp_info_line" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^(?!Find and kill 1 \* \w[^(]+ \(\S.+\))$"
		script="cp_info_end"
		name="trg_cp_info_end" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_info_line", false)
					EnableTrigger("trg_cp_info_end", false) </send> </trigger>
		
	<trigger match="^You still have to kill \* (?<mob>\w[^(]+) \((?<loc>\S.+?)(?<isdead> - Dead)?\)$"
		script="cp_check_line"
		name="trg_cp_check_line" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" send_to="12" > 
			<send>	EnableTrigger("trg_cp_check_end", true)</send> </trigger>

		
	<trigger match="^(?!You still have to kill \* \w[^(]+ \(\S.+?(?: - Dead)?\))$" 
		script="cp_check_end"
		name="trg_cp_check_end" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_check_gag_dead", true)
					EnableTrigger("trg_cp_check_line", false)
					EnableTrigger("trg_cp_check_end", false) </send> </trigger>	

	<trigger match="^Note: Dead means that the target is dead, not that you have killed it\.$"
		name="trg_cp_check_gag_dead" group="trg_campaign"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_check_gag_dead", false) </send> </trigger>
			
<!-- CAMPAIGN STATUS TRACKING -->
	<trigger match="^Congratulations, that was one of your CAMPAIGN mobs\!$"
		script="cp_mob_killed"
		name="trg_cp_mob_killed" 	group="trg_cp_2"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^CONGRATULATIONS\! You have completed your campaign\.$"
		script="do_cp_complete"
		name="trg_cp_complete" 		group="trg_cp_2"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y"> </trigger>
	
	<trigger match="^Campaign cleared\.$"
		script="player_not_on_cp"
		name="trg_cp_quit" 			group="trg_cp_2"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>
		
	<trigger match="^\w.+ tells you 'Good luck in your campaign\!'$"
		script="player_start_new_cp"
		name="trg_cp_request" 		group="trg_cp_2"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>
		
	<trigger match="^You are not currently on a campaign\.$" 
		script="player_not_on_cp"
		name="trg_player_not_on_cp" group="trg_cp_2"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^(?:(?:## )?You may now take another campaign\.|You may take (?:a campaign at this level|another campaign)\.)$"
		script="cp_check_can_get_new_cp"
		name="trg_can_get_new_cp" group="trg_cp_2"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^You (?:will have to level before you can go on another campaign|cannot take another campaign for (?:(?:\d+ hours?, )?\d+ minutes? and )?\d+ seconds?)\.$"
		name="trg_cannot_get_new_cp" group="trg_cp_2"
		script="cp_check_cannot_get_new_cp"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>		
	
	<trigger match="^You use a daily blessing campaign reset token to reset your campaign\.$"
		name="trg_cp_reset_token" group="trg_cp_2"
		script=""
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" omit_from_output="n" send_to="12" > </trigger>

<!-- Xcp next -->
	<trigger match="^Congratulations, that was one of your CAMPAIGN mobs\!$"
		name="trg_xcp_next_cp_mob_killed" group="trg_auto"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_xcp_next_cp", true) </send> </trigger>
					
	<trigger match="^Congratulations, that was one of the GLOBAL QUEST mobs\!$"
		name="trg_xcp_next_gq_mob_killed" group="trg_auto"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > 
			<send>	EnableTrigger("trg_xcp_next_gq", true) </send> </trigger>			
		
<!-- QUICK WHERE -->
	<trigger match="^(?<mobname>\w.{29}) (?<roomname>[^ (0-9].*)$"
		script="qw_match"
		name="trg_quick_where_match" group="QuickWhere"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>
	
	<trigger match="^There is no \w.+ around here\.$"
		script="qw_no_match"
		name="trg_quick_where_no_match" group="QuickWhere"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

<!-- HUNT TRICK -->
	<trigger match="^You are (?:almost )?certain that \w.+ is (?:north|south|east|west|up|down) from here\.|You are confident that \w.+ passed through here, heading (?:north|south|east|west|up|down)\.|The trail of \w.+ is confusing, but you're reasonably sure \w.+ headed (?:north|south|east|west|up|down)\.|There are traces of \w.+ having been here. Perhaps they lead (?:north|south|east|west|up|down)\?|You have no idea what you\'re doing\, but maybe \w.+ is (?:north|south|east|west|up|down)\?|You couldn\'t find a path to \w.+ from here\.|\w.+ is here\!$"
		script="ht_continue"
		name="trg_hunt_trick_continue_dir" group="HuntTrick"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You are (?:almost )?certain that \w.+ is through .+\.|You are confident that \w.+ passed through here, heading through .+\.|The trail of \w.+ is confusing, but you're reasonably sure \w.+ headed through .+\.|There are traces of \w.+ having been here\. Perhaps they lead through \w.+\?|You have no idea which way \w.+ went\.$"
		script="ht_continue"
		name="trg_hunt_trick_continue_portal" group="HuntTrick"
		enabled="n" regexp="y" sequence="100" > </trigger>
	
	<trigger match="^You seem unable to hunt that target for some reason\.$"
		script="ht_complete"
		name="trg_hunt_trick_complete" group="HuntTrick"
		enabled="n" regexp="y" sequence="100" > </trigger>
	
	<trigger match="^\w.+ is here\!$"
		name="trg_hunt_trick_continue_2" group="HuntTrick"		
		script="ht_continue"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^No one in this area by the name '\w.+'\.|Not while you are fighting\!|You can't hunt while (?:resting|sitting)\.|You dream about going on a nice hunting trip, with pony rides, and campfires too\.$"
		name="trg_hunt_trick_abort" group="HuntTrick"
		script="ht_abort"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

<!--  AUTO HUNT -->
	<trigger match="^You are (?:almost )?certain that (?<mob>\w.+) is (?<dir>north|south|east|west|up|down) from here\.$"
		script="auto_hunt_next"
		name="trg_autohunt_next_1" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You are confident that (?<mob>.+) passed through here\, heading (?<dir>north|south|east|west|up|down)\.$"
		script="auto_hunt_next"
		name="trg_autohunt_next_2" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^The trail of \w.+ is confusing, but you\'re reasonably sure .+ headed (?:north|south|east|west|up|down)\.|There are traces of \w.+ having been here\. Perhaps they lead (?:north|south|east|west|up|down)\?|You have no idea what you\'re doing, but maybe \w.+ is (?:north|south|east|west|up|down)\?$"
		script="auto_hunt_lowskill"	
		name="trg_autohunt_lowskill" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You are (?:almost )?certain that \w.+ is through .+\.|You are confident that \w.+ passed through here, heading through .+\.|The trail of \w.+ is confusing, but you're reasonably sure \w.+ headed through .+\.|There are traces of \w.+ having been here\. Perhaps they lead through .+\?|You have no idea what you\'re doing\, but maybe \w.+ is through .+\?$"
		script="auto_hunt_portal"
		name="trg_autohunt_portal" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^No one in this area by the name '\w.+'\.|You couldn\'t find a path to \w.+ from here\.|No one in this area by that name\.|Not while you are fighting\!|You can't hunt while (?:resting|sitting)\.|You dream about going on a nice hunting trip, with pony rides, and campfires too\.$"
		script="auto_hunt_abort"
		name="trg_autohunt_abort" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^You seem unable to hunt that target for some reason\.$"
		script="auto_hunt_abort"
		name="trg_hunt_trick" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger>
	
	<trigger match="^\w.+ is here\!$"
		script="auto_hunt_complete"
		name="trg_autohunt_complete" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger> 
		
	<trigger match="^Magical wards around \w.+ bounce you back\.$"
		name="trg_autohunt_nopass" group="AutoHunt"
		script="auto_hunt_door"
		enabled="n" regexp="y" sequence="100" > </trigger>
		
	<trigger match="^The \w.+ is closed\.$"
		name="trg_autohunt_door" group="AutoHunt"
		script="auto_hunt_door"
		enabled="n" regexp="y" sequence="100" > </trigger>
		
	<trigger match="^You do not have a key for \w.+\.$"
		name="trg_autohunt_no_key" group="AutoHunt"
		script="auto_hunt_abort"
		enabled="n" regexp="y" sequence="100" > </trigger> 
		
	<trigger match="^You open \w.+\.$"
		name="trg_autohunt_door_open" group="AutoHunt"
		script="auto_hunt_door_open"
		enabled="n" regexp="y" sequence="100" > </trigger>
		
	auto_hunt_door_open	
<!-- AUTO SET NOEXP -->
	<trigger match="^You will no longer receive experience\. Happy questing\!$"
		script="anex_automatic_off"
		name="trg_anex_automatic_off"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>
	
	<trigger match="^You will now receive experience\. Happy leveling\!$"
		script="anex_automatic_on"
		name="trg_anex_automatic_on"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^You (?:don't )?receive (\d+)(?:\+\d+)? experience points?\.$"
		script="anex_mobdeath_xp1"
		name="trg_anex_mobdeath_xp1"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^You raise a level\! You are now level \d+\.$"
		script="player_level_up"
		name="trg_player_level_up"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y"> </trigger>

<!-- AREA INDEX PROCESS -->
	<trigger match="^              \[ Listing all areas in range 1 to 300 \]$"
		script="area_index_start"
		name="trg_area_index_start" group="AreaIndex"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_gag_headers", true)
					EnableTrigger("trg_area_index_gag_header_lines", true)
					EnableTrigger("trg_area_index_line", true)
					EnableTrigger("trg_area_index_gag_lock_means", true)
					EnableTrigger("trg_area_index_end", true) </send> </trigger>

	<trigger match="^From To   Lock  Keyword          Area Name                      $"
		name="trg_area_index_gag_headers" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_gag_headers", false) </send> </trigger>
	
	<trigger match="^---- ---- ----  ---------------  ------------------------------$"
		name="trg_area_index_gag_header_lines" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_gag_header_lines", false) </send> </trigger>

	<trigger match="^\s+(?<min>\d+)\s+(?<max>\d+)\s+(?<lock>\d+)?\s+?(?<arid>[0-9a-z]+?)\s+(?<areaName>[A-Z].+?)$"
		script="area_index_line"
		name="trg_area_index_line" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^'Lock' means you cannot enter until you are that level or higher\.$"
		name="trg_area_index_gag_lock_means" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_gag_lock_means", false) </send> </trigger>

	<trigger match="^---------------------------------------------------------------$"
		script="area_index_end"
		name="trg_area_index_end" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_line", false)
					EnableTrigger("trg_area_index_end", false) </send> </trigger>
	
<!-- PAGE SIZE -->
	<trigger match="^You currently display ([0-9]+) lines per page\.|You do not page long messages\.$"
		script="capture_page_size"
		name="trg_capture_page_size"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" omit_from_output = "y" > </trigger>
	
	<trigger match="^Use 'pagesize \<lines\>' to change, or 'pagesize 0' to disable paging\.$"
		script=""
		name="trg_pagesize_gag_1"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" omit_from_output = "y" send_to="12" >
			<send>	EnableTrigger("trg_pagesize_gag_1", false) </send> </trigger>

<!-- Misc. gag triggers -->
	<trigger match="^Players found: \[\d+\], Max this reboot: \[\d+\], Connections this reboot: \[\d+\]$"
		name="trg_gag_who_footer_1"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" > </trigger>

	<trigger match="^Players invis: \[\d+\], Max on ever: \[\d+\]$"
		name="trg_gag_who_footer_2"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" > </trigger>

	<trigger match="^[\s\S]*$"
		name="trg_gag_everything"
		enabled="n" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="y" > </trigger>
</triggers>

<aliases>
<!-- Plugin Update automatic -->
	<alias enabled="y" match="snd update" script="update_plugin" sequence="100">
	</alias>
	<alias enabled="y" match="xhelp" script="showHelp" sequence="100">
	</alias>
<!-- Auto-hunt commands-->
	<alias	match="^ah (?<arg>\w.+)$"
			script="auto_hunt"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:aha|ah0)$"
			script="auto_hunt_abort"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
			
<!-- campaign data input: cp info, check -->
	<alias	match="^cp (?:i|info)$"
			script="do_cp_info"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
					
	<alias	match="^cp (?:ch|check)$"
			script="do_cp_check"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
			
<!-- gquest data input: gq info, check -->
	<alias	match="^gq (?:i|info)$"
			script="do_gq_info"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" >
				<send>	EnableTriggerGroup("trg_gq", false) </send>	</alias>
					
	<alias	match="^(?:gq (?:c|ch|check)|gg|qq)$"
			script="do_gq_check"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
			
<!-- xcp commands  -->
	<alias	match="^xcp$"
			script="xcp_noarg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
			
	<alias	match="^xcp (?<index>[0-9]+)$"
			script="xcp_arg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
		
	<alias	match="^xcp mode(?: (?<option>ht|qw|off))?$"
			script="xcp_set_action_mode"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
					
<!-- movement: xrunto, go, nx, etc.  -->
	<alias	match="^(?:xrt|xrun|xrunto) (?<destination>.+)$"
			script="xrun_to"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
		
	<alias	match="^(?:go|goto)( (?<index>[0-9]+))?$"
			script="goto_number"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" keep_evaluating="y" > </alias>

	<alias	match="^nx$"
			script="goto_next"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
		
	<alias	match="^nx-$"
			script="goto_previous"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Automatic noexp -->
	<alias	match="^xset noexp( (?<arg>off|[0-9]+))?$"
			script="xset_noexp_tnl"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Quest commands -->
	<alias	match="^(?:xq|xq1)$"
			script="xq_command"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Quick scan -->
	<alias	match="^qs$"
			script="quick_scan"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
		
<!-- Quick-kill commands: qk, ak, kk, xset attack -->
	<alias	match="^(?:quick kill|ak|kk|qk)$"
			script="quick_kill"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
		
	<alias	match="^xset (?:kk|ak|qk|qkill)( (?<arg>.+))?$"
			script="xset_quick_kill_command"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Hunt trick -->
	<alias	match="^ht$"
			script="ht_noarg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>		

	<alias	match="^ht (?:(?<index>\d+)\.)?(?<mob>.+)?$"
			script="ht_arg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
			
	<alias	match="^ht(?:a|0| abort| stop)$"
			script="ht_abort"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>	
			
<!-- Quick where -->
	<alias	match="^qw$"
			script="qw_noarg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
			
	<alias	match="^qw (?:(?<index>\d+)\.)?(?<mob>.+)?$"
			script="qw_arg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
	
	<alias	match="^qwx$"
			script="qw_exact"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias> 
				
<!-- roomnotes -->
	<alias	match="^(?:roomnote|rn)$"
			script="room_note"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:roomnote|rn) a(?:rea)?(?: (?<arid>.+))?$"
			script="room_note_area"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Sql Execution -->
	<alias	match="^runsql (?<sql>.+)$"
			script="RunSql"
			enabled="y" regexp="y" sequence="1" ignore_case="y" send_to="12" > </alias>

	<alias	match="^execsql (?<sql>.+)$"
			script="ExecSql"
			enabled="y" regexp="y" sequence="1" ignore_case="y" send_to="12" > </alias>

<!-- xmapper  -->
	<alias	match="^(?:xmap|xmapper) move (?<roomid>\d+|-1)(?: (?<speed>run|walk))?$"
			script="xmapper_move"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
		
	<alias	match="^xm(?:\ {(?<mob>[^\}]+)\})? (?<loc>.+)$"
			script="map_area"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xmall(?:\ {(?<mob>[^\}]+)\})? (?<loc>.+)$"
			script="map_area_all"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
	
	<alias	match="^(?:xm|xmap|xmapper) rlh(?: (?<room_id>\d+))?$"
			script="xmap_rooms_linking_here"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- xset commands -->
	<alias  match="^xset (?:index areas|area index)$"
			script="area_index_process"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
			
	<alias	match="^xset (?:mark|start)$"
			script="xset_to_mark"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias  match="^xset vidblain$"
			script="xset_vidblain"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
			
	<alias  match="^xset vidblain level(?: (?<level>\d{1,3}))?$"
			script="xset_vidblain_setlevel"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias  match="^xset speed ?(?<speed>run|walk)?$"
			script="set_speed"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset sendecho$"		
			script=""
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- xset window commands -->
	<alias	match="^xset fontsize( (?<size>[0-9]+))?$"
			script="xset_font_size"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
		
	<alias	match="^xset linespace( (?<space>[0-9]+))?$"
			script="xset_line_space"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
		
	<alias	match="^xset winreset$"
			script="xg_create_window"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" >
				<send>	win_init = false	</send> </alias>
					
	<alias	match="^xset (?:window|win) (?<onoff>on|off|show|hide|0|1|true|false)$"
			script="xset_ToggleWindowDisplay"
			enabled="y" regexp="y" sequence="100" > </alias>
		
	<alias	match="^(?:xw|xwh|xwhere)( (?<n1>\d+))?( (?<n2>\d+))?( (?<mob>.+))?$"
			script="do_xwhere"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:xg|xgui) (?:ref|refresh)$"
			script="xgui_RefreshLinks"
			enabled="y" regexp="y" sequence="100" > </alias>
			
	<alias	match="^(?:xg|xgui) (?:rel|reload)$"
			script="xgui_ReloadLinks"
			enabled="y" regexp="y" sequence="100" > </alias>
	
<!-- xset page size (area index process) -->
	<alias	match="^xset suspend page size$"
			script="suspend_page_size"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset resume page size$"
			script="resume_page_size"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
			
<!-- xtest commands -->
	<alias  match="^xtest areadata$"
			script="xtest_areadata"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest mcvars$"
			script="xtest_mcvars"
			enabled="y" regexp="y" sequence="100" > </alias>

	<alias	match="^xtest roomhist$"
			script="xtest_roomhist"
			enabled="y" regexp="y" sequence="100" > </alias>	
		
	<alias	match="^xtest simulate cp(?: (?<type>ar?e?a?|ro?o?m?))?$"
			script="simulate_cp"
			enabled="y" regexp="y" sequence="1" ignore_case="y" send_to="12" > </alias>	
			
	<alias	match="^xtest loadroom(?: (?<room_id>\d+))?$"
			script="xtest_loadroom"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
			
	<alias	match="^xtest popmsg$"
			script="xtest_popmsg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>			
		
</aliases>
</muclient>

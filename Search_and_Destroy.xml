<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE muclient>
<!-- Saved on Saturday, July 05, 2008, 4:46 PM -->
<muclient>
<plugin version="5.77" name="Search_and_Destroy" id="30000000537461726C696E67" date_written="2018-12-31 23:00:00" author="Crowley and Naricain" language="Lua" purpose="Safe, legal Search and Destroy" save_state="y" requires="4.90" >
<description trim="n"> </description> </plugin>

<!-- Isolinear intermatrix (utility module) -->
<include name="constants.lua"/>
<variables><variable name="example"></variable></variables>

<timers>
	<timer name="tim_init_plugin"
		second="0.5" active_closed="y"
		script="init_plugin"
		enabled="y" send_to="12" > </timer>

	<timer name="execute_in_area_timer"
		second="0.1"
		script=""
		enabled="n" send_to="12">
			<send>	execute_in_area_tick() </send> </timer>

	<timer name="vidblain_nav_timer"
		second="0.1"
		script=""
		enabled="n" send_to="12">
			<send>	vidblain_nav_tick() </send> </timer>

	<timer name="update_check_tick"
		script="check_for_updates"
		second="10"
		enabled="y" send_to="12"> </timer>
</timers>

<script>
<![CDATA[
--Line 152
	--[[ This script was originally improved upon by Starling, and as such, she deserves credit for the work put into the plugin. In order to ensure future compliance
	     with Aardwolf and MUSHclient, maintenance will now be provided by Crowley and Naricain. If you have any questions, feel free to shoot us a message on Personal
		 or through tells. We will make changes as we see fit to the code. // Crowley and Naricain


		Fix gq: You are no longer part of Global Quest # 4683 and will be unable to rejoin. -- gq quit
				"You have now joined Global Quest # 4685. See 'help gquest' for available commands.", "You may win 2 more gquests at this level.", "You can be rewarded for 50 more kills this level."
		]]--

	require "movewindow"
	require "serialize"
	require "tprint"
	require "wait"

    json = require "json"

	async_ok, async = pcall (require, "async")

	function mapFind(query)
		return CallPlugin("b6eae87ccedd84f510b74714", "map_find_query", query)
	end

	mshow                           = {}
	showStr                         = "@W%s @wis found in @Y%s @win/around @G%s @w(@Cmapper goto %s@w)"

	PLUGIN_VERSION  = GetPluginInfo(GetPluginID(), 19)
	PLUGIN_NAME 	= GetPluginInfo(GetPluginID(), 1)
	SCHEMA_VERSION  = 2

	UPDATE_CHECK_INTERVAL = 60 * 60 -- Check once per hour
	local last_update_check = -1
	local automatic_update_checks = GetVariable("mcvar_automatic_update_checks") or "on"

	local current_sd_version 		= "Search & Destroy v" .. PLUGIN_VERSION
	local plugin_id_gmcp_handler 	= "3e7dedbe37e44942dd46d264"		-- easier to remember the var names than the plugin id's
	local plugin_id_gmcp_mapper		= "b6eae87ccedd84f510b74714"
	local plugin_id_z_order 		= "462b665ecb569efbf261422f"
	local plugin_id_soundpack 		= "23832d1089f727f5f34abad8"

	notarg = (GetVariable("mcvar_quick_kill_notarg") == "true" or false)

	gqCheckPass = false

	local plugins_folder = GetPluginInfo(GetPluginID(), 20)
	local db_file_1
	local db_file_2
	local mapper_db_file = GetInfo(66)..WorldName()..".db"	-- typically aardwolf.db, normally found in main Mushclient folder
	local snd_db_file = GetInfo(66) .. "/SnDdb.db"

-- [[ Current, previous room data GMCP_room_info ]]
	local current_room  = { rmid = "-1", arid = "-1", maze = "no", exits = {} }
	local previous_room = { rmid = "-2", arid = "-2", maze = "no", exits = {} }
	local room_history = { }

-- [[ player status ]]
	local current_character_state = "0"
	local silentMode = GetVariable("mcvar_silentMode_command") or "off"

-- [[ Execute in area, room ]]
	local execute_in_area_tbl = { i=0, j=0, arid="", f="", stat=1 }
	local execute_in_room_tbl = { i=0, j=0, rmid="", f="", stat=1 }
	local vidblain_nav_tbl    = { i=0, j=0, rmid="", f="", stat=1 }

-- [[ main target data / current activity type ]]
	local main_target_list = {}
	local room_targets_ignored = {}
	local area_room_type = "init"
	local current_activity = "init"	-- valid: cp, gq, init, none = "init"
	local xcp_retry_stat
	local xcp_index_attempt
	local last_kill_index

    local last_mob_damaged = nil
    local last_mob_killed = nil

-- [[ campaign data (cpmd) ]]
	local cp_info_level = tonumber(GetVariable("mcvar_cp_level_taken")) or 0
	local cp_info_list = {}
	local cp_check_list = {}
	local last_cp_check = os.clock()

-- [[cp status, etc. ]]
	local can_get_new_cp = "no"
	local player_on_cp = "no"

-- [[ gquest data ]]
	local gqid_declared = GetVariable("mcvar_gqid_declared") or "-1"
	local gqid_joined = GetVariable("mcvar_gqid_joined") or "-1"
	local gqid_started = GetVariable("mcvar_gqid_started") or "-1"
	local gqid_extended = GetVariable("mcvar_gqid_extended") or "-1"
	local player_on_gq = "no"
	local gq_info_list = {}
	local gq_check_list = {}
	local last_gq_check = os.clock()
	local gq_info_minlvl = tonumber(GetVariable("mcvar_gq_info_minlvl")) or 0
	local gq_info_maxlvl = tonumber(GetVariable("mcvar_gq_info_maxlvl")) or 0
	local gq_info_efflvl = tonumber(GetVariable("mcvar_gq_info_efflvl")) or 0

-- [[ current target data - cp, gq, quest ]]
	local xcp_index = 0
	local quest_target = {}	-- {qmob = "", area = "", room = "", keyword="", status="0"}
	local short_mob_name = -1
	local full_mob_name = -1

-- [[ xcp action mode ]]
	local xcp_action_mode = GetVariable("mcvar_xcp_action_mode") or "qw"
	local xcp_targets_quest_onoff = GetVariable("mcvar_xcp_targets_quest_onoff") or "off"

-- [[ goto/nx data ]]
	local gotoArea = -1
	local gotoIndex = 0
	local gotoList = {}
	local next_room = -1

-- [[ auto-hunt ]]
	local auto_hunt_dir = ""
	local auto_hunt_mob = ""
	local autoHuntData = {}

-- [[ hunt trick ]]
	local ht = { index = 1, first_target = true }

-- [[ quick where ]]
	local qw = { index = 1 }

-- [[ quick kill ]]
	local quick_kill_command = GetVariable("mcvar_quick_kill_command") or "k"

-- [[ automatic noexp ]]
	local anex_tnl_cutoff = tonumber(GetVariable("mcvar_anex_tnl_cutoff")) or 0
	local noexp_onoff = "off"
	local anex_automatic_onoff = GetVariable("mcvar_anex_automatic_onoff") or "on"

-- [[ Vidblain navigation ]]
	local xset_vidblain_level = tonumber(GetVariable("mcvar_xset_vidblain_level")) or 300
	local xset_vidblain_onoff = GetVariable("mcvar_xset_vidblain_onoff") or "off"

-- [[ Variables from old Mapper Extender ]]
	local area_range_index = {}
	local area_start_rooms = {}
	local last_area = ""
	local speed = "run"
	local start_room_type

-- [[ Variables from old Search and Destroy ]]
	local dir_map = { north = "n", south = "s", east = "e", west = "w", up = "u", down = "d" }

-- [[ game time data ]]
	local gCycle
	local gYear
	local gYearName
	local gSeason
	local gDay
	local gHour

-- [[ Log players ]]
	local logplayer_table = {}
	local logplayer_levels
	local logplayer_hours
	local logplayer_stats
	local logplayer_qp
	local logplayer_timestamp
	local logplayer_datestamp

-- [[ S&D window data ]]
	local win = "sd_window_" .. GetPluginID()
	local windowinfo
	local win_pos_x = tonumber(GetVariable("mcvar_window_pos_x")) or 0			-- window position x,y coordinates
	local win_pos_y = tonumber(GetVariable("mcvar_window_pos_y")) or 0
	local win_width = tonumber(GetVariable("mcvar_window_width")) or 325
	local win_width_min = 325
	local win_width_max = tonumber(GetVariable("mcvar_window_width_max")) or win_width_min
	local win_height = tonumber(GetVariable("mcvar_window_height")) or 280
	local win_height_min = 60
	local win_height_max = tonumber(GetVariable("mcvar_window_height_max")) or 280
	local win_dragmove_start_x
	local win_dragmove_start_y
	local win_state = GetVariable("mcvar_window_state") or "max"
	local win_init = false
	local win_font = GetVariable("mcvar_window_font") or "Lucida Sans Unicode"
	local win_font_size = tonumber(GetVariable("mcvar_window_font_size")) or 8
	local win_font_bold = tonumber(GetVariable("mcvar_window_font_bold")) or 0
	local win_font_italic = tonumber(GetVariable("mcvar_window_font_italic")) or 0
	local win_font_underline = tonumber(GetVariable("mcvar_window_font_underline")) or 0
	local win_hotspots = {}
	local win_target_hotspots = {}
	local win_hide_settings_button = GetVariable("mcvar_window_hide_settings_button") or "off"
	local last_installed_version = GetVariable("last_installed_version")

-- [[ S&D window color data]]
	local win_bgcolor = 0x000000

	NOTE_COLORS = {
		INFO 					= "#FF5000",
		INFO_HIGHLIGHT 			= "#00B4E0",

		IMPORTANT 				= "#FFFFFF",
		IMPORTANT_HIGHLIGHT 	= "#00FF00",
		IMPORTANT_BACKGROUND 	= "#000080",

		ERROR 					= "#FFFFFF",
		ERROR_HIGHLIGHT 		= "#FFE32E",
		ERROR_BACKGROUND 		= "#650101",

		DEBUG					= "#87CEFA",
		DEBUG_HIGHLIGHT			= "#FFD700",
	}

	TEXT_COLOR_DETAILS = {
		{ key = "normal",			default = "#E0E0E0", menu_name = "Normal mobs",
			desc = "normal mobs" },
		{ key = "targeted",			default = "#FF4000", menu_name = "Targeted mob",
			desc = "the currently targeted mob"},
		{ key = "dead",				default = "#484848", menu_name = "Dead mobs",
			desc = "a dead mobs" },
		{ key = "unknown",			default = "#FF0000", menu_name = "Unknown mobs",
			desc = "mobs in an unknown area" },
		{ key = "unknown_dead",		default = "#900000", menu_name = "Unknown dead mobs",
			desc = "deads mob in an unknown areas" },
		{ key = "unlikely",			default = "#484848", menu_name = "Unlikely mobs",
			desc = "mobs that are not likely to be the target in a room-based campaign or global quest"},
		{ key = "unlikely_tag",		default = "#0000CD", menu_name = "Unlikely tag",
			desc = "the tag beside unlikely mobs" },
		{ key = "quest_available",	default = "#1E90FF", menu_name = "Quest available",
			desc = "the text informing you that you have a quest available" },
		{ key = "quest_complete",	default = "#7CFC00", menu_name = "Quest complete",
			desc = "the text informing you that you have a quest to turn in"},
		{ key = "alternating_row",	default = "#000040", menu_name = "Alternating Row Backgrounds",
			desc = "the background color on alternating rows of the targets list in the mud window. Set it to black to disable"},
	}

	local text_colors = {}

	for i, details in ipairs(TEXT_COLOR_DETAILS) do
		text_colors[details.key] = GetVariable("color_" .. details.key) or details.default
	end

-- [[ Con and scan stuff ]]
	local xset_nx_action = GetVariable("mcvar_xset_nx_action") or (GetVariable("mcvar_xset_autocon_onoff") == "on" and "smartscan") or "qs"
	if xset_nx_action == "conscan" then
		xset_nx_action = "smartscan"
	end

	local xset_overwrite_con = GetVariable("mcvar_xset_overwrite_con") or "on"

	local scanned_mobs_here = {}
	local considered_mobs_here = {}
	local scan_full_display = {}
	local mobs_in_scanned_room = {}
	local doors_in_scanned_room = {}
	local activity_target_found_here = false
	local quest_target_found_here = false
	local target_found_nearby = false
	local other_target_found_here = false
	local scanning_current_room = false
	local running_smart_scan = false
	local con_after_scan = false

	local mob_count_here = 0

-- [[ Sound settings ]]
	-- Defaults on if soundpack is enabled, off otherwise
	local xset_sound_onoff = GetVariable("mcvar_xset_sound_onoff") or (IsPluginInstalled(plugin_id_soundpack) and GetPluginInfo(plugin_id_soundpack, 17) and "on") or "off"

	local target_nearby_sound = "target_nearby.wav"
	local other_target_here_sound = "other_target_here.wav"

-- [[ Image state ]]
	local images_loaded = false

-- [[ S&D dev stuff ]]
	local debug_mode = GetVariable("debug_mode") or "off"

    versionURL      = "https://raw.githubusercontent.com/AardCrowley/Search-and-Destroy/master/VERSION"
	pluginURL       = "https://raw.githubusercontent.com/AardCrowley/Search-and-Destroy/%s/Search_and_Destroy.xml"
	changelogURL    = "https://raw.githubusercontent.com/AardCrowley/Search-and-Destroy/v%s/changelog"
	soundsURL       = "https://raw.githubusercontent.com/AardNaricain/Search-and-Destroy/download-sounds/%s"

--	[[ Plugin broadcast/receive process ]]
	function OnPluginBroadcast(msg, id, name, text)
		if (id == plugin_id_gmcp_handler) then
			if (text == "char.status") then		-- character status
				current_character_state = gmcp("char.status.state")
			elseif (text == "room.info") then	-- current/previous room info
				local ri = gmcp("room.info")
				ri.maze = (string.match(ri.details, "maze") == "maze") and 1 or 0
				previous_room = current_room or { rmid="-2", arid="-2" }
				current_room = { rmid = ri.num, arid = ri.zone, exits = ri.exits, maze = ri.maze } or {}
				if (current_room.rmid == previous_room.rmid) then
					-- do nothing
				else
					if (#room_history == 300) then
						room_history[300] = nil
					end
					table.insert(room_history, 1, room_history[0])
					room_history[0] = { rmid = current_room.rmid, arid=current_room.arid }
				end

			elseif (text == "comm.quest") then	-- quest info
				local q = gmcp("comm.quest")
				quest_status_gmcp(q)
			elseif (text == "config") then		-- config data, needed for automatic noexp
				noexp_onoff = (gmcp("config.noexp") == "YES") and "on" or "off"
			end
		end
	end

-- [[ Plugin installation ]]
	function OnPluginInstall()
		ColourNote("#808080", "", "\n+=================================================================+")
		ColourNote("#FF3000", "", "    " .. current_sd_version .. " installed at " .. os.date() )
		print("")
		ColourNote("#FF3000", "", "    " .. "For support, contact Crowley and Naricain" )
		ColourNote("#FF3000", "", "    " .. "Note: It's beneficial to run 'xset index areas' if you have never run it before." )
		ColourNote("#808080", "", "+=================================================================+\n")
		windowinfo = movewindow.install (win, miniwin.pos_center, miniwin.create_absolute_location, false, nil, {mouseup=MouseUp, mousedown=LeftClickOnly, dragmove=LeftClickOnly, dragrelease=LeftClickOnly},{x=win_pos_x, y=win_pos_y})
		xg_create_window()

		migrate_database()
        if not GetVariable("index_already_checked") then
            area_index_process()
            SetVariable("index_already_checked", "done")
        end
		download_sounds(function() end)
		--show_changelog(false)
        get_changelog(false)
	end

	function migrate_database()
		local db = sqlite3.open(GetInfo(66) .. "/SnDdb.db")
		local current_version

		create_initial_tables(db)

		for row in db:nrows("PRAGMA user_version") do
			current_version = row.user_version
		end

		if current_version >= SCHEMA_VERSION then return end

		Note("Migrating datase")

		-- Inidividual migrations go here
		if current_version == 0 then
			Note("Indexing areas")
			area_index_process()
		end

		if current_version < 2 then
			create_mob_keywords_table(db)
			strip_mobs_table(db)
		end

		db:execute(string.format("PRAGMA user_version = %i;", SCHEMA_VERSION))

		db:close_vm()
	end

	function create_initial_tables(db)
		local db_tables = {}
		local query = "SELECT name FROM sqlite_master WHERE type='table'"
		local create_tables = {}

		for row in db:nrows(query) do
			db_tables[row.name] = true
		end

		if not db_tables['mobs'] then
			Note("Creating table 'mobs'")
			table.insert(create_tables, [[
				CREATE TABLE mobs (
					mob 		TEXT NOT NULL,
					room 		TEXT NOT NULL,
					roomid 		INTEGER NOT NULL,
					zone 		TEXT NOT NULL,
					count 		INTEGER NOT NULL,
					keyword 	TEXT NOT NULL);
			]])
		end

		if not db_tables['area'] then
			Note("Creating table 'area'")
			table.insert(create_tables, [[
				CREATE TABLE 	area (
					name		TEXT NOT NULL,
					key			TEXT NOT NULL,
					minlvl		INTEGER NOT NULL,
					maxlvl		INTEGER NOT NULL,
					lock		INTEGER NOT NULL,
					startRoom	INTEGER,
					noquest		TEXT,
					vidblain	TEXT,
					userKey		TEXT);
			]])
		end

		if #create_tables > 0 then
			db:execute(table.concat(create_tables, ""))
		end
	end

	function create_mob_keywords_table(db)
		Note("Creating mob aliases database table")
		db:execute([[
			CREATE TABLE IF NOT EXISTS mob_keyword_exceptions (
				area_name	TEXT NOT NULL,
				mob_name	TEXT NOT NULL,
				keyword		TEXT NOT NULL,
				UNIQUE(area_name, mob_name)
			);
		]])
		populate_mob_keyword_table(db)
	end

	function strip_mobs_table(db)
		Note("Updating mobs table")
		db:execute([[
			BEGIN TRANSACTION;
			ALTER TABLE mobs RENAME TO old_mobs;
			CREATE TABLE mobs (
				mob 		TEXT NOT NULL COLLATE NOCASE,
				room 		TEXT NOT NULL COLLATE NOCASE,
				roomid 		INTEGER NOT NULL,
				zone 		TEXT NOT NULL,
				count 		INTEGER NOT NULL DEFAULT 0,
				UNIQUE(mob, roomid));
			INSERT INTO mobs SELECT mob COLLATE NOCASE, room COLLATE NOCASE, roomid, zone, SUM(count) as count FROM old_mobs GROUP BY mob COLLATE NOCASE, roomid;
			DROP TABLE old_mobs;
			COMMIT;
		]])
	end

	--[[Deprecated show_changelog

        function show_changelog(all_changes)
		local changes_to_show = {}

		if all_changes then
			changes_to_show = CHANGELOG
		elseif last_installed_version then
			last_installed_version = tonumber(last_installed_version)
			DebugNote("Last installed version ", last_installed_version)

			for version, notes in pairs(CHANGELOG) do
				if version > last_installed_version then
					changes_to_show[version] = notes
				end
			end
		else
			-- show only the latest change
			local latest_change_num = -1
			for version, notes in pairs(CHANGELOG) do
				if version > latest_change_num then
					latest_change_num = version
				end
			end
			changes_to_show[latest_change_num] = CHANGELOG[latest_change_num]
		end
		display_changes(changes_to_show)

		last_installed_version = PLUGIN_VERSION
		SetVariable("last_installed_version", tostring(PLUGIN_VERSION))
	end]]--

    function get_changelog(all_changes)
    	show_all_changes = all_changes or false
    	DebugNote("Attempting to download changelog")
    	download_file(string.format(changelogURL, PLUGIN_VERSION), show_changelog)
	end

	function show_changelog(retval, page, status, headers, full_status, request_url)

    	if status ~= 200 then
        	DebugNote("show_changelog got status ", status)
        	ErrorNote("Error while fetching changelog")
	        return
    	end

		local CHANGELOG = json.decode(page)

    	local changes_to_show = {}

	    if show_all_changes then
	        changes_to_show = CHANGELOG
    	elseif last_installed_version then
        	last_installed_version = tonumber(last_installed_version)
        	DebugNote("Last installed version ", last_installed_version)

        	for version, notes in pairs(CHANGELOG) do
        	    if tonumber(version) > tonumber(last_installed_version) then
    	            changes_to_show[version] = notes
	            end
        	end
    	else
        	-- show only the latest changes
        	local latest_change_num = -1
        	for version, notes in pairs(CHANGELOG) do
            	if tonumber(version) > latest_change_num then
    	            latest_change_num = version
	            end
        	end
	        changes_to_show[latest_change_num] = CHANGELOG[latest_change_num]
    	end
    	display_changes(changes_to_show)

    	last_installed_version = PLUGIN_VERSION
    	SetVariable("last_installed_version", tostring(PLUGIN_VERSION))
	end

	function display_changes(changes_to_show)
		local line_width = 80
		local versions = {}
		for version, notes in pairs(changes_to_show) do
			table.insert(versions, version)
		end
		if #versions == 0 then
			DebugNote("No updates to show in changelog")
			return
		end
		table.sort(versions)

		local function write_notes(lines)
			for i, line in ipairs(lines) do
				local indent_length = line:match("^>") and 8 or 4
				line = line:gsub("^>", "")
				local indent = string.rep(" ", indent_length)
				local indent1 = string.rep(" ", indent_length - 4) .. "  * "

				line = helpWrap(line, 76, indent, indent1):gsub("\n", "\n" .. indent)
				ColourNote(NOTE_COLORS.INFO, "", line)
			end
		end

		InfoNote(string.rep("=", 25), " Search and Destroy Changelog ", string.rep("=", 25), "\n")
		for i, version in ipairs(versions) do
			local head = string.format(" Version %s ", tostring(version))
			ColourTell(NOTE_COLORS.INFO, "", "===")
			ColourTell(NOTE_COLORS.INFO_HIGHLIGHT, "", head)
			ColourNote(NOTE_COLORS.INFO, "", string.rep("=", line_width - #head - 3))
			local notes = changes_to_show[version]

			if notes.features then
				ColourNote(NOTE_COLORS.INFO_HIGHLIGHT, "", "FEATURES:")
				write_notes(notes.features)
				print("")
			end

			if notes.changes then
				ColourNote(NOTE_COLORS.INFO_HIGHLIGHT, "", "CHANGES:")
				write_notes(notes.changes)
				print("")
			end

			if notes.fixes then
				ColourNote(NOTE_COLORS.INFO_HIGHLIGHT, "", "FIXES:")
				write_notes(notes.fixes)
				print("")
			end
			print("")
		end

		if changes_to_show ~= CHANGELOG then
			InfoNote("To see changes from all versions select ", "Changelog", " from the settings menu in the S&D window.\n")
		end
	end

	local init_called = 0
	function init_plugin()
		if not IsConnected() then return end
		local ch_state = current_character_state
		if ((ch_state ~= "3") and (ch_state ~= "8") and (ch_state ~= "9") and (ch_state ~= "11")) then
			send_gmcp_packet("request char")
			return
		end
      	SendNoEcho("tags scan on")
      	SendNoEcho("tags roomchars on")

		send_gmcp_packet("request room")
		init_called = init_called + 1
		if (init_called == 2) then
			EnableTimer("tim_init_plugin", false)
			load_saved_table_data()
			send_gmcp_packet("config noexp")
			send_gmcp_packet("request quest")
			toggle_con_overwrite_triggers()
			check_for_updates()
		end
	end

	-- Expecting an array of operations
	function execute_in_transaction(db, operations)
		query = "BEGIN TRANSACTION;" .. table.concat(operations, "") .. "COMMIT;"
		db:exec(query)
	end

-- [[ Lookup table:  Area start room, noquest true/false, vidblain areas ]]
	local areaDefaultStartRooms = {
		["abend"] 		= { start = "24909", ct = "3" },		-- Continents
		["alagh"] 		= { start =  "3224", ct = "4" },
		["gelidus"] 	= { start = "18780", ct = "2" },
		["mesolar"] 	= { start = "12664", ct = "0" },
		["southern"] 	= { start =  "5192", ct = "1" },
		["uncharted"] 	= { start =  "7701", ct = "5" },
		["vidblain"] 	= { start = "33570", ct = "6", vidblain = true },

		["aardington"] 	= { start = "47509" },		-- A --
		["academy"] 	= { start = "35233" },
		["adaldar"] 	= { start = "34400" },
		["afterglow"] 	= { start = "38134" },
		["agroth"] 		= { start = "11027" },
		["ahner"] 		= { start = "30129" },
		["alehouse"] 	= { start =   "885" },
		["amazon"] 		= { start =  "1409" },
		["amusement"] 	= { start = "29282" },
		["andarin"] 	= { start =  "2399" },
		["annwn"] 		= { start = "28963" },
		["anthrox"] 	= { start =  "3993" },
		["arboretum"] 	= { start = "39100" },
		["arena"] 		= { start = "25768" },
		["arisian"] 	= { start = "28144" },
		["ascent"] 		= { start = "43150" },
		["astral"] 		= { start = "27882" },
		["atlantis"] 	= { start = "10573" },
		["autumn"] 		= { start = "13839" },
		["avian"] 		= { start =  "4334" },
		["aylor"] 		= { start = "32418" },
		["bazaar"] 		= { start = "34454" },		-- B --
		["beer"] 		= { start = "20062" },
		["believer"] 	= { start = "25940" },
		["blackrose"] 	= { start =  "1817" },
		["bliss"] 		= { start = "29988" },
		["bonds"] 		= { start = "23411" },
		["caldera"] 	= { start = "26341" },		-- C --
		["callhero"] 	= { start = "33031" },
		["camps"] 		= { start =  "4714" },
		["canyon"] 		= { start = "25551" },
		["caravan"] 	= { start = "16071" },
		["cards"] 		= { start =  "6255" },
		["carnivale"] 	= { start = "28635" },
		["cataclysm"] 	= { start = "19976" },
		["cathedral"] 	= { start = "27497" },
		["cats"] 		= { start = "40900" },
		["chasm"] 		= { start = "29446" },
		["chessboard"]	= { start = "25513" },
		["childsplay"] 	= { start =   "678" },
		["cineko"] 		= { start =  "1507" },
		["citadel"] 	= { start = "14963" },
		["conflict"] 	= { start = "27711" },
		["coral"] 		= { start =  "4565" },
		["cougarian"] 	= { start = "14311" },
		["cove"] 		= { start = "49941" },
		["cradle"] 		= { start = "11267" },
		["crynn"] 		= { start = "43800" },
		["damned"] 		= { start = "10469" },		-- D --
		["darklight"] 	= { start = "19642", vidblain = true },
		["darkside"] 	= { start = "15060" },
		["ddoom"] 		= { start =  "4193" },
		["deadlights"] 	= { start = "16856" },
		["deathtrap"] 	= { start =  "1767" },
		["deneria"] 	= { start = "35006" },
		["desert"] 		= { start = "20186" },
		["desolation"] 	= { start = "19532" },
		["dhalgora"] 	= { start = "16755" },
		["diatz"] 		= { start =  "1254" },
		["diner"] 		= { start = "36700" },
		["dortmund"] 	= { start = "16577" },
		["drageran"] 	= { start = "25894" },
		["dread"] 		= { start = "26075" },
		["dsr"] 		= { start = "30030" },
		["dundoom"] 	= { start = "25661" },
		["dunoir"] 		= { start = "14222" },
		["duskvalley"] 	= { start = "37301" },
		["dynasty"] 	= { start = "30799" },
		["earthlords"] 	= { start = "42000" },		-- E --
		["earthplane"] 	= { start =  "1354" },
		["elemental"] 	= { start = "41624" },
		["empire"] 		= { start = "32203" },
		["empyrean"] 	= { start = "14042" },
		["entropy"] 	= { start = "29773" },
		["fantasy"] 	= { start = "15205" },		-- F --
		["farm"] 		= { start = "10676" },
		["fayke"] 		= { start = "30418" },
		["fens"] 		= { start = "16528" },
		["fields"] 		= { start = "29232" },
		["firebird"] 	= { start = "32885" },
		["firenation"] 	= { start = "41879" },
		["fireswamp"] 	= { start = "34755" },
		["fortress"] 	= { start = "31835" },
		["fortune"] 	= { start = "38561" },
		["fractured"] 	= { start = "17033" },
		["ft1"] 		= { start =  "1205" },
		["ftii"] 		= { start = "26673" },
		["gallows"] 	= { start =  "4344" },		-- G --
		["gathering"] 	= { start = "36451" },
		["gauntlet"] 	= { start = "31652" },
		["gilda"] 		= { start =  "4243" },
		["glamdursil"] 	= { start = "35055" },
		["glimmerdim"] 	= { start = "26252" },
		["gnomalin"] 	= { start = "34397" },
		["goldrush"] 	= { start = "15014" },
		["graveyard"] 	= { start = "28918" },
		["greece"] 		= { start =  "2089" },
		["gwillim"] 	= { start = "25974" },
		["hades"] 		= { start = "29161" },		-- H --
		["hatchling"]	= { start = "34670" },
		["hawklord"] 	= { start = "40550" },
		["hedge"] 		= { start = "15146" },
		["helegear"] 	= { start = "30699" },
		["hell"] 		= { start = "30984" },
		["hoard"] 		= { start =  "1675" },
		["hodgepodge"] 	= { start = "30469" },
		["horath"] 		= { start =    "91" },
		["horizon"] 	= { start = "31959" },
		["illoria"] 	= { start = "10420" },
		["imagi"] 		= { start = "36800" },		-- I --
		["imperial"] 	= { start = "16966", vidblain = true },
		["infamy"] 		= { start = "26641" },
		["infest"] 		= { start = "16165" },
		["insan"] 		= { start =  "6850" },
		["jenny"] 		= { start = "29637" },		-- J --
		["jotun"] 		= { start = "31508" },
		["kearvek"] 	= { start = "29722" },		-- K --
		["kerofk"] 		= { start = "16405" },
		["ketu"] 		= { start = "35114" },
		["kingsholm"] 	= { start = "27522" },
		["knossos"] 	= { start = "28193" },
		["kobaloi"] 	= { start = "10691" },
		["kultiras"] 	= { start = "31161" },
		["lab"] 		= { start = "28684" },		-- L --
		["labyrinth"] 	= { start = "31405" },
		["lagoon"] 		= { start = "30549" },
		["landofoz"] 	= { start =   "510" },
		["laym"] 		= { start =  "6005" },
		["legend"] 		= { start = "16224" },
		["lemdagor"] 	= { start =  "1966" },
		["lidnesh"] 	= { start = "27995" },
		["livingmine"] 	= { start = "37008" },
		["longnight"] 	= { start = "26367" },
		["losttime"] 	= { start = "28584" },
		["lowlands"] 	= { start = "28044" },
		["lplanes"] 	= { start = "29364" },
		["maelstrom"] 	= { start = "38058" },		-- M --
		["manor"] 		= { start = "10621" },
		["masq"] 		= { start = "29840" },
		["mayhem"] 		= { start =  "1866" },
		["melody"] 		= { start = "14172" },
		["minos"] 		= { start = "20472" },
		["mistridge"] 	= { start =  "4491" },
		["monastery"] 	= { start = "15756" },
		["mudwog"] 		= { start =  "2347" },
		["nanjiki"] 	= { start = "11203" },		-- N --
		["necro"] 		= { start = "29922" },
		["nenukon"] 	= { start = "31784" },
		["newthalos"] 	= { start = "23853" },
		["ninehells"] 	= { start =  "4613" },
		["northstar"] 	= { start = "11127" },
		["nottingham"] 	= { start = "11077" },
		["nulan"] 		= { start = "37900" },
		["nursing"] 	= { start = "31977" },
		["nynewoods"] 	= { start = "23562" },
		["oceanpark"] 	= { start = "39600" },		-- O --
		["omentor"] 	= { start = "15579", vidblain = true },
		["ooku"] 		= { start = "39000" },
		["origins"] 	= { start = "35900" },
		["orlando"] 	= { start = "30331" },
		["paradise"] 	= { start = "29624" },		-- P --
		["partroxis"] 	= { start =  "5814" },
		["peninsula"] 	= { start = "35701" },
		["petstore"] 	= { start =   "995" },
		["pompeii"] 	= { start =    "57" },
		["promises"] 	= { start = "25819" },
		["prosper"] 	= { start = "28268" },
		["qong"] 		= { start = "16115" },		-- Q --
		["quarry"] 		= { start = "23510" },
		["radiance"] 	= { start = "19805" },		-- R --
		["raga"] 		= { start = "19861" },
		["raukora"] 	= { start =  "6040" },
		["rebellion"] 	= { start = "10305" },
		["remcon"] 		= { start = "25837" },
		["reme"] 		= { start = "32703" },
		["rosewood"] 	= { start =  "6901" },
		["ruins"] 		= { start = "16805" },
		["sagewood"] 	= { start = "28754" },		-- S --
		["sahuagin"] 	= { start = "34592" },
		["salt"] 		= { start =  "4538" },
		["sanctity"] 	= { start = "10518" },
		["sanctum"] 	= { start = "15307" },
		["sandcastle"] 	= { start = "37701" },
		["sanguine"] 	= { start = "15436" },
		["scarred"] 	= { start = "34036" },
		["sendhian"] 	= { start = "20288", vidblain = true },
		["sennarre"] 	= { start = "15491" },
		["shadowsend"]	= { start = "40096" },
		["shouggoth"] 	= { start = "34087" },
		["siege"] 		= { start = "43265" },
		["sirens"] 		= { start = "16298" },
		["slaughter"] 	= { start =  "1601" },
		["snuckles"] 	= { start =   "182" },
		["soh"] 		= { start = "25611" },
		["sohtwo"] 		= { start = "30752" },
		["solan"] 		= { start = "23713" },
		["songpalace"] 	= { start = "47013" },
		["spyreknow"] 	= { start = "34800" },
		["stone"] 		= { start = "11386" },
		["storm"] 		= { start =  "6304" },
		["stormhaven"] 	= { start = "20649" },
		["stronghold"] 	= { start = "20572" },
		["stuff"] 		= { start = "40400" },
		["takeda"] 		= { start = "15952" },		-- T --
		["talsa"] 		= { start = "26917" },
		["temple"] 		= { start = "31597" },
		["tanra"] 		= { start = "46913" },
		["terra"] 		= { start = "19679" },
		["terramire"] 	= { start =  "4493" },
		["thieves"] 	= { start =     "7" },
		["tilule"]		= { start = "39771"	},
		["times"] 		= { start = "28463" },
		["tirna"] 		= { start = "20136" },
		["titan"] 		= { start = "38234" },
		["tol"] 		= { start = "16325" },
		["tombs"] 		= { start = "15385" },
		["umari"] 		= { start = "36601" },		-- U --
		["underdark"] 	= { start = "27341" },
		["uplanes"] 	= { start = "29364" },
		["uprising"] 	= { start = "15382" },
		["vale"] 		= { start =  "1036" },		-- V --
		["verdure"] 	= { start = "24090" },
		["verume"] 		= { start = "30607" },
		["village"] 	= { start = "30850" },
		["vlad"] 		= { start = "15970" },
		["volcano"] 	= { start =  "6091" },
		["weather"] 	= { start = "40499" },		-- W --
		["werewood"] 	= { start = "30956" },
		["wildwood"] 	= { start =   "322" },
		["winter"] 		= { start =  "1306" },
		["wizards"] 	= { start = "31316" },
		["wonders"] 	= { start = "32981" },
		["wooble"] 		= { start = "11335" },
		["woodelves"] 	= { start = "32199" },
		["wtc"] 		= { start = "37895" },
		["wyrm"] 		= { start = "28847" },
		["xmas"] 		= { start =  "6212" },		-- X --
		["xylmos"] 		= { start =   "472" },
		["yarr"] 		= { start = "30281" },
		["ygg"] 		= { start = "24186" },		-- Y --
		["yurgach"] 	= { start = "29450" },
		["zangar"] 		= { start =  "6164" },		-- Z --
		["zodiac"] 		= { start = "15857" },
		["zoo"] 		= { start =  "5920" },
		["zyian"] 		= { start =   "729" },
		-- Non-questable Areas
		["manor1"] 		= { start = "14460", noquest = true },		-- Manor areas
		["manor3"] 		= { start = "20836", noquest = true },
		["manorisle"] 	= { start =  "6366", noquest = true },
		["manormount"] 	= { start = "39449", noquest = true },
		["manorsea"] 	= { start = "35003", noquest = true },
		["manorville"] 	= { start = "35004", noquest = true },
		["manorwoods"] 	= { start = "35002", noquest = true },
		["blackclaw"]	= { start = "   -1", noquest = true }, -- epic areas
		["geniewish"] 	= { start = "38464", noquest = true },
		["icefall"] 	= { start = "38701", noquest = true },
		["inferno"]		= { start =    "-1", noquest = true },
		["oradrin"] 	= { start = "25436", noquest = true },
		["winds"] 		= { start = "39900", noquest = true },

		["badtrip"] 	= { start = "32877", noquest = true },		-- Other no-quest areas
		["birthday"]	= { start = "10920", noquest = true },
		["seaking"]		= { start =    "-1", noquest = true },
		["amazonclan"] 	= { start = "34212", noquest = true },		-- Public clan halls
		["bard"] 		= { start = "30538", noquest = true },
		["bootcamp"] 	= { start = "49256", noquest = true },
		["cabal"] 		= { start = "15704", noquest = true },
		["chaos"] 		= { start = "28909", noquest = true },
		["crimson"] 	= { start = "27989", noquest = true },
		["crusaders"] 	= { start = "31122", noquest = true },
		["daoine"] 		= { start = "30949", noquest = true },
		["doh"] 		= { start = "16803", noquest = true },
		["dominion"] 	= { start =  "5863", noquest = true },
		["dragon"] 		= { start =   "642", noquest = true },
		["druid"] 		= { start = "29582", noquest = true },
		["emerald"] 	= { start =   "831", noquest = true },
		["gaardian"] 	= { start = "20026", noquest = true },
		["imperium"] 	= { start = "30415", noquest = true },
		["light"] 		= { start =  "2339", noquest = true },
		["loqui"] 		= { start = "28580", noquest = true },
		["masaki"] 		= { start = "15852", noquest = true },
		["perdition"] 	= { start = "19968", noquest = true },
		["pyre"] 		= { start = "15141", noquest = true },
		["romani"] 		= { start = "24180", noquest = true },
		["seekers"] 	= { start = "14165", noquest = true },
		["shadokil"] 	= { start = "32407", noquest = true },
		["tanelorn"] 	= { start = "31561", noquest = true },
		["tao"] 		= { start = "29210", noquest = true },
		["touchstone"] 	= { start = "28346", noquest = true },
		["twinlobe"] 	= { start = "15575", noquest = true },
		["vanir"] 		= { start =   "878", noquest = true },
		["watchmen"] 	= { start = "32342", noquest = true },

		["baal"] 		= { start =    "-1", noquest = true },		-- Closed clan halls
		["hook"] 		= { start =    "-1", noquest = true },
		["retri"] 		= { start =    "-1", noquest = true },
		["rhabdo"] 		= { start =    "-1", noquest = true },
		["rogues"] 		= { start =    "-1", noquest = true },
		["xunti"] 		= { start =    "-1", noquest = true },

		["challenge"]	= { start =    "-1", noquest = true },		-- Normally inaccessible areas, or which lack a sensible starting room.
		["immhomes"]	= { start =    "-1", noquest = true },
		["lasertwo"]	= { start =    "-1", noquest = true },
		["limbo"]		= { start =    "-1", noquest = true },
		["lualand"]		= { start =    "-1", noquest = true },
		["midgaard"]	= { start =    "-1", noquest = true },
		["oldclanone"] 	= { start =    "-1", noquest = true },
		["oldclantwo"] 	= { start =    "-1", noquest = true },
		["oldclanthr"] 	= { start =    "-1", noquest = true },
		["oldclanfou"] 	= { start =    "-1", noquest = true },
		["vault"]		= { start =    "-1", noquest = true },
		["warzone"]		= { start =    "-1", noquest = true },
		["wolfmaze"]	= { start =    "-1", noquest = true } }

	local vidblain_area_list = {
		["darklight"] 	= { },
		["imperial"] 	= { },
		["omentor"] 	= { },
		["sendhian"] 	= { },
		["vidblain"] 	= { } }

--	[[ Lookup table to get area id from area long name ]]
	local areaNameXref = {
		["A Genie's Last Wish"] 				= "geniewish",
		["A Magical Hodgepodge"] 				= "hodgepodge",
		["A Peaceful Giant Village"]			= "village",
		["Aardington Estate"]					= "aardington",
		["Aardwolf Zoological Park"] 			= "zoo",
		["Adventures in Sendhia"] 				= "sendhian",
		["Aerial City of Cineko"] 				= "cineko",
		["Afterglow"] 							= "afterglow",
		["Alagh, the Blood Lands"] 				= "alagh",
		["All in a Fayke Day"] 					= "fayke",
		["Ancient Greece"] 						= "greece",
		["Andolor's Ocean Adventure Park"] 		= "oceanpark",
		["Annwn"] 								= "annwn",
		["Anthrox"] 							= "anthrox",
		["Arboretum"] 							= "arboretum",
		["Arisian Realm"] 						= "arisian",
		["Art of Melody"] 						= "melody",
		["Artificer's Mayhem"] 					= "mayhem",
		["Ascension Bluff Nursing Home"] 		= "nursing",
		["Atlantis"] 							= "atlantis",
		["Avian Kingdom"] 						= "avian",
		["Battlefields of Adaldar"] 			= "adaldar",
		["Black Lagoon"] 						= "lagoon",
		["Black Rose"] 							= "blackrose",
		["Brightsea and Glimmerdim"]			= "glimmerdim",
		["Canyon Memorial Hospital"] 			= "canyon",
		["Castle Vlad-Shamir"] 					= "vlad",
		["Chaprenula's Laboratory"] 			= "lab",
		["Child's Play"] 						= "childsplay",
		["Christmas Vacation"] 					= "xmas",
		["Cloud City of Gnomalin"] 				= "gnomalin",
		["Cradlebrook"] 						= "cradle",
		["Crossroads of Fortune"] 				= "fortune",
		["Crynn's Church"] 						= "crynn",
		["Dark Elf Stronghold"] 				= "stronghold",
		["Death's Manor"] 						= "manor",
		["Deathtrap Dungeon"] 					= "deathtrap",
		["Den of Thieves"] 						= "thieves",
		["Descent to Hell"] 					= "hell",
		["Desert Doom"] 						= "ddoom",
		["Dhal'Gora Outlands"] 					= "dhalgora",
		["Diamond Soul Revelation"] 			= "dsr",
		["Dortmund"] 							= "dortmund",
		["Dread Tower"] 						= "dread",
		["Dusk Valley"] 						= "duskvalley",
		["Earth Plane 4"] 						= "earthplane",
		["Elemental Chaos"] 					= "elemental",
		["Empyrean, Streets of Downfall"] 		= "empyrean",
		["Entrance to Hades"] 					= "hades",
		["Eternal Autumn"] 						= "autumn",
		["Faerie Tales II"] 					= "ftii",
		["Faerie Tales"] 						= "ft1",
		["Fantasy Fields"] 						= "fantasy",
		["Foolish Promises"] 					= "promises",
		["Fort Terramire"] 						= "terramire",
		["Gallows Hill"] 						= "gallows",
		["Gelidus"] 							= "gelidus",
		["Giant's Pet Store"] 					= "petstore",
		["Gilda And The Dragon"] 				= "gilda",
		["Gnoll's Quarry"] 						= "quarry",
		["Gold Rush"] 							= "goldrush",
		["Guardian's Spyre of Knowledge"] 		= "spyreknow",
		["Gypsy Caravan"] 						= "caravan",
		["Halls of the Damned"] 				= "damned",
		["Hatchling Aerie"] 					= "hatchling",
		["Hedgehogs' Paradise"] 				= "hedge",
		["Helegear Sea"] 						= "helegear",
		["Hotel Orlando"] 						= "orlando",
		["House of Cards"] 						= "cards",
		["Icefall"] 							= "icefall",
		["Imagi's Nation"] 						= "imagi",
		["Imperial Nation"] 					= "imperial",
		["Insanitaria"] 						= "insan",
		["Into the Long Night"] 				= "longnight",
		["Intrigues of Times Past"] 			= "times",
		["Island of Lost Time"] 				= "losttime",
		["Jenny's Tavern"] 						= "jenny",
		["Jotunheim"] 							= "jotun",
		["Jungles of Verume"] 					= "verume",
		["Keep of the Kobaloi"] 				= "kobaloi",
		["Kerofk"] 								= "kerofk",
		["Ketu Uplands"] 						= "ketu",
		["Kiksaadi Cove"] 						= "cove",
		["Kimr's Farm"] 						= "farm",
		["Kingdom of Ahner"] 					= "ahner",
		["Kingsholm"] 							= "kingsholm",
		["Kobold Siege Camp"] 					= "siege",
		["Kul Tiras"] 							= "kultiras",
		["Land of Legend"] 						= "legend",
		["Living Mines of Dak'Tai"] 			= "livingmine",
		["Masquerade Island"] 					= "masq",
		["Mount duNoir"] 						= "dunoir",
		["Mudwog's Swamp"] 						= "mudwog",
		["Nanjiki Ruins"] 						= "nanjiki",
		["Nebulous Horizon"] 					= "horizon",
		["Necromancers' Guild"] 				= "necro",
		["Nenukon and the Far Country"] 		= "nenukon",
		["New Thalos"] 							= "newthalos",
		["Northstar"] 							= "northstar",
		["Nottingham"] 							= "nottingham",
		["Olde Worlde Carnivale"]				= "carnivale",
		["Onyx Bazaar"] 						= "bazaar",
		["Ookushka Garrison"] 					= "ooku",
		["Paradise Lost"] 						= "paradise",
		["Plains of Nulan'Boar"] 				= "nulan",
		["Pompeii"] 							= "pompeii",
		["Prosper's Island"] 					= "prosper",
		["Qong"] 								= "qong",
		["Radiance Woods"] 						= "radiance",
		["Raganatittu"] 						= "raga",
		["Realm of Deneria"] 					= "deneria",
		["Realm of the Firebird"] 				= "firebird",
		["Realm of the Sacred Flame"] 			= "firenation",
		["Realm of the Zodiac"] 				= "zodiac",
		["Rebellion of the Nix"] 				= "rebellion",
		["Rosewood Castle"] 					= "rosewood",
		["Sagewood Grove"] 						= "sagewood",
		["Sanctity of Eternal Damnation"] 		= "sanctity",
		["Sen'narre Lake"] 						= "sennarre",
		["Seven Wonders"] 						= "wonders",
		["Shadow's End"]						= "shadowsend",
		["Sheila's Cat Sanctuary"] 				= "cats",
		["Sho'aram, Castle in the Sand"] 		= "sandcastle",
		["Siren's Oasis Resort"] 				= "sirens",
		["Snuckles Village"] 					= "snuckles",
		["Storm Mountain"] 						= "storm",
		["Storm Ships of Lem-Dagor"] 			= "lemdagor",
		["Sundered Vale"] 						= "vale",
		["Swordbreaker's Hoard"] 				= "hoard",
		["Tairayden Peninsula"] 				= "peninsula",
		["Tai'rha Laym"] 						= "laym",
		["Takeda's Warcamp"] 					= "takeda",
		["Tanra'vea"] 							= "tanra",
		["Thandeld's Conflict"] 				= "conflict",
		["The Abyssal Caverns of Sahuagin"] 	= "sahuagin",
		["The Amazon Nation"] 					= "amazon",
		["The Amusement Park"] 					= "amusement",
		["The Archipelago of Entropy"] 			= "entropy",
		["The Astral Travels"] 					= "astral",
		["The Aylorian Academy"] 				= "academy",
		["The Blighted Tundra of Andarin"] 		= "andarin",
		["The Blood Opal of Rauko'ra"] 			= "raukora",
		["The Blood Sanctum"] 					= "sanctum",
		["The Broken Halls of Horath"] 			= "horath",
		["The Call of Heroes"] 					= "callhero",
		["The Cataclysm"] 						= "cataclysm",
		["The Chasm and The Catacombs"] 		= "chasm",
		["The Chessboard"] 						= "chessboard",
		["The Continent of Mesolar"] 			= "mesolar",
		["The Coral Kingdom"] 					= "coral",
		["The Cougarian Queendom"] 				= "cougarian",
		["The Council of the Wyrm"] 			= "wyrm",
		["The Covenant of Mistridge"] 			= "mistridge",
		["The Cracks of Terra"] 				= "terra",
		["The Curse of the Midnight Fens"] 		= "fens",
		["The Dark Continent, Abend"] 			= "abend",
		["The Dark Temple of Zyian"] 			= "zyian",
		["The DarkLight"] 						= "darklight",
		["The Darkside of the Fractured Lands"] = "darkside",
		["The Deadlights"] 						= "deadlights",
		["The Desert Prison"] 					= "desert",
		["The Drageran Empire"] 				= "drageran",
		["The Dungeon of Doom"] 				= "dundoom",
		["The Earth Lords"] 					= "earthlords",
		["The Eighteenth Dynasty"] 				= "dynasty",
		["The Empire of Aiighialla"] 			= "empire",
		["The Empire of Talsa"] 				= "talsa",
		["The Fabled City of Stone"] 			= "stone",
		["The Fire Swamp"] 						= "fireswamp",
		["The First Ascent"] 					= "ascent",
		["The Flying Citadel"] 					= "citadel",
		["The Forest of Li'Dnesh"] 				= "lidnesh",
		["The Fractured Lands"] 				= "fractured",
		["The Gathering Horde"] 				= "gathering",
		["The Gauntlet"] 						= "gauntlet",
		["The Gladiator's Arena"] 				= "arena",
		["The Glamdursil"] 						= "glamdursil",
		["The Goblin Fortress"] 				= "fortress",
		["The Grand City of Aylor"] 			= "aylor",
		["The Graveyard"] 						= "graveyard",
		["The Great City of Knossos"]			= "knossos",
		["The Great Salt Flats"] 				= "salt",
		["The Icy Caldera of Mauldoon"] 		= "caldera",
		["The Imperial City of Reme"] 			= "reme",
		["The Infestation"] 					= "infest",
		["The Keep of Kearvek"] 				= "kearvek",
		["The Killing Fields"] 					= "fields",
		["The Labyrinth"] 						= "labyrinth",
		["The Land of Oz"] 						= "landofoz",
		["The Land of the Beer Goblins"] 		= "beer",
		["The Lower Planes"] 					= "lplanes",
		["The Maelstrom"] 						= "maelstrom",
		["The Marshlands of Agroth"] 			= "agroth",
		["The Misty Shores of Yarr"] 			= "yarr",
		["The Monastery"] 						= "monastery",
		["The Mountains of Desolation"] 		= "desolation",
		["The Nine Hells"] 						= "ninehells",
		["The Nyne Woods"] 						= "nynewoods",
		["The Old Cathedral"] 					= "cathedral",
		["The Palace of Song"] 					= "songpalace",
		["The Partroxis"] 						= "partroxis",
		["The Path of the Believer"] 			= "believer",
		["The Realm of Infamy"] 				= "infamy",
		["The Realm of the Hawklords"] 			= "hawklord",
		["The Relinquished Tombs"] 				= "tombs",
		["The Reman Conspiracy"] 				= "remcon",
		["The Ruins of Diamond Reach"] 			= "ruins",
		["The Ruins of Stormhaven"] 			= "stormhaven",
		["The Sanguine Tavern"] 				= "sanguine",
		["The Scarred Lands"] 					= "scarred",
		["The School of Horror"] 				= "soh",
		["The Shadows of Minos"] 				= "minos",
		["The Silver Volcano"] 					= "volcano",
		["The Slaughter House"] 				= "slaughter",
		["The Southern Ocean"] 					= "southern",
		["The Stuff of Shadows"] 				= "stuff",
		["The Temple of Shal'indrael"] 			= "temple",
		["The Temple of Shouggoth"] 			= "shouggoth",
		["The Three Pillars of Diatz"] 			= "diatz",
		["The Titans' Keep"] 					= "titan",
		["The Tournament of Illoria"] 			= "illoria",
		["The Town of Solan"] 					= "solan",
		["The Tree of Life"] 					= "tol",
		["The Trouble with Gwillimberry"] 		= "gwillim",
		["The Uncharted Oceans"] 				= "uncharted",
		["The UnderDark"] 						= "underdark",
		["The Upper Planes"] 					= "uplanes",
		["The Uprising"] 						= "uprising",
		["The Were Wood"] 						= "werewood",
		["The Witches of Omen Tor"] 			= "omentor",
		["The Wobbly Woes of Woobleville"] 		= "wooble",
		["The Wood Elves of Nalondir"] 			= "woodelves",
		["The Yurgach Domain"] 					= "yurgach",
		["Tilule Rehabilitation Clinic"]		= "tilule",
		["Tir na nOg"] 							= "tirna",
		["Tournament Camps"] 					= "camps",
		["Tribal Origins"] 						= "origins",
		["Tumari's Diner"] 						= "diner",
		["Umari's Castle"] 						= "umari",
		["Unearthly Bonds"] 					= "bonds",
		["Verdure Estate"] 						= "verdure",
		["Vidblain, the Ever Dark"] 			= "vidblain",
		["War of the Wizards"] 					= "wizards",
		["Warrior's Training Camp"] 			= "wtc",
		["Wayward Alehouse"] 					= "alehouse",
		["Weather Observatory"] 				= "weather",
		["Wedded Bliss"] 						= "bliss",
		["Wildwood"] 							= "wildwood",
		["Winds of Fate"] 						= "winds",
		["Winterlands"] 						= "winter",
		["Xyl's Mosaic"] 						= "xylmos",
		["Yggdrasil: The World Tree"] 			= "ygg",
		["Zangar's Demonic Grotto"] 			= "zangar" }

-- 	[[ Lookup table: Game calendar data]]
	local gCalendar = { }

--	[[ Load saved table data ]]
	function load_saved_table_data()
		load_area_start_rooms()
		load_area_range_index()
	end

	function load_area_start_rooms()
		if (GetVariable("mcvar_areaStartRooms") ~= nil) then
			code = "obj = " .. GetVariable("mcvar_areaStartRooms")
			assert (loadstring (code or "")) ()
			area_start_rooms = obj
		end
	end

	function load_area_range_index()
		send_gmcp_packet("request room")
		if (GetVariable("mcvar_area_range") ~= nil) then
			code = "obj = " .. GetVariable("mcvar_area_range")
			assert(loadstring (code or "")) ()
			area_range_index = obj
			do_cp_info()
		else
			area_index_process()
		end
	end

--	[[ Area index process ]]
	function area_index_process()
        DebugNote("Processing area index")
		Execute("xset suspend page size")
		DoAfterSpecial(0.1, [[ SendNoEcho("areas 1 300 keyword") ]], sendto.script)
	end

	function area_index_start()		-- called by trigger for "Showing areas from 0 to 300" line at start of areas list.
		area_range_index = {}
		InfoNote("*** Indexing area levels")
	end

function area_index_line(name, line, wildcards) -- 1055
	SnDdb = assert(sqlite3.open(GetInfo(66) .. "/SnDdb.db"))
	local sqlQuery = "INSERT INTO area VALUES (\"%s\", \"%s\", \"%d\", \"%d\", \"%d\", \"%d\", \"%s\", \"%s\", \"%s\")"

	local areaName = Trim(wildcards.areaName)
	local arid = Trim(wildcards.arid)
	local minLvl = tonumber(Trim(wildcards.min)) or 1
	local maxLvl = tonumber(Trim(wildcards.max)) or 201
	local levelLock = tonumber(Trim(wildcards.lock)) or 0
	local noQuest = (areaDefaultStartRooms[arid].noquest == true and "true") or "false"
	local vidblain = (tostring(areaDefaultStartRooms[arid].vidblain) == true and "true") or "false"

	if arid == "sahuagin" then
		areaName = "The Abyssal Caverns of Sahuagin"
	elseif arid == "darkside" then
		areaName = "The Darkside of the Fractured Lands"
	elseif arid == "academy" or arid == "lowlands" then
		maxLvl = 10
	elseif arid == "sohtwo" then
		minLvl = 170
	end

	area_range_index[areaName] = { arid = arid, min = minLvl, max = maxLvl }	-- lock = levelLock }

	local queryExists = "SELECT * FROM area WHERE name LIKE '%s'"

	local areaExists = false

	for a in SnDdb:rows(queryExists:format(areaName:gsub("'", "''"))) do
		if a[1] then
			areaExists = true
			break
		end
	end

	if not areaExists then
		if areaDefaultStartRooms[arid] then
			sqlQuery = sqlQuery:format(areaName, arid, minLvl, maxLvl, levelLock, areaDefaultStartRooms[arid].start, noQuest, vidblain, arid)
		else
			sqlQuery = sqlQuery:format(areaName, arid, minLvl, maxLvl, levelLock, -1, noQuest, vidblain, arid)
			ErrorNote("*** Missing default start room - ", areaName)
			ErrorNote("*** Please update by manually running to the area and using '", "xset mark", "'.")
		end

		SnDdb:exec(sqlQuery)
	end

	SnDdb:close()
end

	function area_index_end(name, line, wildcards)
		SetVariable("mcvar_area_range", serialize.save_simple(area_range_index))
		InfoNote("\n*** Area levels indexed!")
		Execute("xset resume page size")
		DoAfterSpecial(0.1, "cp info", sendto.execute)
	end

--	[[ Guess mob keywords ]]
	local gmkw_omit = {	["a"] = "",	["an"] = "", ["and"] = "", ["of"] = "", ["or"] = "", ["some"] = "", ["the"] = "" }
	local gmkw_area_filters = {
		["adaldar"]		= { { f= "^.*(el)vish (%a*%s?%a+)$",			g="%1 %2" 	}, },

		["bonds"]		= { { f= "^(.*[bgry]%a+) dragon$",				g="%1"		}, },

		["citadel"]   	= {	{ f= "^([bgjlmsv]%a+) ([ap]r%a+[el]) .+$",	g="%1 %2"	}, },

		["elemental"]   = {	{ f= "^(%a+)%'(%a+) (%a+)$",				g="%1%2 %3"	},
							{ f= "^wandering (%a+)%'(%a+) (%a+)$",		g="%1%2 %3"	}, },

		["hatchling"] 	= {	{ f= "^(%a+) dragon (egg)$", 				g="%1 %2"	},
							{ f= "^(%a+) dragon (hatchling)$", 			g="%1 %2"	},
							{ f= "^(%a+ %a+) dragon whelp$", 			g="%1"		},
							{ f= "^(%a+) dragon (whelp)$", 				g="%1 %2"	}, },

		["sirens"] 		= {	{ f= "^miss ([%a']+)%s?(%a*).*%a$", 		g="%1 %2"	}, },

		["sohtwo"]		= { { f= "^(evil) %a+",							g="%1"		},
							{ f= "^(good) %a+",							g="%1"		}, },

		["verume"]		= {	{ f= "^lizardman (temple %a+)$", 			g="%1"		}, },

		["wooble"]		= {	{ f= "^sea (%a+)$", 						g="%1"		},
							{ f= "^sea (%a+ %a+)$", 					g="%1"		}, }, }

	local gmkw_exceptions = {
		["aardington"]	= { ["a very large portrait"]				= { kw="large port"			}, },

		["alehouse"]		= { ["a dancing male patron"]				= { kw="dancing male"		},
								["a dancing female patron"]				= { kw="dancing female"		},},

		["anthrox"]		= { ["the little white rabbit"]				= { kw="rabb"				},
							["the bee"]								= { kw="worker bee"			},
							["an escaped creature"]					= { kw="prisoner creature"	},
							['a "business" man']					= { kw="business man"	},},

		["ddoom"]		= { ["a dangerous scorpion"]				= { kw="scorp"				},
							["Lwji, the Sunrise great warrior"]		= { kw="lwji"				},
							["Taji, the Sunset leader"]				= { kw="taji lead"			},
							["Taji's personal advisor"]				= { kw="pers advi"			},
							["Tjac, the Sunrise leader"]			= { kw="tjac lead"			},
							["Tjac's personal advisor"]				= { kw="sunr advis"			},
							["Yki, the great Sunset warrior"]		= { kw="yki"				}, },

		["deneria"]		= { ["High Priest of Miad'Bir"] 			= { kw="high miad" 			}, },

		["desert"]		= { ["a village citizen"] 					= { kw="citi" 				}, },

		["fields"]		= { ["a mutated goat"] 						= { kw="goat" 				}, },

		["fortress"]	= { ["a grizzled goblin dressed in skins"]	= { kw="grizz gobl"		 	},
							["Blood Silk, Collector of souls, Queen of the spiders"] = { kw="silk queen" }, },

		["hell"]		= { ["a scrumptious chicken pot pie"] 		= { kw="chicken pot pie"	},
							["a yummy vegetable pot pie"] 			= { kw="vegetable pot pie"	},
							["a yummy beef pot pie"] 				= { kw="beef pot pie"		}, },

		["illoria"]		= { ["the King and Queen's Guard"]			= { kw="pers guard"			}, },

		["landofoz"]	= { ["one of Dorothy's uncles"] 			= { kw="doroth uncle"		}, },

		["laym"]		= { ["an elite guard of the church"]		= { kw="elit guar"			}, },

		["livingmine"]	= { ["a member of the 'Cal tribe"]			= { kw="memb cal"			},
							["a member of the 'Sorr tribe"]			= { kw="memb sorr"			},
							["a member of the 'Tai tribe"]			= { kw="memb tai"			},
							["Dak'tai's shaman"]					= { kw="dakt shama"			},
							["the 'Tai chieftain"]					= { kw="tai chief"			}, },

		["longnight"]	= { ["Mr. Roberge"]							= { kw="car rober"			}, },

		["losttime"]	= { ["T-Rex"]								= { kw="T-rex"				},
							["Great White Shark"]					= { kw="white shark"				}, },

		["manor"]		= { ["Aremata-Popua"] 						= { kw="aremata-pop"	 	},
							["Aremata-Rorua"] 						= { kw="aremata-ror" 		}, },

		["masq"]		= { ["a gentleman on the way to the ball"]	= { kw="gentl"				},
							["a very attractive woman"]				= { kw="attr woman"			}, },

		["necro"] 		= { ["the head necromancer's assistant"]	= { kw="old mage assist" 	}, },

		["northstar"]	= { ["a Blood Ring elite warrior"]			= { kw="elit warr"			},
							["Daryoon, a priest of nature"]			= { kw="dary pries"			},
							["Tristam, the Prince of the Orcs"]		= { kw="trist orc"			}, },

		["sanctity"]	= { ["a half-converted human"]				= { kw="human"				}, },

		["siege"]		= { ["a kobold eating lunch"]				= { kw="kobold eating"		},
							["a large mole"]						= { kw="mole"				},
							["a very large firefly"]				= { kw="larg firef"			},
							["the fattest kobold ever"]				= { kw="fat kobold"			},
							["an oddly tall and clean kobold"]		= { kw="tall kobold"			}, },

		["snuckles"]	= { ["the snuckle"]							= { kw="male snuckle"		}, },

		["sohtwo"]      = { ["An evil form of Sagen"]               = { kw="notcarlsagen"        },
							["Angelic Demonspawn"]                  = { kw="angelic"             },
							["Bubbly Obyron"]                       = { kw="fuzzybunny"          },
							["Dejected Broud"]                      = { kw="dejected"            },
							["Disagreeable Rumour"]                 = { kw="obstinate"           },
							["Disoriented Dadrake"]                 = { kw="letsturnlefthere"    },
							["Evil Aaeron"] 	                    = { kw="shinythings"         },
							["Evil Althalus"]                       = { kw="homeskillet"         },
							["Evil Belmont"]                        = { kw="bridgetroll"         },
							["Evil Domain"]                         = { kw="66"                  },
							["Evil Euphonix"]                       = { kw="ragbrai"             },
							["Evil Ghaan"]                          = { kw="longghaan"           },
							["Evil Halo"]                           = { kw="jackandcoke"         },
							["Evil Ikyu"]                           = { kw="ickypoo"             },
							["Evil Justme"]                         = { kw="helperisme"          },
							["Evil Kharpern"]                       = { kw="kittyimm"            },
							["Evil KlauWaard"]                      = { kw="tricksy"             },
							["Evil Kt"]                             = { kw="ktkat"               },
							["Evil Lasher"]                         = { kw="thearchitect"        },
							["Evil Madcatz"]                        = { kw="mathizard"           },
							["Evil Maerchyng"]                      = { kw="maerchyng"           },
							["Evil Morrigu"]                        = { kw="morrigu"             },
							["Evil OrcWarrior"]                     = { kw="sheepshagger"        },
							["Evil Pane"]                           = { kw="painintheneck"       },
							["Evil Plaideleon"]                     = { kw="crazycanadian"       },
							["Evil Rekhart"]                        = { kw="hartsawreck"         },
							["Evil Sarlock"]                        = { kw="l33td00d"            },
							["Evil Tela"]                           = { kw="telllllllla"         },
							["Evil Timeghost"]                      = { kw="floppyimm"           },
							["Good Tripitaka"]                      = { kw="laketripitaka"       },
							["Evil Tymme"]                          = { kw="hourglass"           },
							["Evil Vladia"]                         = { kw="sexyvamp"            },
							["Evil Whitdjinn"]                      = { kw="thundercat"          },
							["Evil Windjammer"]                     = { kw="justsomeimm"         },
							["Evil Wolfe"]                          = { kw="likeobybutbritish"   },
							["Evil Xyzzy"]                          = { kw="weirdcode"           },
							["Good Aerianne"]                       = { kw="pointyears"          },
							["Good Cadaver"]                        = { kw="newbiehater"         },
							["Good Delight"]                        = { kw="turkishdelight"       },
							["Good Dirtworm"]                       = { kw="wormy"                },
							["Good Eclaboussure"]                   = { kw="dropbearimm"          },
							["Good Filt"]                           = { kw="plainolefilt"         },
							["Good Glimmer"]                        = { kw="betterhalfofclaire"   },
							["Good Kinson"]                         = { kw="upgradeboy"           },
							["Good Lumina"]                         = { kw="thievesrus"           },
							["Good Oladon"]                         = { kw="spellingbee"          },
							["Good Rhuli"]                          = { kw="rulistheworld"        },
							["Good Sausage"]                        = { kw="fatbreakfast"         },
							["Good Sirene"]                         = { kw="warriorprincess"      },
							["Good Takihisis"]                      = { kw="dragonlady"           },
							["Good Terrill"]                        = { kw="askcitron"            },
							["Good Tyanon"]                         = { kw="tieoneon"             },
							["Good Valkur"]                         = { kw="demonlord"            },
							["Good Vilgan"]                         = { kw="unabridged"           },
							["Good Xantcha"]                        = { kw="pokerimm"             },
							["Good Zane"]                           = { kw="inzanity"             },
							["Goodie Goodie Jaenelle"]              = { kw="goodie"               },
							["Impatient Styliann"]                  = { kw="willyouhurryup"       },
							["Kinda-Sorta Good Whisper"]            = { kw="kinda"                },
							["Master Shen"]                         = { kw="master"               },
							["Mathematical Mordist"]                = { kw="complex"              },
							["Nascaard Rezit"]                      = { kw="nascaard"             },
							["Pandemonium Penthesilea"]             = { kw="pandemonium"          },
							["Record Holding Guinness"]             = { kw="cantwriteatall"       },
							["Singing Paramore"]                    = { kw="failedmusician"       },
							["Sith Lord Neeper"]                    = { kw="sith"                 },
							["Smurfy Laren"]                        = { kw="lovethemsmurfs"       },
							["Sober Citron"]                        = { kw="sober"                },
							["Socialite Arthon"]                    = { kw="airhead"              },
							["Straight Dreamfyre"]                  = { kw="straight"             },
							["The cool version of Xeno"]            = { kw="onex"                 },
							["The Pancake Flat"]                    = { kw="pancake"              },
							["Tjopping Quadrapus"]                  = { kw="tjopping"             },
							["Unhelpful Claire"]                    = { kw="cookies"              },
							["Unremarkable Korridel"]               = { kw="unremarkable"         },
							["Unrestrained Elvandar"]               = { kw="omgsheneverstopstalking"},
							["Warsnail Anaristos"]                  = { kw="warsnail"             },
							["Cuddlebear Koala"]                    = { kw="cuddlebear"           },
							["(Helper) Fenix"]                      = { kw="helper"               },},

		["snuckles"]	= {	["Sarah, the grieving snuckle"]			= { kw="sarah griev"		}, },

		["stone"]		= { ["a Citadel of Stone Cityguard"]		= { kw="cit guar"			,} },

		["talsa"]		= { ["a dwarven mercenary"]					= { kw="dwar merc"			}, },

		["wooble"]		= { ["the Sea Snake Master-at-Arms"] 		= { kw="snake mast" 		}, },

		["yarr"]		= {	["a pirate sorting the treasure"]		= { kw="pirat sort"			},
							["a pirate stealing some treasure"]		= { kw="pirat steal"		}, },

		["zoo"]			= { ["a black-footed pine marten"]			= { kw="pine marte"			}, }, }

	function populate_mob_keyword_table(db)
		local inserts = {}
		for area, mob_keywords in pairs(gmkw_exceptions) do
			for mob_name, keyword in pairs(mob_keywords) do
				local str = string.format("INSERT INTO mob_keyword_exceptions VALUES (%s,%s,%s);", fixsql(area), fixsql(mob_name), fixsql(keyword["kw"]))
				table.insert(inserts, str)
			end
		end
		execute_in_transaction(db, inserts)
		db:execute(table.concat(inserts, ""))
	end

	function set_mob_keyword(name, line, wildcards)
		local current_area = current_room.arid
		local area_list = {}
		local db = assert(sqlite3.open(mapper_db_file))
		local i
		local area
		local mob_name
		local keyword

		for row in db:nrows("SELECT uid FROM areas ORDER BY uid ASC") do
			area_list[row.uid] = row.uid
		end

		area = utils.choose("Area", "Please choose the mob's area.", area_list, current_area)
		if not area then return end

		function require_input(input)
			return #Trim(input) > 0
		end

		mob_name = utils.inputbox("Enter the mob's full name.\nFor example: a yummy beef pot pie", "Enter mob name", nil, nil, 0, {validate = require_input})
		if not mob_name then return end
		mob_name = Trim(mob_name)

		keyword = utils.inputbox(string.format("Enter the new keyword for '%s'.\nFor example: beef pie", mob_name), "Enter new keyword", nil, nil, 0, {validate = require_input})
		if not keyword then return end
		keyword = Trim(keyword)

		if save_mob_keyword_keyword(area, mob_name, keyword) then
			if full_mob_name == mob_name then
				short_mob_name = keyword
			end
			update_main_target_list_keyword(area, mob_name, keyword)
		end
	end

	function set_current_mob_keyword(name, line, wildcards)
		local keyword = Trim(wildcards.keyword)
		local area

		if has_target() then
			if is_quest_mob_targeted() then
				area = quest_target.arid
			elseif main_target_list[xcp_index] then
				area = main_target_list[xcp_index].arid
			end

			if not area then
				InfoNote("\nSearch and Destroy: Target's area could not be identified. Try visiting its area and trying again.")
				return
			end

			if save_mob_keyword_keyword(area, full_mob_name, keyword) then
				short_mob_name = keyword
				update_main_target_list_keyword(area, full_mob_name, keyword)
			end
		else
			InfoNote("\nSearch and Destroy: 'kw' has no target.  Use 'xcp' to select a target, or use 'xset kw' with no arguments.")
		end
	end

	function update_main_target_list_keyword(area, mob_name, keyword)
		for i, mobdesc in ipairs(main_target_list) do
			if area == mobdesc.arid and mob_name == mobdesc.mob then
				mobdesc.kw = keyword
			end
		end
	end

	function save_mob_keyword_keyword(area, mob_name, keyword)
		local found_area = false
		local query

		local db = assert(sqlite3.open(snd_db_file))
		query = string.format("INSERT OR REPLACE INTO mob_keyword_exceptions VALUES (%s,%s,%s);", fixsql(area), fixsql(mob_name), fixsql(keyword))
		db:exec(query)
		db:close_vm()

		InfoNote("Updated keyword for ", mob_name, " to ", keyword, " in area ", area .. "\n")
		return true
	end

	function gmkw(s, a)	-- guess mob keywords
		if not s then return "" end
		local ri = current_room
		local ar = a or ri.zone
		local guess

		local db = sqlite3.open(snd_db_file)
		query = string.format("SELECT keyword FROM mob_keyword_exceptions WHERE area_name = %s AND mob_name = %s LIMIT 1;", fixsql(ar), fixsql(s))
		for row in db:nrows(query) do
			guess = row.keyword
		end
		db:close_vm()

		if guess then
			DebugNote("Found custom keyword for '", s, "': ", guess)
			return guess
		end

		local omit = gmkw_omit
		local s1 = {}
		for w in string.gmatch(string.lower(s), "[^ ]+") do
			w = string.gsub(w, "%p%-", "")
			w = string.gsub(w, ",", "")
			w = string.gsub(w, "%.", "")
			w = string.gsub(w, "'s$", "")
			w = string.gsub(w, "[!?]+$", "")
			table.insert(s1, w)
		end

		local s2
		for i,v in ipairs (s1) do
			if omit[v] then
				-- do nothing
			else
				s2 = (s2 == nil) and v or s2 .. " " .. v
			end
		end

		local s3
		if gmkw_area_filters[ar] then
			for i,v in ipairs (gmkw_area_filters[ar]) do
				s3 = string.gsub(s2, v.f, v.g)
				if (s3 ~= s2) then
					break
				end
			end
		else
			s3 = s2
		end
		s3 = string.gsub(s3, "-", " ")

		local s4 = {}
		for w in string.gmatch(s3, "[^ ]+") do
			table.insert(s4, w)
		end
		local len1 = #(s4[1])
		local len2 = #(s4[#s4]) or 0
		if (#s4 > 1) then	-- mob name has multiple words
			local x,y = math.random(4,6), math.random(4,6)
			guess = string.sub(s4[1], 1, x) .. " " .. string.sub(s4[#s4], 1, y)
		elseif (#s4 == 1) then	-- mob name has one word
			local x = math.random(2 + round_banker(len1*0.5), len1)
			guess = string.sub(s4[1], 1, x)
		else										-- Sometimes all of the mob words get deleted, if so just use original input.  In theory, if we reached this step
			guess = s or "gmkw error in stage 4"  	-- then the input is non-nil and I've never seen it be "" ... so, if it errors it means Lua is propagating a nil
		end-- somehow or doing one of the other mickey mouse nonsense things that Lua likes to do.
		return guess
	end

--	[[ Detect campaign (or gquest) type - area or room ]]
	function area_room_type_check(list)
		local areaCount = 0
		local roomCount = 0
		local ar_rm
		for i,v in ipairs (list) do
			if areaNameXref[v.loc] then
				areaCount = areaCount + 1
			else
				roomCount = roomCount + 1
			end
		end
		if (areaCount >= roomCount) then
			ar_rm = "area"
		else
			ar_rm = "room"
		end
		return ar_rm
	end

--	[[ Quest target process ]]
	function xq_command()	-- enables 'xq' command (reload quest info)
		send_gmcp_packet("request quest")
	end

	function retarget_quest()
		if has_active_quest() then
			target_quest_mob(true)
			xg_draw_window()
		elseif quest_target.qstat == "3" then
			InfoNote("\nSearch and Destroy: You have already killed your quest target!\n")
		else
			InfoNote("\nSearch and Destroy: You are not on a quest.\n")
		end
	end

	function target_quest_mob(bool)	-- Re-targets your quest mob if you un-target it somehow (xcp, etc.)
		local qt = quest_target
		xcp_clear_target(true)
		qw_reset(false)
		if (qt.mob == "missing") and (qt.arid == nil) and (qt.areaName == nil) and (qt.room == nil) then
			qt.mob = GetVariable("mcvar_qt_mob")
			qt.arid = GetVariable("mcvar_qt_arid")
			qt.areaName = GetVariable("mcvar_qt_areaName")
			qt.room = GetVariable("mcvar_qt_mob")
			if (bool == true) then
				InfoNote("\n'Target quest mob' (xq) not done - the mob is currently dead, or you can't see it (check detects).")
				InfoNote("\n'The last known location, before it went missing, was:\n")
				InfoNote("mob : ", qt.mob.." ")
				InfoNote("area: ", qt.areaName .. " ("..qt.arid..")")
				InfoNote("room: ", qt.room)
			end
		else
			full_mob_name = qt.mob
			short_mob_name = gmkw(qt.mob, qt.arid)
			SetVariable("mcvar_qt_mob", qt.mob)
			SetVariable("mcvar_qt_arid", qt.arid)
			SetVariable("mcvar_qt_areaName", qt.areaName)
			SetVariable("mcvar_qt_room", qt.room)
			if (bool == true) then
				InfoNote("\nYour quest mob is: \n")
				InfoNote("mob : ", qt.mob.." ")
				InfoNote("area: ", qt.areaName .. " ("..qt.arid..")")
				InfoNote("room: ", qt.room)
			end
		end
		search_rooms(string.format("%s|%s", qt.room, qt.arid), "area", qt.mob)
	end

	function quest_status_gmcp(q)	-- sets quest status when you take a new quest, kill qmob, complete quest, etc.
		if (q.action == "start") then									-- you've just taken a new quest
			quest_target = { qstat = "2", mob = q.targ,	areaName = q.area, arid = areaNameXref[q.area], room = (string.gsub(q.room, "@[bcgmrwyBCDGMRWY]", "")) }
			target_quest_mob(true)
		elseif (q.action == "status" and q.targ and q.timer) then		-- on quest, qmob not yet killed
			quest_target = { qstat="2", mob = q.targ, areaName = q.area, arid = areaNameXref[q.area], room = (string.gsub(q.room, "@[bcgmrwyBCDGMRWY]", "")) }
			target_quest_mob(true)
		else
			if (q.action == "killed") then	-- you've just killed the target
				quest_target.qstat = "3"
			--elseif (q.action == "start") then	-- you've just taken a new quest
			--	quest_target = { qstat = "2", mob = q.targ,	areaName = q.area, arid = areaNameXref[q.area], room = (string.gsub(q.room, "@[bcgmrwyBCDGMRWY]", "")) }
			--	target_quest_mob(true)
			elseif (q.action == "comp") or (q.action == "fail") or (q.action == "reset") then -- quest has ended (completed, failed, or reset)
				quest_target = { qstat="1"}
				xcp_clear_target(false)
				qw_reset(false)
			elseif (q.action == "ready") or (q.action == "timeout") then -- can take new quest immediately
				quest_target = { qstat="0"}

			-- in all of these, the action is "status"
			elseif (q.action == "status" and q.target == "killed") then		-- on quest, qmob has been killed (do not confuse q.target with q.targ above!)
				quest_target.qstat = "3"
				InfoNote("\nSearch and Destroy: You have already killed your quest target!\n")
			--elseif (q.action == "status" and q.targ and q.timer) then		-- on quest, qmob not yet killed
			--	quest_target = { qstat="2", mob = q.targ, areaName = q.area, arid = areaNameXref[q.area], room = (string.gsub(q.room, "@[bcgmrwyBCDGMRWY]", "")) }
			--	target_quest_mob(true)
			elseif (q.action == "status" and (q.wait)) then					-- off quest, must wait before requesting new
				quest_target = { qstat="1"}
				InfoNote("\nSearch and Destroy: Not on quest - must wait before requesting new.\n")
			elseif (q.action == "status" and q.status == "ready") then		-- off quest, can request new quest immediately
				quest_target = { qstat="0"}
				InfoNote("\nSearch and Destroy: Not on quest - can request new quest immediately. \n")
			end
			SetVariable("mcvar_qt_mob", "")
			SetVariable("mcvar_qt_arid", "")
			SetVariable("mcvar_qt_areaName", "")
			SetVariable("mcvar_qt_room", "")
		end
		xg_draw_window()
	end

--	[[ "cp info" process path ]]
	function do_cp_info()
		cp_info_list = {}
		main_target_list = {}
		room_targets_ignored = {}
		xcp_index = 0
		EnableTrigger("trg_cp_info_level_taken", true)
		EnableTrigger("trg_cp_info_targets", true)
		SendNoEcho("cp info")
		xg_draw_window()	-- redraw window during latency period between sending the command and receiving a response, which would otherwise be 'dead' time.
	end

	function cp_info_level_taken(name, line, wildcards)
		local x = tonumber(wildcards.level)
		cp_info_level = x
		SetVariable("mcvar_cp_level_taken", x)
	end

	function cp_info_line(name, line, wildcards)
		local t = cp_info_list
		local mob = wildcards.mob
		local loc = wildcards.loc
		local ord = #t+1
		table.insert(t, { mob=mob, loc=loc, ord=ord } )
	end

	function cp_info_end()
		player_on_cp = "yes"
		current_activity = "cp"
		local t = cp_info_list
		area_room_type = area_room_type_check(t)
		print("cp type detection: ".. area_room_type .." (level "..cp_info_level..")\n")
		xg_draw_window()
		DoAfterSpecial(0.1, [[ do_cp_check() ]], sendto.script)
	end

--	[[ "cp check" process path ]]
	function do_cp_check()
		local time_check = os.clock()					-- prevent double cp checks from different plugins
		if ((time_check - last_cp_check) < 1.0) then
			return
		end
		last_cp_check = time_check
		cp_check_list = {}
		EnableTrigger("trg_cp_check_line", true)
		SendNoEcho("cp ch")
	end

	function cp_check_line(name, line, wildcards)
		local t = cp_check_list
		local mob = wildcards.mob
		local qty = 1
		local kw = ""
		local loc = wildcards.loc
		local is_dead = ((wildcards.isdead == "") and "no" or "yes")
		local ord = #t + 1
		table.insert(t, { mob=mob, qty=qty, loc=loc, is_dead=is_dead, ord=ord })
	end

	function cp_check_end(name, line, wildcards)
		player_on_cp = "yes"
		current_activity = "cp"
		build_main_target_list("cp", area_room_type)
		xcp_retry()
	end

--	[[ general cp status functions ]]
	function player_start_new_cp()	-- called by line "good luck on your campaign" when starting new cp
		player_on_cp = "yes"
		can_get_new_cp = "no"
		local x = tonumber(gmcp("char.status.level"))
		cp_info_level = x
		current_activity = "cp"
		xg_draw_window()
		if (noexp_onoff == "on") and (anex_tnl_cutoff > 0) then
			InfoNote("Search and Destroy: Turning 'noexp' OFF (you have started a new CP)")
			anex_set_noexp("off")
		end
		do_cp_info()
	end

	function cp_mob_killed()
		if (player_on_gq == "no") then
			xcp_retry_stat = 1
			qw_reset(false)
			last_kill_index = get_last_kill_index()
			if main_target_list[last_kill_index] then
				main_target_list[last_kill_index].is_dead = "yes"
			end
			xcp_clear_target(true)
			DoAfterSpecial(0.1, "do_cp_check()", 12)
		end
	end

	function get_last_kill_index()
		if xcp_index > 0 and last_mob_killed == main_target_list[xcp_index].mob then
			DebugNote("killed mob is xcp index mob")
			return xcp_index
		else
			for i, target in ipairs(main_target_list) do
				DebugNote("comparing ", last_mob_killed, " (", current_room.arid, ") to ", target.mob, " (",  target.arid, ")")
				if current_room.arid == target.arid and last_mob_killed == target.mob then
					DebugNote("killed mob is number ", i)
					return i
				end
			end
			DebugNote("killed mob DEFAULTING to xcp mob")
			return xcp_index
		end
	end

	function player_level_up()
		can_get_new_cp = "yes"
		xg_draw_window()
	end

	function player_is_on_cp()
		player_on_cp = "yes"
	end

	function do_cp_complete(name, line, wildcards)
		player_not_on_cp()
	end

	function player_not_on_cp()
		player_on_cp = "no"
		EnableTriggerGroup ("trg_campaign", false)
		cp_info_level = "0"
			SetVariable("mcvar_cp_level_taken", "0")
		cp_info_list = {}
		cp_check_list = {}
		if (player_on_gq == "yes") then
			-- do nothing, we don't want to clear our gq info
		else
			main_target_list = {}
			room_targets_ignored = {}
			area_room_type = "none"
			current_activity = "none"
			xcp_index = 0
			xg_draw_window()
		end
	end

	function cp_check_can_get_new_cp()
		can_get_new_cp = "yes"
		anex_can_get_new_cp()
		xg_draw_window()
	end

	function cp_check_cannot_get_new_cp()
		can_get_new_cp = "no"
		anex_must_level_new_cp()
		xg_draw_window()
	end

	function can_player_get_new_cp()
		return (can_get_new_cp == "yes") and true or false
	end

--	[[ Gquest beginning event messages: declare, join, start ]]
	function gqmsg_declared(name, line, wildcards)
		gqid_declared = wildcards.gq_id
			SetVariable("mcvar_gqid_declared", gqid_declared)
		gqid_joined = "-1"
			SetVariable("mcvar_gqid_joined", "-1")
		gqid_started = "-1"
			SetVariable("mcvar_gqid_started", "-1")
		gqid_extended = "-1"
			SetVariable("mcvar_gqid_extended", "-1")
	end

	function gqmsg_joined(name, line, wildcards)
		gqid_joined = wildcards.gq_id
		SetVariable("mcvar_gqid_joined", gqid_joined)
		if (gqid_joined == gqid_started) then
			EnableTriggerGroup("trg_gqmsg_2", true)
			do_gq_info()
		end
	end

	function gqmsg_started(name, line, wildcards)
		gqid_started = wildcards.gq_id
		SetVariable("mcvar_gqid_started", gqid_started)
		if (gqid_started == gqid_joined) then
			EnableTriggerGroup("trg_gqmsg_2", true)
			do_gq_info()
		end
	end

--	[[ Gquest info functions ]]
	function do_gq_info()
		if (gqid_joined ~= "-1") then
			xcp_clear_target(false)
			main_target_list = {}
			room_targets_ignored = {}
			gq_info_list = {}
			EnableTrigger("trg_gq_info_quest_name", true)
			SendNoEcho("gq info " .. gqid_joined)
			--DoAfterSpecial(0.1, [[ Send("gq info .. ]] .. gqid_joined .. [[")]], sendto.script)
		else
			print("\ndo_gq_info: You haven't joined a gquest.")
		end
	end

	function gq_info_quest_name(name, line, wildcards)
		local gqid = wildcards.gq_id
		if (gqid == gqid_joined) then
			EnableTrigger("trg_gq_info_quest_status", true)
			player_is_on_gq()
		elseif gqCheckPass then
			gqid_joined = gqid
			gqCheckPass = false
			EnableTrigger("trg_gq_info_quest_status")
			player_is_on_gq()
		else
			print("gq info name fail")
		end
	end

	function gq_info_quest_status(name, line, wildcards)
		local status = wildcards.status
		if (status == "Active") or (status == "Extended") then
			EnableTrigger("trg_gq_info_level_range", true)
		end
	end

	function gq_info_level_range(name, line, wildcards)
		local min = tonumber(wildcards.minlvl)
		local max = tonumber(wildcards.maxlvl)
		local eff = math.floor((min + max) / 2)
		gq_info_minlvl = min
			SetVariable("mcvar_gq_info_minlvl", min)
		gq_info_maxlvl = max
			SetVariable("mcvar_gq_info_maxlvl", max)
		gq_info_efflvl = eff
			SetVariable("mcvar_gq_info_efflvl", eff)
	end

	function gq_info_line(name, line, wildcards)
		local t = gq_info_list
		local mob = wildcards.mob
		local qty = wildcards.qty
		local loc = wildcards.loc
		local ord = #t+1
		table.insert(t, { mob=mob, qty=qty, loc=loc, ord=ord } )
	end

	function gq_info_end()
		player_is_on_gq()	-- more redundancy.  gq's are a pain
		area_room_type = area_room_type_check(gq_info_list)
		cp_info_level = tonumber(gmcp("char.status.level"))	-- room target builder will crash without a sensible value here.  Just use current player level.
		print("gq type detection: " .. area_room_type .. " (level " .. cp_info_level .. ")\n")
		xg_draw_window()
		DoAfterSpecial(0.1, "do_gq_check()", sendto.script)
	end

--	[[ Gquest check functions ]]
	function do_gq_check()
		player_is_on_gq()
		local time_check = os.clock()					-- prevent double cp checks from different plugins
		if ((time_check - last_cp_check) < 1.0) then
			return
		end
		last_gq_check = time_check
		gq_check_list = {}
		EnableTrigger("trg_gq_check_line", true)
		DoAfterSpecial(0.1, 'SendNoEcho("gq ch")', sendto.script)
	end

	function gq_check_line(name, line, wildcards)
		local t = gq_check_list
		local mob = wildcards.mob
		local qty = wildcards.qty
		local loc = wildcards.loc
		local is_dead = (wildcards.isdead == "" and "no" or "yes")
		local ord = #t+1
		table.insert(t, { mob=mob, qty=qty, loc=loc, is_dead=is_dead, ord=ord })
	end

	function gq_check_end()
		player_is_on_gq()
		build_main_target_list("gq", area_room_type)
		xcp_retry()
	end

	function xcp_retry()
		-- About xcp_retry_stat:
		-- after killing gq mob, it's possible to 'xcp' after tables are cleared,
		-- but before they're refreshed, which would cause 'xcp' to fail with the
		-- message "no data yet".  Instead, gq_mob_killed sets a flag that does
		-- two things: 1) tells 'xcp' to silently abort, 2) tells gq_check_end to
		-- do 'xcp' again (with or without arg), which works normally now that
		-- table data is available.
		if (xcp_retry_stat == 2) then
			xcp_index = xcp_index_attempt
			if last_kill_index < xcp_index_attempt then
				xcp_index = math.max(1, xcp_index_attempt - 1)
			end
			xcp_retry_stat = 0
			xcp_arg("", "", {index=xcp_index})
		end
		xcp_retry_stat = 0
	end

--	[[ Gquest general status functions ]]
	function gq_mob_killed()
		if main_target_list[xcp_index] then
			local x = tonumber(main_target_list[xcp_index].qty) - 1
			main_target_list[xcp_index].qty = x
			if (#main_target_list > 1) then
				if x and (x > 0) then
					xg_draw_window()
					print_target_links(main_target_list)
				else
					qw_reset(false)
					xcp_retry_stat = 1
					last_kill_index = get_last_kill_index()
					if main_target_list[last_kill_index] then
						main_target_list[last_kill_index].is_dead = "yes"
					end
					xcp_clear_target(true)
					DoAfterSpecial(0.1, "do_gq_check()", 12)
				end
			elseif (#main_target_list == 1) then
				if x and (x > 0) then
					xg_draw_window()
					print_target_links(main_target_list)
				else
					qw_reset(false)
					xcp_clear_target(false)
				end
			end
		else
			qw_reset(false)
			xcp_retry_stat = 1
			xcp_clear_target(false)
			DoAfterSpecial(0.1, "do_gq_check()", 12)
		end
	end

	function gqmsg_winner(name, line, wildcards)
		local gqid = wildcards.gq_id
		local winner = wildcards.winner
		local you = gmcp("char.base.name")
		if (winner == you) then
			ColourNote("#FFFFFF", "", "\nA WINNER IS YOU\n")
			player_not_on_gq()
		elseif (gqid == gqid_joined) then
			EnableTrigger("trg_gqmsg_extended_time", true)
			DoAfterSpecial(0.5, "gq_check_if_extended()", sendto.script)
		else
			-- do nothing, message is for a different gq.
		end
	end

	function gqmsg_extended_time(name, line, wildcards)
		local gqid = wildcards.gq_id
		if (gqid == gqid_joined) then
			gqid_extended = gqid
		end
	end

	function gq_check_if_extended()
		EnableTrigger("trg_gqmsg_extended_time", false)
		if (gqid_extended ~= gqid_joined) then
			player_not_on_gq()
		end
	end

	function gq_check_not_yet_started(name, line, wildcards)
		gqid_joined = wildcards[1]
		player_is_on_gq()
		gqid_started = "-1"
			SetVariable("mcvar_gqid_started", "-1")
	end

	function player_is_on_gq()
		player_on_gq = "yes"
		current_activity = "gq"
	end

	function gq_ended(name, line, wildcards)
		if gq_id_joined == wildcards.gq_id then
			player_not_on_gq()
		end
	end

	function player_not_on_gq()
		EnableTriggerGroup("trg_gq", false)
		EnableTriggerGroup("trg_gqmsg_2", false)
		EnableTrigger("trg_gqmsg_extended_time", false)
		player_on_gq = "no"
		area_room_type = "none"
		current_activity = "none"
		gq_info_list = {}
		gq_check_list = {}
		main_target_list = {}
		room_targets_ignored = {}

		gqid_joined = "-1"
			SetVariable("mcvar_gqid_joined", gqid_joined)
		gqid_started = "-1"
			SetVariable("mcvar_gqid_started", gqid_started)
		gqid_extended = "-1"
			SetVariable("mcvar_gqid_extended", gqid_extended)

		gq_info_minlvl = "-1"
			SetVariable("mcvar_gq_info_minlvl", gq_info_minlvl)
		gq_info_maxlvl = "-1"
			SetVariable("mcvar_gq_info_maxlvl", gq_info_maxlvl)

		xcp_clear_target(true)

		if (player_on_cp == "yes") then
			DoAfterSpecial(0.4, [[ InfoNote("Reloading your cp targets....")
								do_cp_info() ]], sendto.script)
		end
	end

--	[[ Build main target list process path ]]
	function build_main_target_list(cp_or_gq, area_or_room)
		local cp_gq = cp_or_gq
		local ar_rm = area_or_room

		local sqla = " SELECT uid as arid, name as areaName " .. "FROM areas " .. "WHERE name = %s " .. "ORDER BY arid ASC "
		local sqlr = " SELECT r.uid as roomid, r.name as roomName, a.uid as arid, a.name as areaName, 'room' as link_type " .. "FROM rooms r " .. "INNER JOIN areas a ON r.area = a.uid " .. "WHERE r.name = %s " .. "ORDER BY arid ASC "
		if (ar_rm == "area") then
			main_target_list = build_area_targets(cp_gq, sqla)
		elseif (ar_rm == "room") then
			main_target_list, room_targets_ignored = build_room_targets(cp_gq, sqlr, sqla)
		elseif (ar_rm == "none") then	-- should never be called but who knows
			print("main_target_list build error - tried to run while on " .. cp_gq .. " but area/room type is 'none'.")
		end
		xg_draw_window()
		print_target_links(main_target_list)
	end

	function color_for_target(target, targeted)
		if targeted then
			return text_colors.targeted
		elseif target.unlikely then
			return text_colors.unlikely
		elseif target.is_dead == "yes" and target.link_type == "unknown" then
			return text_colors.unknown_dead
		elseif target.is_dead == "yes" then
			return text_colors.dead
		elseif target.link_type == "unknown" then
			return text_colors.unknown
		else
			return text_colors.normal
		end
	end

	function build_area_targets(cp_gq, sqla)
		local t, list = {}, {}
		if (cp_gq == "cp") then
			list = cp_check_list
		elseif (cp_gq == "gq") then
			list = gq_check_list
		end
		local db = assert(sqlite3.open(mapper_db_file))
		for i,v in ipairs (list) do
			local dead = v.is_dead
			local results_found = false
			local select = string.format(sqla, fixsql(v.loc))
			for row in db:nrows(select) do
				results_found = true
				table.insert(t,
				{	mob = v.mob,
					arid = row.arid,
					qty = v.qty,
					is_dead = dead,
					link_type = "area",
					index = #t+1,
					ord = v.ord } )
			end
			if (results_found == false) then
				table.insert(t,
				{	mob = v.mob,
					location = v.loc,
					arid = "-1",
					qty = v.qty,
					is_dead = dead,
					link_type = "unknown",
					index = #t+1,
					ord = v.ord,
					unknown = true, } )
			end
		end
		db:close_vm()
		for i,v in ipairs (t) do
			v.kw = gmkw(v.mob, v.arid)
		end
		return t
	end

	function build_room_targets(cp_gq, sqlr, sqla)
		local ig, list = {}, {}
		local low_chance = {}
		local high_chance = {}
		local level_taken
		if (cp_gq == "cp") then
			list = cp_check_list
			level_taken = tonumber(cp_info_level)
		elseif (cp_gq == "gq") then
			list = gq_check_list
			level_taken = tonumber(gq_info_efflvl)
		end
		local db = assert(sqlite3.open(mapper_db_file))
		local SnDdb = assert(sqlite3.open(snd_db_file))
		local area_sorter = function(a, b)
			if a.arid == "-1" then
				return false
			elseif b.arid == "-1" then
				return true
			else
				return a.arid < b.arid
			end
		end

		for i,v in ipairs (list) do
			local possibilities = {}
			local dead = v.is_dead
			local lt -- link type (area, room, unknown)
			local areas_sql = {}
			if (dead == "yes") then
				lt = "area"
			else
				lt = "room"
			end
			local results_found = false
			local select = string.format(sqlr, fixsql(v.loc))
			local last_mob_sig = ""
			for row in db:nrows(select) do			-- if not row then / print("error - room db search returned no rows") / elseif not row.areaName then / print("area name missing from row") / end
				if (area_range_index[row.areaName]) then	-- don't include areas that never contain quest mobs
					results_found = true
					local mob_sig = row.arid .. "|" .. v.mob
					if (mob_sig ~= last_mob_sig) then
						last_mob_sig = mob_sig
						local area_min_lvl = (area_range_index[row.areaName].min) or 1
						local area_max_lvl = (area_range_index[row.areaName].max) or 300
						if (level_taken >= area_min_lvl) and (level_taken <= (area_max_lvl+25)) then	-- limit results to sensible level range.
							table.insert(areas_sql, fixsql(row.arid))
							table.insert(possibilities, {
								mob = v.mob,
								arid = row.arid,
								roomid = row.roomid,
								roomName = row.roomName,
								qty = v.qty,
								is_dead = dead,--v.is_dead,
								minlvl = area_min_lvl,
								maxlvl = area_max_lvl,
								link_type = lt,	--((v.is_dead == false) and "room" or "area"),	-- deals with dead mobs when area contains roomnames same as area name e.g. Aardington Estate
								ord = v.ord } )
						else
							table.insert(ig, {	-- build table of search results for areas out of your level range.
								mob = v.mob,	-- Usually invalid, but valid links can wind up here if area's level range is too broad, or wrong.
								arid = row.arid,
								roomid = row.roomid,
								roomName = row.roomName,
								qty = v.qty,
								is_dead = dead,
								minlvl = area_min_lvl,
								maxlvl = area_max_lvl,
								link_type = "ignored",
								ord = v.ord } )
						end
					end
				end
			end
			if results_found then
				-- When more than one possible area is found, check if you've seen the mob in that room in any of the areas
				-- if never seen in any of the rooms, check if you've seen them anywhere in the areas
				if #possibilities > 1 then
					local mobs_by_room_query = string.format("SELECT sum(count) as count, zone FROM mobs WHERE mob = %s AND room = %s AND zone IN (%s);",
						fixsql(v.mob), fixsql(v.loc), table.concat(areas_sql, ","))
					local mob_found = false
					for row in SnDdb:nrows(mobs_by_room_query) do
						for i, possibility in ipairs(possibilities) do
							if possibility.arid == row.zone then
								mob_found = true
								possibility.found = true
								break
							end
						end
					end

					if not mob_found then
						local mobs_by_area_query = string.format("SELECT sum(count) as count, zone FROM mobs WHERE mob = %s AND zone IN (%s);",
							fixsql(v.mob), table.concat(areas_sql, ","))
						for row in SnDdb:nrows(mobs_by_room_query) do
							for i, possibility in ipairs(possibilities) do
								if possibility.arid == row.zone then
									mob_found = true
									possibility.found = true
									break
								end
							end
						end
					end

					table.sort(possibilities, area_sorter)
					if mob_found then
						local temp_high = {}
						local temp_low = {}
						for i, possibility in ipairs(possibilities) do
							possibility.count_for_room = #possibilities
							if possibility.found then
								table.insert(temp_high, possibility)
							else
								possibility.unlikely = true
								table.insert(temp_low, possibility)
							end
						end
						for i, possibility in ipairs(temp_high) do
							possibility.room_index = i
							table.insert(high_chance, possibility)
						end

						for i, possibility in ipairs(temp_low) do
							possibility.room_index = i + #temp_high
							table.insert(low_chance, possibility)
						end
					else
						for i, possibility in ipairs(possibilities) do
							possibility.count_for_room = #possibilities
							possibility.room_index = i
							table.insert(high_chance, possibility)
						end
					end
				elseif #possibilities == 1 then
					table.insert(high_chance, possibilities[1])
				end
			else	-- no results were returned: either the mob is dead, or the location is unknown.
				if (dead == "yes") then	-- mob is dead
					local results_found = false
					local select = string.format(sqla, fixsql(v.loc))	-- dead mobs only give area name (even in room cp's) so search area info only.
					for dead_row in db:nrows(select) do	-- mob is dead, location is known
						results_found = true
						table.insert(high_chance, { mob=v.mob, arid=dead_row.arid, qty = v.qty, is_dead="yes", link_type="area", ord=v.ord } )
					end
					if (results_found == false) then	-- mob is dead, location is unknown
						table.insert(high_chance, { mob=v.mob, arid="-1", location=v.loc, qty = v.qty, is_dead="yes", link_type="unknown", ord=v.ord } )
					end
				else	-- mob is alive, but location is unknown
					table.insert(high_chance, { mob=v.mob, arid="-1", location=v.loc, qty = v.qty, is_dead="no", link_type="unknown", ord=v.ord } )
				end
			end
		end
		table.sort(ig, area_sorter)
		table.sort(high_chance, area_sorter)
		table.sort(low_chance, area_sorter)

		for i, v in ipairs(low_chance) do
			table.insert(high_chance, v)
		end

		db:close_vm()
		SnDdb:close_vm()
		for i,v in ipairs(high_chance) do
			v.kw = gmkw(v.mob, v.arid)
		end
		return high_chance, ig
	end

--	[[ Display target links in MUD window ]]
	function print_target_links(list)
		if (#room_targets_ignored > 0) then
			print_room_links_ignored()
		end
		if silentMode == "off" then
			if (#list > 0) then
				ColourNote("#808080", "", string.rep("-", 80))
				--[[if list[1].link_type == "room" then
					for _,v in ipairs(list) do
						if string.match(v.roomName, "^Hiding from") then
							v.arid = "zz" .. v.arid ]]--

				for i,v in ipairs (list) do
					local mob_text = string.format("%s%s",  ((v.is_dead == "no") and "" or "[D] "), v.mob)
					local arid = v.arid:sub(1, 10)
					local background = (i % 2) == 0 and text_colors.alternating_row or ""
					local link_text
					local tooltip = "Target cp mob " .. i .. " - " .. mob_text .. " (" .. v.arid .. ")"
					local notehelp = "Show notes for item " .. i
					local color = color_for_target(v)
					mob_text = ellipsify(mob_text, 32)
					if (v.link_type == "area") then
						link_text = string.format("%2d  %-32s - %-10s", i, mob_text, arid)
						Hyperlink("xcp " .. i, link_text, tooltip, color, background, 0, 1)
						Hyperlink("roomnote area " .. v.arid, string.format("  %-29s", "[notes]"), notehelp, ((v.is_dead == "yes") and "#006000" or "lightgreen"), background, 0, 1)
					elseif v.link_type == "room" and v.unlikely then
						ColourNameToRGB(text_colors.unlikely_tag)
						Hyperlink("xcp " .. i, string.format("%2d  ", i), tooltip, color, background, 0, 1)
						Hyperlink("xcp " .. i, "(U) ", tooltip, text_colors.unlikely_tag, background, 0, 1)
						mob_text = ellipsify(mob_text, 28)
						local roomText = string.format("'%s'", ellipsify(v.roomName, 27))
						link_text = string.format("%-28s - %-10s  %-29s", mob_text, v.arid, roomText)
						Hyperlink("xcp " .. i, link_text, tooltip, color, background, 0, 1)
					elseif v.link_type == "room" then
						local roomText = string.format("'%s'", ellipsify(v.roomName, 27))
						link_text = string.format("%2d  %-32s - %-10s  %-29s", i, mob_text, v.arid, roomText)
						Hyperlink("xcp " .. i, link_text, tooltip, color, background, 0, 1)
					elseif (v.link_type == "unknown") then
						local location = ellipsify(v.location, 30)
						link_text = string.format("%2d  %-32s - unknown: '%s'%s", i, mob_text, location, string.rep(" ", 30 - #location))
						tooltip = "Location not found in mapper database"
						Hyperlink(" ", link_text, tooltip, color, background, 0, 1)

					end
					print("")
				end
					ColourNote("#808080", "", string.rep("-", 80))
					ColourNote("#808080", "", "Type 'xcp <index>' or click link to go to that target.")
			else
				InfoNote("   No target items to show.")
			end
		end
	end

	function ellipsify(str, max_length)
		if #str <= max_length then
			return str
		else
			return str:sub(1, max_length - 1) .. "…"
		end
	end

	function print_room_links_ignored()
		local ig = room_targets_ignored
		ColourNote("#808080", "", string.rep("-", 80))
		for i,v in ipairs (ig) do
			local link = string.format(" ** Ignoring due to level: %s - '%s' (%s) [%s-%s]", v.mob, v.roomName, v.arid, v.minlvl, v.maxlvl)
			Hyperlink("xmapper move " .. v.roomid, link, "Move to room " .. v.roomid, "#002460", "", 0, 1)
			print("")
		end
	end


-- [[ "xcp" command ]]
	function xcp_noarg()	-- xcp with no argument given, so find the first available mob (alive, location known) and go to it.
		local t = main_target_list
		if xcp_targets_quest_onoff == "on" and has_active_quest() then
			target_quest_mob(true)
			xg_draw_window()
		elseif (area_room_type == "none") then	-- abort if not on cp
			InfoNote("\nSearch and Destroy: 'xcp' aborted - you're not on a cp.\n")
		elseif (#t == 0) then	-- abort if on a cp, but target list is empty
			InfoNote("\nSearch and Destroy: 'xcp' aborted - cp is active but target list is empty.\n")
		else
			for i,v in ipairs (t) do	-- loop through list and try to find something to kill.
				if (v.is_dead == "no") and (v.link_type == "area" or v.link_type == "room") then	-- if mob is alive and location known, go to it.
					xcp_index = i
					xg_draw_window()
					xcp_goto_target(i)
					break
				else
					local index = i + 1
					if (index > #t) then 	-- if we reach this step, all mobs are dead and/or unknown.
						InfoNote("\nSearch and Destroy: 'xcp' aborted - lack of targets (dead, or location unknown)")
					end
				end
			end
		end
	end

	function xcp_arg(name, line, wildcards)
		local index = tonumber(wildcards.index)
		local cp_list = main_target_list
		if (area_room_type == "none") then
			InfoNote("\nSearch and Destroy: 'xcp' aborted - you're not on a cp.\n")
		elseif (#cp_list == 0) then
			InfoNote("\nSearch and Destroy: 'xcp' aborted - cp is active but target list is empty.\n")
		elseif (index > #cp_list) or (index < 0) then	-- index doesn't exist
			InfoNote("\nSearch and Destroy: 'xcp' aborted - index doesn't exist (".. index .. ")\n")
		elseif (index == 0) then	-- clear xcp target
			xcp_clear_target(true)
			InfoNote("\nSearch and Destroy: 'xcp' current target cleared.\n")
		elseif (cp_list[index].link_type == "unknown") then -- or (cp_list[index].link_type == "unknown_room") then	-- abort if unknown
			InfoNote("\nSearch and Destroy: 'xcp' aborted - no mapper data for target (#" .. index .. ").\n")
		else	-- everything is in order, so go to mob.
			local ch_state = current_character_state
			if (ch_state == "3") then
				xcp_index = index
				xg_draw_window()
				xcp_goto_target(index)
			elseif (ch_state == "8") then
				InfoNote("\nNot while you're fighting!")
			elseif (ch_state == "12") then
				InfoNote("\nYou are already running!")
			end
		end
	end

	function xcp_goto_target(index)
		if (xcp_retry_stat == 0) then
			local t = main_target_list[index]
			local ri = current_room
			local action = xcp_action_mode
			gotoArea = -1
			gotoIndex = 1
			next_room = -1
			gotoList = {}
			if (t ~= nil) and (ri.rmid ~= nil) then
				full_mob_name = t.mob
				short_mob_name = t.kw
				if (t.link_type == "area") then	-- Area cp links - "xcp" goes to target area, then runs Hunt Trick to get target room.
					if (action == "qw") then
						local func = function() qw_exact(t.kw) end
						execute_in_area(t.arid, func)
					elseif (action == "ht") then		-- do hunt trick or quick where after arriving in area.
						local func = function() do_hunt_trick(1, t.kw) end
						execute_in_area(t.arid, func)
					elseif (action == "off") then	-- do nothing
						InfoNote("Xcp action is off - no additional action\n")
					end
					if (ri.arid ~= t.arid) then	-- if you're not in target area, xrunto target area.
						--Execute("xrt " .. t.arid)
						xrun_to(t.arid, true)
					end
				else	-- Room cp:  get target room from mapper, but don't move yet.  "go" takes you to room.
					search_rooms(t.roomName .. "|" .. t.arid, "area", t.mob)
				end
			else
				InfoNote("No item exists, or data is busy")
			end
		else
			xcp_index_attempt = index
			xcp_retry_stat = 2
		end
	end

	function xcp_clear_target(bool)
		short_mob_name = -1
		full_mob_name = -1
		xcp_index = 0
		gotoArea = -1
		gotoIndex = 0
		gotoList = {}
		if (bool == true) then
			xg_draw_window()
		end
	end

	function xcp_set_action_mode(name, line, wildcards)
			local opt = wildcards.option or ""
			local options = {
				["ht"] = "ht - do hunt trick",
				["qw"] = "qw - do quick where",
				["off"] = "off - no additional action",
				}
			if (opt == "ht") or (opt == "qw") or (opt == "off") then
				xcp_action_mode = opt
				SetVariable("mcvar_xcp_action_mode", opt)
				InfoNote("", "Set 'xcp' mode to: ", options[opt], ".")
			elseif (opt == "") then
				InfoNote("Current 'xcp' mode: " .. options[xcp_action_mode] .. ".")
				InfoNote("Syntax: 'xcp mode [ht|qw|off]'")
			else
				InfoNote("Invalid 'xcp' mode given.  Syntax: 'xcp mode [ht|qw|off]'")
			end
			print("")
	end

	function xcp_toggle_quest_targeting()
		if xcp_targets_quest_onoff == "on" then
			xcp_targets_quest_onoff = "off"
		else
			xcp_targets_quest_onoff = "on"
		end
		SetVariable("mcvar_xcp_targets_quest_onoff", xcp_targets_quest_onoff)

		InfoNote("\nxcp quest targeting is now ", string.upper(xcp_targets_quest_onoff))
	end

-- [[  Goto area (xrt), goto room (go), goto next (nx), goto previous (nx-) ]]
	local xrun_to_sql_uid =  "SELECT r.uid, r.name as room, r.area " .. "FROM rooms r " .. "WHERE r.area like %s " .. "ORDER BY r.name "
	local xrun_to_sql_name = "SELECT r.uid, r.name as room, r.area " .. "FROM rooms r " .. "INNER JOIN areas a ON a.uid = r.area " .. "WHERE r.area like %s OR a.name like %s " .. "ORDER BY r.name "

	function xrun_to_alias(name, line, wildcards)
		xrun_to(wildcards.destination, false)
	end

	function xrun_to(arid, exact)
		local ri = current_room
		if (arid == "ft2") then arid = "ftii" end
		local rmid = get_start_room(arid, exact)
		if (rmid == "-1") then		-- area has no start room defined.
			InfoNote("X-runto: No default start room is defined for area: " .. arid .. ".\n")
			SendNoEcho("areas 1 299 keywords " .. arid)
		else
			InfoNote("X-runto: " .. arid .. ", room ID: " .. rmid .. " (" .. start_room_type .. ")\n")
			goto_room_id(rmid, arid)
		end
	end

	function goto_room_id(rmid, arid)	-- go to specific room id (do not confuse with goto_number, see below)
		local ri = current_room
		local rmid = rmid
		local arid = arid or getAreaFromRoomId(rmid)
		if (is_vidblain_area(rmid) == true) then -- if target is in a vidblain area,
			if(is_vidblain_area(ri.rmid) == false) then	-- but if you are not
				vidblain_nav(rmid, arid)
			else
				do_mapper_goto(rmid, "walk")
			end
		else
			do_mapper_goto(rmid)
		end
	end

	function action_on_destination_arrived()
		if xset_nx_action == "smartscan" then
			smart_scan()
		elseif xset_nx_action == "con" then
			EnableTrigger("consider_end_empty", true)
			SendNoEcho("consider")
		elseif xset_nx_action == "scan" then
			SendNoEcho("scan")
		elseif xset_nx_action == "scanhere" then
			SendNoEcho("scan here")
		elseif xset_nx_action == "qs" then
			quick_scan()
		end
	end

	function goto_number(name, line, wildcards)
		local ch_state = current_character_state
		if (ch_state == "3") then
			gotoIndex = tonumber(wildcards.index) or 1
			if gotoList[gotoIndex] then
				if (tonumber(gotoList[gotoIndex]) == nil) then
					xrun_to(gotoList[gotoIndex], true)
					action_on_destination_arrived()
				else
					next_room = gotoList[gotoIndex]
					goto_room_id(gotoList[gotoIndex])
					action_on_destination_arrived()
				end
			else
				InfoNote("Goto room result (go) aborted - No destination yet.")
			end
		elseif (ch_state == "8") then
			InfoNote("\nNot while you're fighting!")
		elseif (ch_state == "12") then
			InfoNote("\nYou are already running!")
		else
			InfoNote("\nGoto room result (go):  Can't do that now - you must be standing and ready.")
		end
	end

	function goto_next(name, line, wildcards)
		local ch_state = current_character_state
		if (ch_state == "3") then
			if (next_room == nil) or (next_room == "") or (not tonumber(next_room)) then
				InfoNote("Goto next (nx) aborted - No data yet.")
			else
				if (tonumber(next_room) == tonumber(gmcp("room.info.num"))) and (gotoIndex < #gotoList) then
					gotoIndex = gotoIndex + 1
				end
				if gotoList[gotoIndex] then
					InfoNote("Next room (nx) - ", gotoIndex, " of ", #gotoList)
					next_room = gotoList[gotoIndex]
					do_mapper_goto(next_room)
					action_on_destination_arrived()
				else
					InfoNote("Goto next (nx) aborted - No more rooms.")
				end
			end
		elseif (ch_state == "8") then
			InfoNote("\nNot while you're fighting!")
		elseif (ch_state == "12") then
			InfoNote("\nYou are already running!")
		else
			InfoNote("\nGoto next room (nx):  Can't do that now - you must be standing and ready.")
		end
	end

	function goto_previous(name, line, wildcards)
		local ch_state = current_character_state
		if (ch_state == "3") then
			if (next_room == nil) or (next_room == "") or (not tonumber(next_room)) then
				InfoNote("Goto previous (nx-) aborted - No data yet.")
			else
				if (tonumber(next_room) == tonumber(gmcp("room.info.num"))) and (gotoIndex > 1) then
					gotoIndex = gotoIndex - 1
				end
				if gotoList[gotoIndex] then
					InfoNote("Previous room (nx-) - ", gotoIndex, " of ", #gotoList)
					next_room = gotoList[gotoIndex]
					do_mapper_goto(next_room)
					quick_scan()
				else
					InfoNote("Goto previous (nx-) aborted - No more rooms.")
				end
			end
		elseif (ch_state == "8") then
			InfoNote("\nNot while you're fighting!")
		elseif (ch_state == "12") then
			InfoNote("\nYou are already running!")
		else
			InfoNote("\nGoto previous room (nx-):  Can't do that now - you must be standing and ready.")
		end
	end

--	[[ Vidblain navigation ]]
	function vidblain_nav(rmid, arid)
		local ch_state = current_character_state
		vidblain_nav_tbl = { i=0, j=0, rmid=rmid, arid=arid, stat=ch_state }
		EnableTimer("execute_in_area_timer", false)
		EnableTimer("vidblain_nav_timer", true)
		Execute("mapper goto 11910") -- move to vidblain and enter the portal
		Execute("enter hole")
	end

	function vidblain_nav_tick()
		local ri = current_room
		local ch_state = current_character_state
		local vnt = vidblain_nav_tbl
		local eiat = execute_in_area_tbl
		if (ri.arid ~= nil) and (ch_state ~= nil) then
			if (ri.arid ~= "vidblain") then	-- not in vidblain yet
				vnt.i = vnt.i + 1
				if (vnt.i > 200) then
					EnableTimer("vidblain_nav_timer", false)
					xcp_clear_target(true)
					InfoNote("** vidblain nav:  abort timer - took too long to get to destination.")
					vidblain_nav_tbl = { i=0, j=0, rmid="", arid="", stat=1 }
				end
			else  -- arrived in vidblain proper
				if (ch_state == "3") and (ch_state == vnt.stat) then  -- monitor char state for 3 ticks, if stable, start EIA timer and run to target area
					vnt.j = vnt.j + 1
					if (vnt.j > 3) then
						EnableTimer("vidblain_nav_timer", false) -- stop vidblain timer
						do_mapper_goto(vnt.rmid, "walk")
						execute_in_area(vnt.arid, eiat.f)	-- start EIA timer
						vidblain_nav_tbl = { i=0, j=0, rmid="", arid="", stat=1 }
					end
				else
					vnt.stat = ch_state
				end
			end
		end
	end

--	[[ Execute in Area ]]
	function execute_in_area(arid, func)	-- id is the process or function calling this one.
		local ri = current_room
		local ch_state = current_character_state
		local fn
		if (type(func) == "function") then
			fn = func
		else
			fn = function () end
		end
		execute_in_area_tbl = { i=0, j=0, arid=arid, f=fn, stat=ch_state }
		if (ri.arid == arid) then	-- in target area
			func()
			execute_in_area_tbl = { i=0, j=0, arid="", f="", stat=1 }
		elseif (ri.arid == nil) then	--
			print("execute_in_area - nil area name")
			send_gmcp_packet("request room")
		else
			EnableTimer("execute_in_area_timer", true)
		end
	end

	function execute_in_area_tick()
		local ri = current_room
		local ch_state = current_character_state
		local eiat = execute_in_area_tbl
		if (ri.arid ~= nil) and (ch_state ~= nil) then
			if (ri.arid ~= eiat.arid) then
				eiat.i = eiat.i + 1
				if (eiat.i > 200) then
					EnableTimer("execute_in_area_timer", false)
					xcp_clear_target(true)
					InfoNote("** execute-in-area:  abort timer - took too long to get to destination.")
					execute_in_area_tbl = { i=0, j=0, arid="", f="", stat=1 }
				end
			else
				if (ch_state == "3") and (ch_state == eiat.stat) then
					eiat.j = eiat.j + 1
					if (eiat.j > 3) then
						EnableTimer("execute_in_area_timer", false)
						eiat.f()
						--eiat.f()
					end
				else
					eiat.stat = ch_state
					if (ch_state == "8") then
						EnableTimer("execute_in_area_timer", false)
						DoAfterSpecial(1.5, [[ EnableTimer("execute_in_area_timer", true) ]], 12)
					end
				end
			end
		end
	end

	function execute_in_room(rmid, func)

	end

	function execute_in_room_tick()

	end

--	[[ quick where ]]
	function qw_reset(exact)
		EnableTrigger("trg_quick_where_match", false)
		EnableTrigger("trg_quick_where_no_match", false)
		qw = { index = 1, exact = exact }
	end

	function qw_noarg()
		local ix = qw.index or 1
		local s = short_mob_name or -1
		if (s == -1) then
			InfoNote("\nSearch and Destroy: 'Quick-where' has no target.")
			InfoNote("Use 'xcp', 'qw <mob>, or 'ht <mob>' to get target info.\n")
		else
			if (qw.exact == true) then
				qw_exact()
			else
				do_quick_where(ix, s)
			end
		end
	end

	function qw_arg_alias(name, line, wildcards)
		local mob = wildcards.mob
		local index = tonumber(wildcards.index) or 1

		xcp_index = 0
		full_mob_name = -1
		xg_draw_window()

		qw_arg(index, mob)
	end

	function qw_arg(index, mob)
		short_mob_name = mob
		qw.index = index
		qw.exact = false

		do_quick_where(index, mob)
	end

	function qw_exact()  -- called from code, e.g. xcp function
		local t = main_target_list[xcp_index]
		if (t) then
			local f = t.mob
			local s = t.kw
			full_mob_name = f
			short_mob_name = s
			local ix = qw.index or 1
			local p1 = split(f, "[^ ]+")
			local p2
				for i,v in ipairs (p1) do
					if gmkw_omit[v] then
						-- do nothing
					else
						p2 = (p2 == nil) and v or p2 .. " " .. v
					end
				end
			qw.exact = true
			qw.match = p2
			do_quick_where(ix, s)
		else
			print("\nqw exact: You have no 'xcp' target.")
		end
	end

	function do_quick_where(ix, s)
		EnableTrigger("trg_quick_where_match", true)
		EnableTrigger("trg_quick_where_no_match", true)
		if (ix == 1) then	-- don't use 1.mob
			Send(string.format("where %s", s))
		else
			Send(string.format("where %s.%s", ix, s))
		end
	end

	function qw_match(name, line, wildcards)
		local mob = Trim(wildcards.mobname):lower()
		local room = wildcards.roomname
		local parts
		local found = false
		qw.index = qw.index or 1
		if (qw.exact == true) then	-- tells this function to look for an exact match for the current xcp target mob name.
			if mob == Trim(string.sub(full_mob_name, 1, 30)):lower() then
				found = true
			end
		else
			parts = split(string.lower(short_mob_name), "[^ ]+")
			for i=1, #parts do
				if (string.find(mob, parts[i], 1, true) ~= nil) then
					found = true
					break -- leave loop
				end
			end
		end
		if (found == false) then	-- not our line, keep looking
			qw.index = qw.index + 1
			if (qw.index < 101) then
				SendNoEcho(string.format("where %s.%s", qw.index, short_mob_name))
				return
			else
				print("qw: too many fails")
				found = true
				return
			end
		end
		qw_reset(qw.exact)
		-- change target
		xcp_index = 0
		full_mob_name = -1
		if quest_target.mob and current_room.arid == quest_target.arid and quest_target.mob:lower():sub(1, 30) == Trim(mob):lower() then
			full_mob_name = quest_target.mob
		else
			for i, target in ipairs(main_target_list) do
				if current_room.arid == target.arid and mob == target.mob:lower():sub(1, 30) then
					full_mob_name = target.mob
					xcp_index = i
					break
				end
			end
		end
		xg_draw_window()
		search_rooms(room, 'area', Trim(wildcards.mobname))
		if go_after then
			goto_number(nil, nil, {})
		end
	end

	function qw_no_match()	-- responds to "There is no <mob name> around here."
		qw_reset(qw.exact)
		if type(full_mob_name) == 'string' then
			lookup_not_found_mob()
		end
	end

	function lookup_not_found_mob()
		local full_name = full_mob_name:lower()
		local search_name = short_mob_name -- needed?
		local arid = current_room.arid
		local found = false
		local query = string.format("SELECT room, roomid, count FROM mobs WHERE zone = %s AND mob = %s;",
			fixsql(arid), fixsql(full_name))

		local db = assert(sqlite3.open(snd_db_file))
		local possible_rooms = {}
		local roomids= {}
		local total_count = 0

		for row in db:nrows(query) do
			found = true
			table.insert(possible_rooms, {
				rmid = row.roomid,
				name = row.room,
				arid = arid,
				count = row.count,
			})
			total_count = total_count + row.count
			table.insert(roomids, row.roomid)
		end
		db:close_vm()

		if not found then
			return
		end

		query = string.format("SELECT uid, notes FROM bookmarks WHERE uid in (%s);", table.concat(roomids, ","))
		db = assert(sqlite3.open(mapper_db_file))

		for row in db:nrows(query) do
			for i, room in ipairs(possible_rooms) do
				if tostring(room.rmid) == row.uid then
					room.notes = row.notes
					break
				end
			end
		end

		for i, room in ipairs(possible_rooms) do
			if total_count > 0 then
				room.percentage = (room.count / total_count)
			else
				room.percentage = 0
			end
		end

		table.sort(possible_rooms, sort_rooms_by_count)

		InfoNote("\nMob not found. There are multiple possible reasons for this:")
		InfoNote("  * It might be dead")
		InfoNote("  * You might be using the wrong keyword (use `xset kw` to update if needed)")
		InfoNote("  * It might be flagged nowhere")
		InfoNote("You have previously seen ", full_mob_name, " in:")
		search_rooms_results(possible_rooms)
	end

--	[[ Hunt trick ]]
	function ht_reset()
		EnableTriggerGroup("HuntTrick", false)
		ht = { index = 1, first_target = true }
	end

	function ht_noarg()
		local s = short_mob_name or -1
		local ix = ht.index or 1
		if (s == -1) then
			InfoNote("\nSearch and Destroy: 'Hunt trick' has no target.")
			InfoNote("Use 'xcp', ht <mob>', or 'qw <mob>' to pick a target.\n")
			return
		end
		do_hunt_trick(ix, s)
	end

	function ht_arg(name, line, wildcards)
		local s = wildcards.mob
		local ix = tonumber(wildcards.index) or 1
		short_mob_name = s
		xcp_index = 0
		full_mob_name = -1
		xg_draw_window()
		do_hunt_trick(ix, s)
	end

	function do_hunt_trick(ix, s)
		ht.index = ix or 1
		EnableTriggerGroup("AutoHunt", false)
		EnableTriggerGroup("HuntTrick", true)
		if (ix == 1) then	-- don't use "1.mob"
			Send(string.format("hunt %s", s))
		else
			Send(string.format("hunt %s.%s", ix, s))
		end
	end

	function ht_continue()
		local s = short_mob_name
		local ix = (ht.index + 1) or 1
		ht.first_target = false
		do_hunt_trick(ix, s)
	end

	function ht_complete(name, line, wildcards)
		EnableTriggerGroup("AutoHunt", false)
		local s = short_mob_name
		local ix = ht.index or 1
		qw_arg(ix, s)
		ht_reset()
	end

	function ht_fail()
		local first_target = ht.first_target
		EnableTriggerGroup("HuntTrick", false)
		ht_reset()


		if first_target and type(full_mob_name) == 'string' then
			InfoNote("Search and Destroy:  Hunt trick failed. Attempting quick where.")
			qw_exact()
		else
			InfoNote("Search and Destroy:  Hunt trick failed.")
		end
	end

	function ht_abort(name, line, wildcards)
		EnableTriggerGroup("HuntTrick", false)
		ht_reset()
		InfoNote("Search and Destroy:  Hunt trick cancelled.")
	end

-- [[ quick scan, quick kill ("kk") ]]
	function quick_scan()
		if (short_mob_name == nil) or (short_mob_name == "") then
			Send("scan")
		else
			Send(string.format("scan %s", short_mob_name))
		end
	end

	function smart_scan()
		if has_activity() then
			running_smart_scan = true
			DebugNote("Performing smart scan.")
			SendNoEcho("scan")
		else
			quick_scan()
		end
	end

	function quick_kill(name, line, wildcards)
		local targName = ""
		if (short_mob_name == nil) or (short_mob_name == "") or (short_mob_name == "-1") or (short_mob_name == -1) then
			InfoNote("\nSearch and Destroy: 'Quick-kill' has no target.  Use 'ht', 'qw', or 'xcp' to select a target.\n")
		else
			for command in quick_kill_command:gmatch("[%a%s%p%d]+[^;]?") do
				if not notarg then
					targName = " '" .. short_mob_name .. "'"
				end
				Execute(command .. targName)
				--Execute(command .. " '" .. short_mob_name .. "'")
			end
			--Execute(quick_kill_command .. " '" .. short_mob_name .. "'")
		end
	end

	function xset_quick_kill_command(name, line, wildcards)		-- user-defined attack to use with qk/kk
		if (wildcards.notarg ~= "") then
			notarg = true
		else
			notarg = false
		end

		SetVariable("mcvar_quick_kill_notarg", tostring(notarg))
		DebugNote("Quick kill notarg variable set to ", GetVariable("mcvar_quick_kill_notarg"))

		if (wildcards.arg == "") then
			InfoNote("Search and Destroy: Quick-kill command currently set to: '", quick_kill_command, "'")
		else
			quick_kill_command = wildcards.arg:gsub(" notarg", "")
			--quick_kill_command = wildcards.arg
			SetVariable("mcvar_quick_kill_command", quick_kill_command)
			InfoNote("Search and Destroy: Quick-kill command is now set to: '", quick_kill_command, "'")
		end
	end

	function xset_silentMode(name, line, wildcards)
		if (not wildcards[1] or wildcards[1] == "") then
			InfoNote("Search and Destroy: Silent mode currently set to: '", silentMode, "'")
		else
			silentMode = wildcards[1]:lower()
			SetVariable("mcvar_silentMode_command", silentMode)
			InfoNote("Search and Destroy: Silent mode is now set to: '", silentMode, "'")
		end
	end

-- [[ Room search processes ]]
	local search_rooms_sql =
		"SELECT r.uid as uid, r.name as name, info, r.area as area, " ..
		"ifnull(a.name, r.area) as area_name, 1 as DisplayOrder " ..
		"FROM rooms r " ..
		"LEFT OUTER JOIN areas a ON r.area = a.uid " ..
		"WHERE r.name = %s " .. -- room
		"AND (%s = 'all' OR (a.name = %s OR r.area = %s)) " .. -- area_id x3
		"UNION " ..
		"SELECT r.uid, r.name, info, r.area, " ..
		"ifnull(a.name, r.area) as area_name, 0 as DisplayOrder " ..
		"FROM rooms r " ..
		"LEFT OUTER JOIN areas a ON r.area = a.uid " ..
		"WHERE r.name <> %s " ..	-- room
		"AND r.name LIKE %s " .. 	-- like
		"AND (%s = 'all' OR (a.name = %s OR r.area = %s)) " .. -- area_id x3
		"ORDER BY area, DisplayOrder DESC "

	function search_rooms(room_name, searchType, fullMobName)
		if (room_name == nil) or (room_name == "") then
			Note("map_area() error : room name isn't known")
		else
			local ri = current_room
			local parts = split(room_name, "[^|]+") -- pipe delimited:  room|area
			local room = parts[1]
			local arid
			if (#parts == 2) then
				arid = parts[2]
			else
				if (current_room ~= nil) then
					arid = ri.arid
				else
					InfoNote("Area not known, falling back to mapper list")
					Execute("mapper list " .. parts[1])
				end
			end
			if (room == nil) then
				Note("map_area() - Room not known")
				return
			end
			local like = "%"..room.."%"
			-- i forget what this does? Strip out a leading " ?
			--if string.sub(room,1,1) == "\"" and string.sub(room,-1) == "\"" then
			--	like = string.sub(room,2,-2)
			--end
			local select = string.format(search_rooms_sql,	fixsql(room),
															fixsql(arid), fixsql(arid), fixsql(arid),
															fixsql(room),
															fixsql(like),
															fixsql(arid), fixsql(arid), fixsql(arid))
			local db = assert(sqlite3.open(mapper_db_file))
			local results = {}
			local roomid_list = {}
			local has_results = false
			for row in db:nrows(select) do
				has_results = true
				local id = (tonumber(row.uid) or -1) -- sanitize text room ids for "unmappable" (nomap) rooms that are now being mapped
				results[#results + 1] = {
					rmid = id,
					name = row.name,
					info = row.info,
					area = row.area_name,
					arid = row.area, --or row.area_name -- make safe against bad dbs
					notes = row.notes,
				}
				if (id > 0) then	-- make a list of room ids
					roomid_list[#roomid_list + 1] = id
				end

			end   -- finding rooms

			if has_results then
				local notes_query = string.format("SELECT uid, notes FROM bookmarks WHERE uid in (%s);", table.concat(roomid_list, ","))
				for row in db:nrows(notes_query) do
					for i, room in ipairs(results) do
						if tostring(room.rmid) == row.uid then
							room.notes = row.notes
							break
						end
					end
				end
			end

			db:close_vm()

			if has_results and fullMobName then
				local SnDdb = assert(sqlite3.open(snd_db_file))
				local count_by_room = {}
				local sum = 0

				select = string.format("SELECT roomid, count FROM mobs WHERE zone = %s AND mob = %s AND roomid in (%s);", fixsql(arid), fixsql(fullMobName), table.concat(roomid_list, ","))

				for row in SnDdb:nrows(select) do
					count_by_room[row.roomid] = row.count
					sum = sum + row.count
				end
				SnDdb:close_vm()

				for i, result in ipairs(results) do
					result.count = count_by_room[result.rmid] or 0
					if sum > 0 then
						result.percentage = (result.count / sum)
					else
						result.percentage = 0
					end
				end

				table.sort(results, sort_rooms_by_count)
			end

			search_rooms_results(results)
		end
	end

	function sort_rooms_by_count(a, b)
		if a.count > b.count then
			return true
		elseif	a.count < b.count then
			return false
		else
			return a.rmid < b.rmid
		end
	end

	function search_rooms_results(results)	-- Display list of 'go' links from hunt-trick, quick-where, etc.
		gotoArea = -1
		gotoIndex = 1
		next_room = -1
		gotoList = {}
		local mapper_area_index = 0
		local line_num = 0
		local last_area = ""
		local has_chance = #results > 0 and results[1].percentage
		local width = 69
		ColourTell("#808080", "", string.format("\nXCP  Location %36s", "(uid)"))
		if has_chance then
			width = 80
			ColourTell("#808080", "", string.format("%20s", "(chance)"))
		end
		print("")
		ColourNote("#808080", "", string.rep("-", width))
		for i,v in ipairs (results) do
			line_num = line_num + 1
			local background = (line_num % 2) == 0 and text_colors.alternating_row or ""
			local instruction = "go " .. mapper_area_index
			if (last_area ~= v.arid) then
				local padding = string.rep(" ", width - 5 - #v.arid)
				if (mapper_area_index == 0) then
					local areaLine = string.format("%2d   %s%s", mapper_area_index, v.arid, padding)
					Hyperlink("go " .. mapper_area_index, areaLine, "go to area " .. v.arid, "silver", background, 0, 1)
					gotoList[mapper_area_index] = v.arid
					gotoArea = v.arid
					mapper_area_index = mapper_area_index + 1
				else
					local areaLine = string.format("     %s%s", v.arid, padding)
					Hyperlink("xrt " .. v.arid, areaLine, "go to area " .. v.arid, "silver", background, 0, 1)
				end
				print("")
				line_num = line_num + 1
				last_area = v.arid
			end
			background = (line_num % 2) == 0 and text_colors.alternating_row or ""
			local name = ellipsify(string.gsub(v.name, "@[a-zA-Z]", ""), 38)
			local text = string.format("%2d   %-38s  %-7s ", mapper_area_index, name, string.format("(%s)", v.rmid))
			Hyperlink("go " .. mapper_area_index, text, "go to item " .. mapper_area_index, "lightblue", background, 0, 1)

			local instruction = "mapper where " .. v.rmid
			local tooltip = "click for speedwalk to this room"
			Hyperlink(instruction, "   {sw}", tooltip, "#FF5000", background, 0, 1)
			gotoList[mapper_area_index] = v.rmid

			if v.percentage then
				local pct_string = string.format("%6.2f%%", v.percentage * 100)
				Hyperlink(instruction, "  (", tooltip, "silver", background, 0, 1)
				Hyperlink(instruction, pct_string, tooltip, mob_room_percentage_color(v.percentage), background, 0, 1)
				Hyperlink(instruction, ")", tooltip, "silver", background, 0, 1)
			end

			if v.notes then
				Hyperlink(string.format("roomnote %i", v.rmid), "  [notes]", v.notes, "lightgreen", background, 0, 1)
			else
				ColourTell("", background, string.rep(" ", 9))
			end

			print("")
			mapper_area_index = mapper_area_index + 1
		end
		if (mapper_area_index == 0) then
			InfoNote("No matching rooms found.")
		end
		ColourNote("#808080", "", string.rep("-", width))
		ColourNote("#808080", "", "Type 'go <index>' or click link to go to that room.\n")
	end

	-- Return a color between #aaaaaa (grey, at 0%) and #44ff00 (green, at 100%)
	function mob_room_percentage_color(percentage)
		local red_from, red_to = 170, 68
		local green_from, green_to = 170, 255
		local blue_from, blue_to = 170, 0

		-- using the straight percentage was resulting in numbers being too grey
		percentage = math.min(1, math.max(0, math.sqrt(percentage)))

		return string.format("#%02x%02x%02x",
			red_from + (red_to - red_from) * percentage,
			green_from + (green_to - green_from) * percentage,
			blue_from + (blue_to - blue_from) * percentage)
	end

	function map_area(name, line, wildcards)
		search_rooms(wildcards.loc, 'area')
	end

	function map_area_all(name, line, wildcards)
		search_rooms(wildcards.loc .. "|all", 'all')
	end

--	[[ "xwhere" command ]]
	function do_xwhere(name, line, wildcards)
		local n1 = tonumber(wildcards.n1) or 12	-- if no number given, default to 12
		local n2 = tonumber(wildcards.n2) or ""
		local mob = wildcards.mob or ""
		if (mob == "") then						-- user entered no numbers, no mobname, or no args at all
			InfoNote("\nSearch and Destroy: 'xwhere' required parameter missing.\n")
			InfoNote("              Syntax: 'xwhere <mobname>'")		-- default to 10
			InfoNote("                      'xwhere <n1> <mobname>'")	-- where 1.mobname to n1.mobname
			InfoNote("                      'xwhere <n1> <n2> <mobname>'")	-- where 1.mobname to n2.mobname
			return
		elseif (n2 == "") then	-- user entered one number (n1) and a mobname, but no second number (n2)
			InfoNote("\nSearch and Destroy: 'xwhere ", n1, " ", mob, "'")
			for i = 1, n1, 1 do
				if (i == 1) then
					Send("where " .. mob)
				else
					Send("where " .. i .. "." .. mob)
				end
			end
		elseif (mob ~= "") and (n2 ~= "") then	-- user entered n1, n2, and mobname
			InfoNote("Search and Destroy: 'xwhere ", n1, " ", n2, " ", mob, "'")
			for i = n1, n2, 1 do
				if (i == 1) then
					Send("where " .. mob)
				else
					Send("where " .. i .. "." .. mob)
				end
			end
		else
			InfoNote("Search and Destroy: 'xwhere' data entry problem!")
		end
	end

--	[[ Autohunt ]]
	function auto_hunt(name, line, wildcards)
		local s = string.lower(wildcards.arg)
		if (s == "abort") or (s == "cancel") or (s == "0") then
			auto_hunt_abort()
		else
			ht_reset()
			EnableTriggerGroup("AutoHunt", true)				auto_hunt_mob = s
			Send("hunt " .. s)
		end
	end

	function auto_hunt_abort()
		auto_hunt_reset()
		InfoNote("Search and Destroy:  Auto-hunt cancelled.\n")
	end

	function auto_hunt_complete()
		auto_hunt_reset()
		InfoNote("Search and Destroy: Auto-hunt complete.\n")
	end

	function auto_hunt_lowskill()
		InfoNote("\nSearch and Destroy:  Autohunt not available - hunt skill is too low.")
		InfoNote("                     If hunt skill is available, practice it to 85% or higher.")
		auto_hunt_reset()
	end

	function auto_hunt_move(direction)
		local ri = current_room
		local dir = dir_map[direction]
		auto_hunt_direction = dir
		if (ri) then	-- don't know our gmcp exits, so just go with it
			if (ri.exits[dir] == nil ) then	-- exit is visible in gmcp
				Send("open " .. dir)
			end
		end
		Send(dir)
	end

	function auto_hunt_next(name, line, wildcards)
		local dir = wildcards.dir
		auto_hunt_move(dir)
		Send("hunt " .. auto_hunt_mob)
	end

	function auto_hunt_door()
		EnableTrigger("trg_autohunt_next_1", false)
		EnableTrigger("trg_autohunt_next_2", false)
		Send("open " .. auto_hunt_direction)
	end

	function auto_hunt_door_open()
		EnableTrigger("trg_autohunt_next_1", true)
		EnableTrigger("trg_autohunt_next_2", true)
		Send(auto_hunt_direction)
		Send("hunt " .. auto_hunt_mob)
	end

	function auto_hunt_portal()
		InfoNote("\nSearch and Destroy: Auto-hunt through portals not working yet.  Enter portal manually and then autohunt again.")
		auto_hunt_reset()
	end

	function auto_hunt_reset()
		EnableTriggerGroup("AutoHunt", false)
		auto_hunt_mob = ""
		auto_hunt_direction = ""
		autoHuntData = { count = 0, north = 0, south = 0, east = 0, west = 0, up = 0, down = 0 }
	end

--	[[ Automatic noexp ]]
	function xset_noexp_tnl(name, line, wildcards)		-- called by alias: "xset noexp" when argument given
		local set_tnl = wildcards.arg or "-1"
		if (anex_automatic_onoff == "on") then
			if (wildcards.arg == "-1") or (wildcards.arg == "") or (wildcards.arg == nil) then
				if (anex_tnl_cutoff == 0) then
					InfoNote("Search and Destroy: Auto 'noexp' is currently OFF.")
				else
					InfoNote("Search and Destroy: Auto 'noexp' is ON and set to ", anex_tnl_cutoff, " TNL.\n")
				end
			elseif (wildcards.arg == "off") or (wildcards.arg == "0") then	-- "xset noexp off" and "xset noexp 0" turn auto-noexp off.
				EnableTrigger("trg_anex_mobdeath_xp1", false)
				anex_tnl_cutoff = 0
				SetVariable("mcvar_anex_tnl_cutoff", anex_tnl_cutoff)
				InfoNote("\nSearch and Destroy: Auto 'noexp' is now OFF.\n")
			else											-- xset with any other (positive) number turns auto-noexp on.
				EnableTrigger("trg_anex_mobdeath_xp1", true)
				anex_tnl_cutoff = tonumber(set_tnl)
				SetVariable("mcvar_anex_tnl_cutoff", anex_tnl_cutoff)
				InfoNote("\nSearch and Destroy: Auto 'noexp' now set to ", anex_tnl_cutoff, " TNL.\n")
			end
		else
			InfoNote("\nSearch and Destroy: 'noexp' is *manually* OFF.\nType 'noexp' again to turn it back on.")
		end
		xg_draw_window()
	end

	function anex_set_noexp(x)
		if (anex_automatic_onoff) == "on" then
			if (x == "on") or (x == "off") then
				noexp_onoff = x
				send_gmcp_packet("config noexp " .. x)
				print("noexp: " .. noexp_onoff)
			end
		else
			noexp_onoff = "off"
		end
		xg_draw_window()
	end

	function anex_can_get_new_cp()		-- called by line 'You may take campaign this level.' in 'cp check'
		if (anex_automatic_onoff == "on") then
			if (anex_tnl_cutoff > 0) then	-- if anex_tnl_cutoff > 0 then auto-noexp is on.
				local level = tonumber(gmcp("char.status.level"))
				if (level < 200) then
					local tnl = tonumber(gmcp("char.status.tnl"))
					if (tnl < anex_tnl_cutoff) and (noexp_onoff == "off") then		-- tnl less than set point and noexp is off --> turn that shit on
						anex_set_noexp("on")
						InfoNote("\nSearch and Destroy: Turning 'noexp' ON (Your TNL is less than ", anex_tnl_cutoff, ")")
					elseif (tnl > anex_tnl_cutoff) and (noexp_onoff == "on") then	-- if over min TNL and noexp is on --> turn noexp off regardless
						anex_set_noexp("off")
						InfoNote("\nSearch and Destroy: Turning 'noexp' OFF (your TNL is greater than ", anex_tnl_cutoff, ")")
					end
				else
					if (noexp_onoff == "on") then
						anex_set_noexp("off")
						InfoNote("\nSearch and Destroy: Turning noexp OFF (you have reached level ", plevel, ")")
					end
				end
			else 	-- feature is turned off, just show reminder
				anex_tnl_cutoff = 0	-- set to 0 if somehow negative
				InfoNote("Automatic 'noexp' is currently turned OFF.\n")
			end
		end
	end

	function anex_must_level_new_cp()	-- called by trigger:  You must level to get a new campaign
		if anex_automatic_onoff == "on" then
			if (anex_tnl_cutoff > 0) then
				local level = tonumber(gmcp("char.status.level"))
				if (level < 200) then
					if (noexp_onoff == "on") and (player_on_cp == "yes") then
						InfoNote("Search and Destroy: Turning noexp OFF (must level to get new cp)")
						anex_set_noexp("off")
					end
				else
					if (noexp_onoff == "on") then
						anex_set_noexp("off")
						InfoNote("Search and Destroy: Turning noexp OFF (you have reached level ", level, ")")
					end
				end
			end
		end
	end

	function anex_mobdeath_xp1(name, line, wildcards)	-- called when mob kill awards xp
		if (anex_automatic_onoff == "on") then
			local level = tonumber(gmcp("char.status.level"))
			if (anex_tnl_cutoff > 0) then
				if (level < 200) then
					DoAfterSpecial(0.1, [[ anex_mobdeath_xp2() ]], 12)
				else
					if (noexp_onoff == "on") then
						anex_set_noexp("off")
						InfoNote("Search and Destroy: Turning noexp OFF (you have reached level ", level, ")")
						InfoNote("                    Use 'xset noexp off' to override.")
					end
				end
			end
		end
	end

	function anex_mobdeath_xp2()	-- called via timer set by function anex_mobdeath_xp1
		if (anex_automatic_onoff == "on") then
		local tnl = tonumber(gmcp("char.status.tnl"))
		if (can_get_new_cp == "yes") then
			if (tnl < anex_tnl_cutoff) then
				if (noexp_onoff == "off") then
					anex_set_noexp("on")
					InfoNote("\nSearch and Destroy: Turning 'noexp' ON (your TNL is less than ", anex_tnl_cutoff, ")")
				end
			else
				if (noexp_onoff == "on") then
					anex_set_noexp("off")
					InfoNote("\nSearch and Destroy: Turning 'noexp' OFF (your TNL is greater than ", anex_tnl_cutoff, ")")
				end
			end
		else
			if (noexp_onoff == "on") then
				anex_set_noexp("off")
				InfoNote("\nSearch and Destroy: Turning 'noexp' OFF (you must level before taking a new campaign)")
			end
		end
		end
	end

	function anex_check_tnl_silent()	-- used by the window's clickable TNL cutoff changer
		local tnl = tonumber(gmcp("char.status.tnl"))
		if (can_get_new_cp == "yes") then
			if (tnl < anex_tnl_cutoff) then
				if (noexp_onoff == "off") then
					anex_set_noexp("on")
				end
			else
				if (noexp_onoff == "on") then
					anex_set_noexp("off")
				end
			end
		else
			if (noexp_onoff == "on") then
				anex_set_noexp("off")
			end
		end
	end

	function anex_automatic_on()	-- Noexp will toggle automatically according to the TNL setting.
		anex_automatic_onoff = "on"
		noexp_onoff = "off"
		SetVariable("mcvar_anex_automatic_onoff", "on")
		xg_draw_window()
	end

	function anex_automatic_off()	-- Manually turns off experience and disables automatic toggling.  Typing noexp again turns the automatics back on.
		anex_automatic_onoff = "off"
		noexp_onoff = "on"
		SetVariable("mcvar_anex_automatic_onoff", "off")
		xg_draw_window()
	end

	function xset_to_mark(name, line, wildcards)
		local ri = current_room
		area_start_rooms[ri.arid] = {}
		area_start_rooms[ri.arid].roomid = ri.rmid
		tprint(area_start_rooms)
		local serial = serialize.save_simple(area_start_rooms)
		SetVariable("mcvar_areaStartRooms", serial)
		InfoNote("\nxset mark: Room ", ri.rmid, " set as start of area ", ri.arid, ".\n")
	end

	function get_start_room(area_id, exact)
		local arid = string.lower(area_id)
		start_room_type = "xset mark"			-- If 'xset mark' was set, xrunto will go there.
		local possible_room_type
		if area_start_rooms[arid] then 			-- Function exits as soon as any 'return' statement is encountered.
			return area_start_rooms[arid].roomid			-- Exact match on area id
		end

		local possible_match = nil
		for k,v in pairs (area_start_rooms) do
			if k:lower() == arid then -- exact match
				return v.roomid
			elseif string.match(string.lower(k), arid) then
				possible_room_type = "xset_mark"
				possible_match = v.roomid
			end
		end
		start_room_type = "default"						-- If 'xset mark' isn't set, look up start room from the table areaDefaultStartRooms.
		if areaDefaultStartRooms[arid] then 	-- Note, Upper/Lower Planes have the same default room.  More development needed here.
			return areaDefaultStartRooms[arid].start		-- exact match on area id
		end
		for k,v in pairs (areaDefaultStartRooms) do
			if k:lower() == arid then -- exact match
				return v.start
			elseif string.match(string.lower(k), arid) then
				possible_room_type = possible_room_type or "default"
				possible_match = possible_match or v.start
			end
		end
		if possible_match and not exact then
			start_room_type = possible_room_type
			return possible_match
		else
			return "-1"
		end
	end

--	[[ "xset vidblain" ]]
	function xset_vidblain(name, line, wildcards)
		local x = xset_vidblain_onoff
		x = (x == "on") and "off" or "on"
		xset_vidblain_onoff = x
		SetVariable("mcvar_xset_vidblain_onoff", x)
		InfoNote("\nVidblain navigation is now ", string.upper(x), "\n")
	end

	function xset_vidblain_setlevel(name, line, wildcards)
		local x = tonumber(wildcards.level) or "check"
		if (x == "check") then
			InfoNote("\n'xset vidblain' portal level is ", xset_vidblain_level, "\n")
		else
			xset_vidblain_level = x
			SetVariable("mcvar_xset_vidblain_level", x)
			InfoNote("\n'xset vidblain' portal level set to ", x, "\n")
		end
	end

	local is_vidblain_area_sql = "SELECT area FROM rooms WHERE uid = %s "

	function is_vidblain_area(roomid)
		local level = tier_level()--tonumber(gmcp("char.status.level")) + 10 * tonumber(gmcp("char.base.tier"))
		if (xset_vidblain_onoff == "on") and (level < xset_vidblain_level) then
			--local worldPath = GetInfo(66) .. Trim(sanitize_filename(WorldName()))
			--local db = assert(sqlite3.open(worldPath .. ".db"))
			local db = assert(sqlite3.open(mapper_db_file))
			local select = string.format (is_vidblain_area_sql, fixsql(roomid))
			local ar
			for row in db:nrows(select) do
				ar = row.area
			end
			db:close_vm()
			if (vidblain_area_list[ar]) then
				return true
			else
				return false
			end
		else
			return false
		end
	end

--	[[ Simulate cp ]]
	function simulate_cp(name, line, wildcards)
		if (wildcards.type == "") then
			area_room_type = "area"
			current_activity = "cp"
		else
			area_room_type = wildcards.type
			current_activity = "cp"
		end
		local time_check = os.clock()					-- prevent double cp checks from different plugins
		if ((time_check - last_cp_check) < 1.0) then
			return
		end
		last_cp_check = time_check
		cp_check_list = {}
		EnableTrigger("trg_cp_check_line", true)
		Simulate("\n")
		if (area_room_type == "area") then
			Simulate("You still have to kill * the head necromancer's assistant (Necromancers' Guild)\n")
			Simulate("You still have to kill * Isscheburqua (Insanitaria)\n")
			Simulate("You still have to kill * a rook citizen (Avian Kingdom - Dead)\n") -- dead
			Simulate("You still have to kill * Lea, the farmer's daughter (Farmyard)\n") -- unknown
			Simulate("You still have to kill * a former court jester (The Labyrinth)\n")
			Simulate("You still have to kill * Parent (A Cold Path - Dead)\n")   --dead and unknown
			Simulate("You still have to kill * a wealth redistribution specialist (Empyrean, Streets of Downfall)\n") -- long unnknown
			Simulate("You still have to kill * a wealth redistribution specialist (Empyrean, Streets of Downfall and Upfall and Other Things)\n") -- really long unnknown
			Simulate("You still have to kill * Laurence, archangel of the sword and shield and other implements of war (The Flying Citadel)\n") -- long known
			Simulate("You still have to kill * the spirit of Bakarne (The Empire of Aiighialla)\n")
			Simulate("You still have to kill * a sinister vandal (The Three Pillars of Diatz)\n") -- noscan
			Simulate("You still have to kill * a hideously hairy spider (The Temple of Shouggoth)\n") -- nowhere
			Simulate("You still have to kill * Don Crumble (Zangar's Demonic Grotto)\n") -- nohunt
			Simulate("You still have to kill * A very large firefly (Kobold Siege Camp)\n") -- nohunt/nowhere
		else
			Simulate("You still have to kill * a former court jester (The Labyrinth)\n")
			Simulate("You still have to kill * the iron golem (Audience Chamber)\n")
			Simulate("You still have to kill * probably a fake mob (Probably a Fake Room)\n")
			Simulate("You still have to kill * Jarre (The UnderDark - Dead)\n") -- known dead
			Simulate("You still have to kill * the heart of a sandstorm (Buried in the Great Desert's unrelenting dunes)\n") -- long
			Simulate("You still have to kill * Parent (The Kitchen)\n")  -- lots of options
			Simulate("You still have to kill * A sprite prisoner (A cell)\n")
			Simulate("You still have to kill * the cutpurse (Road of Shadows)\n") -- many rooms
			Simulate("You still have to kill * definitely a fake mob (Fake Area - Dead)\n") -- unknown dead
			Simulate("You still have to kill * the gibbering mouther (Dining Hall)\n")  -- lots of options
			Simulate("You still have to kill * a sinister vandal (In The Courtyard)\n") -- noscan
			Simulate("You still have to kill * a hideously hairy spider (The Landing)\n") -- nowhere
			Simulate("You still have to kill * Sssssuper long mob name that should break formatting (This can't be a real room, right)\n") -- long unknown
			Simulate("You still have to kill * Laurence, archangel of the sword and shield and other implements of war (In the clouds)\n") -- long known
			Simulate("You still have to kill * a giant bee (An Impossibly Dark Intersection in the Labyrinth)\n") -- long room name

		end
		Simulate("Note: Dead means that the target is dead, not that you have killed it.\n")
		Simulate("\n")
		Simulate("You have 6 days, 23 hours and 56 minutes left to finish this campaign.\n")
		Simulate("\n")

	end

	function spoof_level(name, line, wildcards)
		local level = math.min(201, math.max(1, wildcards.level))
		gq_info_efflvl = level
		cp_info_level = level
		Note("Pretending level is ", level, " for testing purposes\n")
	end

	function simulate_quest(name, line, wildcards)
		local result = {
			targ = 'a garden snake',
			area = "Kimr's Farm",
			room = "Old Farm Lane",
		}
		local status = wildcards.status
		if #status == 0 then status = "status" end

		InfoNote("Simulating quest with status ", status)

		if status == "start" then
			result.action = "start"
		elseif status == "status" then
			result.action = "status"
			result.timer = 60
		elseif status == "killed" then
			result.action = "killed"
		elseif status == "comp" then
			result.action = "comp"
		elseif status == "fail" then
			result.action = "fail"
		elseif status == "reset" then
			result.action = "reset"
		elseif status == "ready" then
			result.action = "ready"
		elseif status == "timeout" then
			result.action = "timeout"
		elseif status == "statkilled" then
			result.action = "status"
			result.target = "killed"
		elseif status == "wait" then
			result.action = "status"
			result.wait = 60
		elseif status == "ready" then
			result.action = "status"
			result.status = "ready"
		end

		quest_status_gmcp(result)
	end

-- [[ Room notes ]]
	function room_note_area(name, line, wildcards)
		if (wildcards.arid == "") then
			--get_notes(current_room.arid, nil)
			get_notes(gmcp("room.info.zone"), nil)
		else
			get_notes(wildcards.arid, nil)
		end
	end

	function room_note(name, line, wildcards)
		--get_notes(nil, current_room.rmid)
		if not get_notes(nil, gmcp("room.info.num")) then
			InfoNote("No notes found for room this room.\n")
		end
	end

	function room_note_room(name, line, wildcards)
		if not get_notes(nil, wildcards.roomid) then
			InfoNote(string.format("No notes found for room %s.\n", wildcards.roomid))
		end
	end

	function get_notes(arid, roomid, text_only)
		--local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		--local db = assert(sqlite3.open(worldPath .. ".db"))
		local db = assert(sqlite3.open(mapper_db_file))
		local sql =  " SELECT b.uid, b.notes "
		sql = sql .. " FROM bookmarks b "
		if arid then
			sql = sql .. " INNER JOIN rooms r ON b.uid = r.uid "
			sql = sql .. " WHERE r.area = " .. fixsql(arid)
		else
			sql = sql .. " WHERE b.uid = " .. fixsql(roomid)
		end
		sql = sql .. " ORDER BY b.uid "
		local found_notes = false
		if (arid ~= nil) then
			Simulate("\nNotes for " .. getAreaNameFromId(arid) .. "\n")
		end
		for row in db:nrows(sql) do
			found_notes = true
			if (text_only == true) then
				local line = string.format("    note:'%s'", row.notes)
				Hyperlink("xmapper move " .. row.uid, line, "go to room " .. row.uid, "lightblue", "black", 0, 1)
			else
				local line = string.format("    (%s) %s", row.uid, row.notes)
				Hyperlink("xmapper move " .. row.uid, line, "go to room " .. row.uid, "lightblue", "black", 0, 1)
			end
			print("")
		end
		db:close_vm()
		if not found_notes then
			if arid then
				Simulate("\tNo notes.\n")
			else
				return false
			end
		end
		return true
	end

	function getAreaIdFromName(name)
		local db = assert(sqlite3.open(mapper_db_file))
		local sql =  "SELECT uid FROM areas WHERE name = %s"
		for row in db:nrows(string.format (sql, fixsql(name))) do
			db:close_vm()
			return row.uid
		end
		db:close_vm()
		return name
	end

	function getAreaNameFromId(arid)
		local db = assert(sqlite3.open(mapper_db_file))
		local sql =  "SELECT name FROM areas WHERE uid = %s"
		for row in db:nrows(string.format (sql, fixsql(arid))) do
			db:close_vm()
			return row.name
		end
		db:close_vm()
		return arid
	end

	function getAreaFromRoomId(room_id)
		local db = assert(sqlite3.open(mapper_db_file))
		local sql =  "SELECT area FROM rooms WHERE uid = %s"
		for row in db:nrows(string.format(sql, fixsql(room_id))) do
			db:close_vm()
			return row.area
		end
		db:close_vm()
		return room_id
	end

	function getAreaUid(name)
		local db = assert(sqlite3.open(mapper_db_file))
		local sql =  "SELECT uid FROM areas WHERE name = %s order by uid "
		local areas = {}
		local index = 0
		for row in db:nrows(string.format (sql, fixsql(name))) do
			index = index + 1
			areas[index] = {uid = row.uid, name = name}
		end
		db:close_vm()
		return areas
	end

--	[[ SQL execution ]]
	function RunSql(name, line, wildcards)
		local worldPath = GetInfo(66) .. "/worlds/plugins/"
		local db = assert(sqlite3.open(snd_db_file))
		local index = 0
		local sql = wildcards.sql
		ColourNote("#00C040", "", "\nrunning sql: " .. sql)
		for row in db:nrows(sql) do
			index = index + 1
			print("----------- record " .. index .. " -----------" )
			-- tprint(row)
			print (serialize.save ("row", row))
		end
		db:close_vm()
	end

	function ExecSql (name, line, wildcards)
		local db = assert(sqlite3.open(mapper_db_file))
		Note("executing " .. wildcards.sql)
	--	dbcheck (db:execute (fixsql(wildcards.sql)))
		db:execute(fixsql(wildcards.sql))
		db:close_vm()
		Note("ok")
	end


--	[[ page size functions ]]
	local page_size = 0
	local page_size_suspended = false

	function capture_page_size(name, line, wildcards)
		EnableTrigger("trg_capture_page_size", false)
		local size = tonumber(wildcards[1])
		page_size = size or 0
		SendNoEcho("pagesize 0")
	end

	function suspend_page_size(name, line, wildcards)
		if (page_size_suspended == false) then
			page_size_suspended = true
			InfoNote("\nSearch and Destroy: Temporarily disabling pagesize (area index process)\n")
			EnableTrigger("trg_capture_page_size", true)
			EnableTrigger("trg_pagesize_gag_1", true)
			SendNoEcho("pagesize")
		end
	end

	function resume_page_size(name, line, wildcards)
		InfoNote("\nSearch and Destroy: Area index complete. Pagesize re-enabled (if >0)\n")
		EnableTrigger("trg_capture_page_size", false)
		if (page_size ~= 0) then
			SendNoEcho("pagesize " .. page_size)
		end
		page_size_suspended = false
	end

	function xmapper_move(name, line, wildcards)
		local r = wildcards.roomid
		local s = wildcards.speed
		if (r == "-1") then
			InfoNote("\nSearch and Destroy:  Can't go to room id -1 (nomap room)\n")
		elseif (r ~= "") then
			do_mapper_goto(r, s)
		end
	end

	function do_mapper_goto(r, s)
		if (s == nil or s == "") then
			s = speed
		end
		if (s == "walk") then
			--Note("walking to " .. r)
			Execute("mapper walkto " .. r)
		else
			Execute("mapper goto " .. r)
		end
	end

--	[[ Former plugin - S&D GUI ]]
	function clear_window_menu_hotspots()
		DebugNote("trying to clear all menu hotspots")
		for k, v in pairs(win_hotspots) do
			DebugNote("Deleting hotspot ", k)
			WindowDeleteHotspot(win, k)
		end
		win_hotspots = {}
	end

	local window_fonts = {
		["title"]	= { f="Consolas",				 s=10, 				b=false, 	i=false, 	u=false },
		["bt1"]	 	= { f="Segoe",					 s=10, 				b=true, 	i=false, 	u=false },
		["bt2"] 	= { f="Segoe",					 s=10, 				b=true, 	i=false, 	u=false },
		["circ1"] 	= { f="Consolas",				 s=11, 				b=false, 	i=false, 	u=false },
		["circ2"]	= { f="Consolas",				 s= 9, 				b=false, 	i=false, 	u=false },
		["cplevel"] = { f="Consolas",				 s=11, 				b=false, 	i=false, 	u=false },
		["noexp"]	= { f="Consolas",				 s=11, 				b=false, 	i=false, 	u=false }, --noexp tnl
		["noexp2"]	= { f="Consolas",				 s= 9, 				b=false, 	i=false, 	u=false },
	}

	function xg_create_window()
		if (win_init == false) then
			win_init = true
			local width = win_width
			local height = win_height
			WindowCreate(win, windowinfo.window_left, windowinfo.window_top, width, height, windowinfo.window_mode, windowinfo.window_flags, win_bgcolor)  -- create window
			for k,v in pairs (window_fonts) do
				WindowFont(win, k, v.f, v.s, v.b, v.i, v.u, false)
			end
			WindowFont(win, "cplist", win_font, win_font_size, win_font_bold, win_font_italic, win_font_underline, false)
			if not GetVariable("mcvar_xgui_window_onoff") then SetVariable("mcvar_xgui_window_onoff", "on") end
			WindowShow(win, true and GetVariable("mcvar_xgui_window_onoff") == "on" or false)  -- show it
			if (win_state == "min") then
				mouseup_drag(0, "hsMinimize")
			end
			if (IsPluginInstalled(plugin_id_z_order) and GetPluginInfo(plugin_id_z_order, 17)) then
				CallPlugin(plugin_id_z_order, "registerMiniwindow", win)
			end
			xg_draw_window()
		end
	end

	function xg_draw_window()
		WindowRectOp (win, miniwin.rect_fill, 0, 0, 0, 0, win_bgcolor)			-- Clear the window, which is the first step in updating it
		WindowRectOp (win, 2, 0, 0, 0, 17, 0x000000)						 	-- Draw title bar background and set color (almost black, "17" is height)
		WindowRectOp (win, 4, 0, 0, 0, 17, 0xE0E0E0, 0x909090)					-- Draw title bar border (left/top = light grey, right/bottom = darker grey, "17" is height)
		WindowRectOp (win, 1, 0, 0, 0, 0, 0xC0C0C0, 15)							-- Draw window border.
		WindowRectOp (win, 1, 1, 17, -1, -1, 0x000000, 15)						-- Draw colored perimeter line.
		WindowText (win, "title", 		-- draw the window title text and set its color
					current_sd_version,			-- window title text
					5, 0, 255, 15,				-- left (x1), top (y1), right (x2), bottom (y2) values for window title text
					0xA0FFFF, 					-- colour (light yellow)
					false)						-- not unicode
		if (win_hotspots["hsDrag1"] == nil) then	-- make the title bar draggable
			win_hotspots["hsDrag1"] = WindowAddHotspot(win, "hsDrag1", 0, 0, win_width-1, 16, -- hotspot id, rectangle (left, top, right, bottom)
						"", "", "mousedown_drag", "", "mouseup_drag",
						"Left click = Drag title bar to move\nRight click = Send window to front/back", miniwin.cursor_arrow, 0)
			WindowDragHandler(win, "hsDrag1", "dragmove", "dragrelease", 0)
		end

		local x_offset = 0
		if win_hide_settings_button == "off" then
			draw_settings_button(5, 20)
			x_offset = 40
		end
		draw_b1_action_buttons(47 + x_offset, 20)	-- draw xcp, go, etc. buttons
		draw_circle_readout(5 + x_offset, 20)		-- add circle text/level readout
		draw_noexp_readout(206 + x_offset, 22)	-- add noexp on/off and TNL indicator
		draw_resize_tag()
		xg_show_target_links()
		Redraw()
	end

	local button_1_list = {
--[[ 1 ]]	["hsXCP"] = { L=  0, text="xcp", tdx=3, tdy=3, exec1=     "xcp", exec2=   "xcp 0", tooltip="Left click = get target\nRight click = clear target" },
--[[ 2 ]]	["hsGO"]  = { L= 31, text= "go", tdx=7, tdy=3, exec1=      "go", exec2=    "go 0", tooltip="Left click = Go to room 1\nRight click = Go to area start" },
--[[ 3 ]]	["hsKK"]  = { L= 62, text= "kk", tdx=8, tdy=3, exec1=      "kk", exec2=      "kk", tooltip="Left click = 'kill' target mob\nRight click = kill with special" },
--[[ 4 ]]	["hsNX"]  = { L= 93, text= "nx", tdx=7, tdy=3, exec1=      "nx", exec2=     "nx-", tooltip="Left click = goto next\nRight click = goto prev" },
--[[ 5 ]]	["hsQS"]  = { L=124, text= "qs", tdx=8, tdy=3, exec1=      "qs", exec2=      "qs", tooltip="Quick-scan for current target (cp, quest, ht, qw)" },
--[[ 6 ]]	["hsQW"]  = { L=219, text= "qw", tdx=5, tdy=3, exec1=      "qw", exec2=     "qwx", tooltip="Left click = Quick-where\nRight click = Quick-where exact" },
--[[ 7 ]]	["hsHT"]  = { L=250, text= "ht", tdx=9, tdy=3, exec1=      "ht", exec2=     "hta", tooltip="Left click = Do hunt trick\nRight click = Cancel hunt trick" },
--[[ 8 ]]	["hsREF"] = { L=281, text="ref", tdx=6, tdy=3, exec1="xgui ref", exec2="xgui rel", tooltip="Left click = Refresh target list - cp (gq) check\nRight click = Reload target data - cp (gq) info" } }

	function draw_b1_action_buttons(left, top)
		local b1 = button_1_list
		for hs,b in pairs (b1) do
			draw_button_1_A(left+b.L, top, b.text, hs, b.tooltip, b.tdx, b.tdy)
		end
	end

	function load_images()
		if images_loaded then
			return
		end

		images_loaded = true
		local mime = require("mime")
		local gear_base64 = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAJPSURBVFhHtZeNNQQxEMeXCujgtgMq4CpABagAFXAV0AE6oAI6oAPXgevg/H97k7z9SDZz2N9787JfyUxmJpPsTrUly+XyWs2tZK950OVyNps92bWLXWu34UqSUg731rrJGqCZHjBbycweBXLKofNOffcyY0SSIVCHAzVvEgZcSc4kn5ILSWmWdwrDQmMc6/pRgvLVer2e13XNGB0GBvSU/ydJIzoGTKg8MDAiGmBx+pBMpTxASA8VpiU37SQkZlMrB3Sgq6FtwItkkCQTwMzfN5fDHMC6782dC9y5rddwf5xoqg4w6Bi8v5McSmoNxiRqyY2k1LdqK4e+ByizY+uczmchgfqYBwnlUfMgTVMn7LraMaXnElbBmDuZ3bw/gz5mBKspW/0EYyELDCDmnjh2LB9DY1IxqYJFyAFvEj1b64EwuMhuRn1ycU+hb3Gva0l7DShm92/xGsC2OpZUKVyhdYdAnFpbRMbyrctgDKCoeLi1JTaKfcOpqQRhfegXIooQdSHHuxJsbtcDTDljsAxzPEgWlqjJA0mpLtDxRgPEw6cp5iyBctox9oNy6HuAuH1t7lyEpVaqom3YP+KSjgbYLDgNlWbwV1DOjth4ob0KyNyplQPeijnSNsBdPv8IM49VMhpgLmGPnxJ08PcUT0SdQqQXWJYygo54yLMf8G1U0CIo73i6YwAkjAgd+TnxeIgzA7WCb+kLSeUwqAMBrQoSktPrizrGmZfqhL5tryzGOJG86nlyd8wakKNgwEqK9u3axSAEDiilObb6Na+qqvoBy3vRX8g9PVIAAAAASUVORK5CYII="

		-- local image_path = GetInfo(60) .. "images/gear_small.png"
		-- local f = io.open(image_path, "rb")
		-- local image_data = f:read("a*")
		-- local encoded
		-- f:close()
		-- encoded = mime.b64(image_data)
		-- Note("Base64:")
		-- Note(encoded)

		if not WindowLoadImageMemory(win, "gear", mime.unb64(gear_base64)) then
			ErrorNote("Image could not be decoded")
		end
	end

	function draw_settings_button(left, top, clicked)
		load_images()
		if images_loaded then
			local right = left + 36
			local bottom = top + 36
			local bgcolor = 0x000000
			local color_1 = 0xE0E0E0
			local color_2 = 0x808080

			if clicked then
				color_1, color_2 = color_2, color_1
			end

			WindowRectOp(win, 2, left, top, right, bottom, bgcolor, 0)
			WindowRectOp(win, 4, left, top, right, bottom, color_1, color_2)
			WindowDrawImageAlpha(win, "gear", left + 2, top + 2, right - 2, bottom - 2, 1, 0, 0)

			if (win_hotspots.config == nil) then
				-- Redoing the hotspot screws with mouseup actions so we'll leave the old one in place
				win_hotspots.config = WindowAddHotspot(win, "config", left, top, right, bottom,
					"", "", "config_mousedown", "config_mouseup", "config_mouseup_inside", "Settings", miniwin.cursor_arrow, 0)
			end
		end
	end

	function config_mousedown()
		local left = WindowHotspotInfo(win, "config", 1)
		local top = WindowHotspotInfo(win, "config", 2)
		draw_settings_button(left, top, true)
		Redraw()
	end

	function config_mouseup()
		local left = WindowHotspotInfo(win, "config", 1)
		local top = WindowHotspotInfo(win, "config", 2)
		draw_settings_button(left, top)
		Redraw()
	end

	function config_mouseup_inside()
		config_mouseup()
		right_click_menu()
	end


	function draw_button_1_A(L, T, text, hsName, tooltip, tdx, tdy, clicked)
		local x,y,w,z = L, T, L+30, T+25
		local tx,ty = (x+tdx), (y+tdy)	-- x and y values for text location
		local bgcolor = 0x000000
		local color_1 = 0xE0E0E0
		local color_2 = 0x808080
		local text_color = color_1

		if clicked then
			color_1, color_2 = color_2, color_1
		end

		WindowRectOp(win,2, x,y,w,z, bgcolor)													-- Draw background and set color (black)
		WindowRectOp(win,4, x,y,w,z, color_1, color_2)											-- Draw button border (left/top = light grey, right/bottom = darker grey)
		WindowText(win, "bt1", text, tx,ty,w-1,z-1, text_color, false)								-- Draw button text ("button" font, light grey)
		if (win_hotspots[hsName] == nil) then																-- Make button clickable by defining a hotspot
			win_hotspots[hsName] = WindowAddHotspot(win, hsName, x, y, w, z,							-- Hotspot name and location info
				"", "", "mousedown_b1", "cancelmousedown_b1", "mouseup_b1",				-- Mouse actions
				"" .. (tooltip or text), miniwin.cursor_arrow, 0)											-- Tooltip text, cursor shape (hand)
		end
	end

	local win_circle_readout_vars = {
			["cp"] 	 = { cc, cc1="r", cc2y="", tc1="", tc2="", tdx="", tdy="", text="" },
			["gq"] 	 = { cc1n="", cc2n="", cc1y="", cc2y="", tc1="", tc2="", tdx="", tdy="", text="" },
			["init"] = { cc1n="", cc2n="", cc1y="", cc2y="", tc1="", tc2="", tdx="", tdy="", text="" },
			["none"] = { cc1n="", cc2n="", cc1y="", cc2y="", tc1="", tc2="", tdx="", tdy="", text="" }, }


	--local win_circle_readout_colors = { g1=0x30C000, g2=0x004000, r1=0x0040F0, r2=0x000080, u1=0xC08800, u2=0x403000, v1=0xC000C0, v2=0x400040 }
	local win_circle_border_colors = { g={0x30C000,0x004000}, r={0x0040F0,0x000080}, u={0xC08800,0x403000}, v={0xC000C0,0x400040} }
	local win_circle_text_colors

	function draw_circle_readout(left, top)
		local level, ar_rm, get_new = cp_info_level, area_room_type, can_get_new_cp
		local activity = current_activity
		local width, height = 36, 36
		local cx1,cy1 = left+1, top+1; local cx2,cy2 = (cx1+width), (cy1+height)
		local g1,g2, r1,r2, u1,u2, v1,v2 = 0x30C000,0x004000, 0x0040F0,0x000080, 0xC08800,0x403000, 0xC000C0,0x400040	-- green, red, blue, violet
		local tdx, tdy = 6, 8
		local circle_color_1, circle_color_2, text_color, text
		local font = "circ1"
		if(activity == "cp") then
			circle_color_1 = (get_new == "yes") and g1 or r1; circle_color_2 = (get_new == "yes") and g2 or r2
			text_color_1 = 0xA0FFFF; text_color_2 = 0x0C1830
			text = tostring(level)
			local llen = string.len(text)
			--if (llen == 3) then tdx = 6
			if (llen == 2) then tdx = 10
			elseif (llen == 1) then tdx = 14
			end
		elseif (activity == "none") then
			circle_color_1 = (get_new == "yes") and g1 or r1; circle_color_2 = (get_new == "yes") and g2 or r2
			text_color_1 = (get_new == "yes") and 0x0050FF or 0x0070FF; text_color_2 = 0x000040
			text = "off"
		elseif (activity == "gq") then
			circle_color_1 = v1; circle_color_2 = v2
			text_color_1 = 0xA0FFFF; text_color_2 = 0x0C1830
			text = "gq"
			tdx = 10; tdy = 6
		elseif (activity == "init") then
			circle_color_1 = u1; circle_color_2 = u2
			text_color_1 = 0xB0B0B0; text_color_2 = 0x080808
			text = "init"
			font = "circ2"
			tdx = 4; tdy = 10
		end

		--if (ar_rm == "none") then	-- player not on cp
		--	circle_color_1 = (get_new == "yes") and g1 or r1
		--	circle_color_2 = (get_new == "yes") and g2 or r2
		--	text_color_1 = (get_new == "yes") and 0x0050FF or 0x0070FF
		--	text_color_2 = 0x000040
		--	tdx = 6
		--	tdy = 8
		--	text = "off"
		--elseif (ar_rm == "init") then		-- plugin is loading, no info yet
		--	circle_color_1 = u1
		--	circle_color_2 = u2
		--	text_color_1 = 0xB0B0B0
		--	text_color_2 = 0x080808
		--	tdx = 4
		--	tdy = 10
		--	text = "init"
		--	font = "circ2"				-- show "init" in circle while plugin installs
	--	else							-- player is on cp or gq
	--		if (current_activity == "gq") then
	--			circle_color_1 = v1
	--			circle_color_2 = v2
	--			text_color_1 = 0xA0FFFF
	--			text_color_2 = 0x0C1830
	--			text = "gq"
	--			tdx = 10
	--			tdy = 6
	--		elseif (current_activity == "cp") then
	--			circle_color_1 = (get_new == "yes") and g1 or r1
	--			circle_color_2 = (get_new == "yes") and g2 or r2
	--			text_color_1 = 0xA0FFFF
	--			text_color_2 = 0x0C1830
	--			text = tostring(level)
	--			local llen = string.len(text)
	--			if (llen == 3) then tdx = 6
	--			elseif (llen == 2) then tdx = 10
	--			elseif (llen == 1) then tdx = 14
	--			else
	--				tdx = 6
	--				text = "err"
	--			end
	--		end
	--	end
		WindowCircleOp(win, 1, cx1+1, cy1+1, cx2-1, cy2-1, circle_color_2, 0, 2, win_bgcolor, 1)	-- inner circle (dark)
		WindowCircleOp(win, 1, cx1-1, cy1-1, cx2+1, cy2+1, circle_color_2, 0, 2, win_bgcolor, 1)	-- outer circle (dark)
		WindowCircleOp(win, 1, cx1, cy1, cx2, cy2, circle_color_1, 0, 2, win_bgcolor, 1)			-- main circle (bright)
		local tx1,tx2, ty1,ty2 = (cx1+tdx),(cx2), (cy1+tdy),(cy2)
		WindowText(win, font, string.format("%s", text), tx1+1, ty1, tx2+1, ty2, text_color_2, false)		-- text shadow effect
		WindowText(win, font, string.format("%s", text), tx1+2, ty1+1, tx2+2, ty2+1, text_color_2, false)	-- text shadow effect
		WindowText(win, font, string.format("%s", text), tx1, ty1, tx2, ty2, text_color_1, false)			-- actual text and color
	end

	function draw_noexp_readout(left, top)
		WindowDeleteHotspot(win, "hs_noexp")
		local symbol = {
			{ x1= 0, y1= 0, x2=12, y2= 0, c0=0x30FF00, c1=0x0030FF, th=2 },		-- top bar
			{ x1= 0, y1= 3, x2=12, y2= 3, c0=0x000000, c1=0x0030FF, th=2 },		-- second bar
			{ x1= 7, y1= 6, x2= 7, y2=21, c0=0x303030, c1=0x00073F, th=1 },		-- shadow vertical
			{ x1= 6, y1= 6, x2= 6, y2=21, c0=0xC0C0C0, c1=0x0060FF, th=2 },		-- vertical
			{ x1= 0, y1=10, x2= 5, y2= 5, c0=0xC0C0C0, c1=0x0060FF, th=2 }, 	-- left diagonal
			{ x1=11, y1=10, x2= 6, y2= 5, c0=0xC0C0C0, c1=0x0060FF, th=2 } }	-- right diagonal
		local text_color_1 = 0xA0FFFF
		local text_color_2 = 0x0C1830
		local tooltip = "Left click: +100 \nRight click: -100"
		for i,v in ipairs (symbol) do
				local color = (noexp_onoff == "on") and v.c1 or v.c0
				WindowLine(win, left+v.x1,top+v.y1,left+v.x2,top+v.y2, color, 256, v.th)
		end
		if (anex_automatic_onoff == "on") then
			WindowText(win, "noexp", string.format("%s", anex_tnl_cutoff), left+18, top+4, left+62, top+21, text_color_2, false)
			WindowText(win, "noexp", string.format("%s", anex_tnl_cutoff), left+17, top+4, left+61, top+20, text_color_2, false)
			WindowText(win, "noexp", string.format("%s", anex_tnl_cutoff), left+16, top+3, left+60, top+20, text_color_1, false)
			--if (win_hotspots["hs_noexp"] == nil) then																-- Make button clickable by defining a hotspot
				win_hotspots["hs_noexp"] = WindowAddHotspot(win, "hs_noexp", left, top, left+55, top+25,							-- Hotspot name and location info
					"", "", "", "", "mouseup_noexp",				-- Mouse actions
					"" .. (tooltip), miniwin.cursor_arrow, 0)											-- Tooltip text, cursor shape (hand)
			--end
		else
			WindowText(win, "noexp2", string.format("%s", "manual"), left+17, top+4, left+61, top+21, text_color_2, false)
			WindowText(win, "noexp2", string.format("%s", "manual"), left+16, top+4, left+60, top+20, text_color_2, false)
			WindowText(win, "noexp2", string.format("%s", "manual"), left+15, top+3, left+59, top+20, text_color_1, false)
			--if (win_hotspots["hs_noexp"] == nil) then																-- Make button clickable by defining a hotspot
				win_hotspots["hs_noexp"] = WindowAddHotspot(win, "hs_noexp", left, top, left+55, top+25,							-- Hotspot name and location info
					"", "", "", "", "mouseup_noexp",				-- Mouse actions
					"" .. ("Noexp is manually off, type 'noexp' again to turn on"), miniwin.cursor_arrow, 0)
			--end
		end
	end

	function draw_resize_tag()
		local w = win_width
		local h = win_height
		local rts = 13
		local c1,c2 = 0x707070, 0xF0F0F0
		local x,y = w-4, h-4		-- bottom of resize widget tag
		for i=0,9,3 do
			WindowLine(win, x-(i+2), y, x+1, y-(i+3), c2, 0, 1)	-- dark lines
			WindowLine(win, x-i, y, x+1, y-(i+1), c1, 0, 1)	-- bright lines
		end
		WindowSetPixel (win, x, y, 0xF0F0F0)
		if (WindowHotspotInfo(win, "hsResize", 1) == nil) then
			WindowAddHotspot(win, "hsResize", w-rts, h-rts, win_width, h, "", "", "mousedown_resize_window", "", "", "", 6, 0)
			WindowDragHandler(win, "hsResize", "ResizeMoveCallback", "ResizeReleaseCallback", 0)
		else
			WindowMoveHotspot(win, "hsResize", w-rts, h-rts, 0, 0)
		end
	end

	function xg_show_target_links()
		for i,v in ipairs(win_target_hotspots) do
			WindowDeleteHotspot(win, v)
		end
		win_target_hotspots = {}
		if (win_state == "min") then return	end
		local list = main_target_list
		local font = "cplist"
		local resize_tag = 13
		local targ_list_top = 59
		local targ_list_bottom = win_height - 5
		local font_height = WindowFontInfo (win, font, 1)

		if xg_show_quest_target_link(targ_list_top, resize_tag, font) then
			targ_list_top = targ_list_top + font_height * 2
		end

		for index,v in ipairs (list) do
			if (((index-1) * font_height + targ_list_top) > targ_list_bottom) then break end		-- Abort loop if printed item would not be visible.
			local mob = v.mob .. ((v.is_dead == "yes") and " [Dead]" or "")
			local ar = v.arid
			local ct = v.link_type
			local location
			local eventHandler = "win_mouseup_target_link"
			if (ct == "area") then
				location = string.format("%s", ar)
			elseif (ct == "room") then
				location = string.format("'%s' (%s)", v.roomName, ar)
			elseif (ct == "unknown") then
				location = string.format("'%s' (unknown)", v.location)
				eventHandler = ""
			end
			local qty = ((player_on_gq == "yes") and v.qty .. "* " or "")
			local counts = ""
			if v.count_for_room and v.count_for_room > 1 then
				counts = string.format("(%i/%i) ", v.room_index, v.count_for_room)
			end
			local link = string.format("%2s) %s%s%s - %s", index, counts, qty, mob, location)
			local color = ColourNameToRGB(color_for_target(v, index == xcp_index))
			local hs_left = 6
			local hs_top = (targ_list_top + ((index-1) * font_height))
			local hs_right = math.min(hs_left + WindowTextWidth(win, font, link), win_width - 5)
			local hs_bottom = (hs_top + font_height + 1)
			if v.unlikely then
				local added_width = WindowTextWidth(win, font, "(Unlikely) ")
				WindowText(win, font, "(Unlikely) ", 6, hs_top, 0, 0, ColourNameToRGB(text_colors.unlikely_tag), false)
				hs_left = hs_left + added_width
				hs_right = math.min(hs_right + added_width, win_width - 5)
			end
			WindowText(win, font, link, hs_left, hs_top, 0, 0, color, false)
			if (hs_bottom > win_height - resize_tag) then		-- Prevent list item's hotspot from overlapping with the resize tag
				hs_right = math.min(hs_right, win_width - resize_tag - 5)
			end
			table.insert(win_target_hotspots, index)
			--WindowRectOp (win, 1,
			--				hs_left-1, hs_top+2, hs_right+2, hs_bottom, 0x000080, 15)
			WindowAddHotspot(win, index,
							hs_left-1, hs_top+2, hs_right+2, hs_bottom,		-- hotspot boundary rectangle
							"", "", "", "",								-- "mouseover", "cancelmouseover", "mousedown", "cancelmousedown"
							eventHandler, "", miniwin.cursor_arrow, 0)	-- "mouseup", tooltip, cursor type
		end
	end

	function is_cp_or_gq_mob_targeted()
		return xcp_index > 0 and main_target_list[xcp_index]
	end

	function is_quest_mob_targeted()
		if not has_active_quest() then
			return false
		elseif xcp_index > 0 then
			return false
		else
			return full_mob_name == quest_target.mob
		end
	end

	function has_target()
		return is_quest_mob_targeted() or is_cp_or_gq_mob_targeted()
	end

	function has_activity()
		return has_active_quest() or has_active_cp_or_gq()
	end

	function has_active_quest()
		return quest_target.qstat == "2"
	end

	function has_active_cp_or_gq()
		return #main_target_list > 0
	end

	function xg_show_quest_target_link(targ_list_top, resize_tag, font)
		if not quest_target.qstat or quest_target.qstat == "1" then
			return false
		end

		local text
		local color
		local hs_left, hs_top, hs_right, hs_bottom

		if quest_target.qstat == "0" then
			text = " You may now quest again"
			color = text_colors.quest_available
		elseif has_active_quest() then
			color = is_quest_mob_targeted() and text_colors.targeted or text_colors.normal
			text = string.format(" Q) %s - '%s' (%s)", quest_target.mob, quest_target.room, quest_target.arid)
		elseif quest_target.qstat == "3" then
			text = " Quest complete! You may turn it in"
			color = text_colors.quest_complete
		else
			return false
		end

		hs_left = 6
		hs_top = targ_list_top
		hs_right = math.min(hs_left + WindowTextWidth(win, font, text), win_width - 5)
		hs_bottom = (hs_top + WindowFontInfo(win, font, 1) + 1)
		if (hs_bottom > win_height - resize_tag) then
			hs_right = math.min(hs_right, win_width - resize_tag - 5)
		end

		WindowText(win, font, text, hs_left, hs_top, 0, 0, ColourNameToRGB(color), false)

		if has_active_quest() then
			table.insert(win_target_hotspots, 'q')
			WindowAddHotspot(win, 'q',
							hs_left-1, hs_top+2, hs_right+2, hs_bottom,
							"", "", "", "",
							"win_mouseup_target_quest", "", miniwin.cursor_arrow, 0)
		end
		if #main_target_list > 0 then
			local font_height = WindowFontInfo(win, font, 1)
			local space_width = WindowTextWidth(win, font, " ")
			hs_top = math.floor(hs_top + font_height * 1.5)
			WindowRectOp(win, 2, hs_left + space_width, hs_top, hs_right, hs_top + 2, "0x808080")
		end
		return true
	end

-- [[ GUI window mouse click functions (buttons, links, etc.) ]]
	function mouseup_b1(flags, hotspot_id)	-- when mouse button is released, redraw the buttons to normal appearance.
		local b = button_1_list[hotspot_id]
		local click = ((bit.band(flags, 0x20) == 0) and "L" or "R")
		local left = WindowHotspotInfo(win, hotspot_id, 1)
		local top = WindowHotspotInfo(win, hotspot_id, 2)
		draw_button_1_A(left, top, b.text, hotspot_id, b.tooltip, b.tdx, b.tdy)
		Redraw()
		Execute(((click == "L") and b.exec1 or b.exec2))
	end

	function mousedown_b1(flags, hotspot_id)	-- when mouse button is pressed:
		local b = button_1_list[hotspot_id]
		local click = ((bit.band(flags, 0x20) == 0) and "L" or "R")
		local left = WindowHotspotInfo(win, hotspot_id, 1)
		local top = WindowHotspotInfo(win, hotspot_id, 2)
		draw_button_1_A(left, top, b.text, hotspot_id.."2", "", b.tdx, b.tdy, true)
		Redraw()
	end

	function cancelmousedown_b1(flags, hotspot_id)
		local b = button_1_list[hotspot_id]
		local click = ((bit.band(flags, 0x20) == 0) and "L" or "R")
		local left = WindowHotspotInfo(win, hotspot_id, 1)
		local top = WindowHotspotInfo(win, hotspot_id, 2)
		draw_button_1_A(left, top, b.text, hotspot_id, b.tooltip, b.tdx, b.tdy)
		Redraw()
	end

	function mousedown_resize_window(flags, hotspot_id)
	if (hotspot_id == "hsResize") then
		startx, starty = WindowInfo (win, 17), WindowInfo (win, 18)
	end
	end

	function mouseup_noexp(flags)
		local f = flags
		local hs = "hs_noexp"
		local click = ((bit.band(f, 0x20) == 0) and "L" or "R")
		if (anex_automatic_onoff == "on") then
			if (click == "L") then
				anex_tnl_cutoff = anex_tnl_cutoff + 100
				if (anex_tnl_cutoff > 9900) then anex_tnl_cutoff = 9900 end
			elseif (click == "R") then
				anex_tnl_cutoff = anex_tnl_cutoff - 100
				if (anex_tnl_cutoff < 0 ) then anex_tnl_cutoff = 0 end
			else
				-- do nothing
			end
			SetVariable("mcvar_anex_tnl_cutoff", anex_tnl_cutoff)
			anex_check_tnl_silent()
			xg_draw_window()
		end
	end

	function mousedown_drag(flags, hotspot_id)
		win_dragmove_start_x = WindowInfo(win, 14)
		win_dragmove_start_y = WindowInfo (win, 15)
	end

	function mouseup_drag(flags, hotspot_id)
		local f = flags
		local click = ((bit.band(f, 0x20) == 0) and "L" or "R")
		if (hotspot_id == "hsDrag1") then
			if (click == "R") then
				right_click_menu()
			end
		end
	end

	function win_mouseup_target_link(flags, hotspot_id)
		if (tonumber(hotspot_id) ~= nil) then
			xcp_arg("", "", {index=hotspot_id})
		end
	end

	function win_mouseup_target_quest()
		target_quest_mob(true)
		xg_draw_window()
	end

--	[[ Window dragging / moving ]]
	function dragmove(flags, hotspot_id)
		if (bit.band(flags, 0x20) == 0) then
			win_pos_x = WindowInfo(win, 17) -- - 50
			win_pos_y = WindowInfo(win, 18) -- - 7
			local delta_x = win_pos_x - win_dragmove_start_x
			local delta_y = win_pos_y - win_dragmove_start_y
			local max_x = GetInfo(281) - 100
			local max_y = GetInfo(280) - 60
			if (delta_x <= 1) then 			-- Prevents window from leaving the screen.  The bug that got me started on all this.
				delta_x = 1
			elseif (delta_x >= max_x) then
				delta_x = max_x
			end
			if (delta_y <= 1) then
				delta_y = 1
			elseif (delta_y >= max_y) then
				delta_y = max_y
			end
			WindowPosition(win, delta_x, delta_y, miniwin.pos_stretch_to_view, miniwin.create_absolute_location) -- move window to new location
		else
			return
		end
	end

	function dragrelease(flags, hotspot_id)
	--  print ("mouse drag release for " .. hotspot_id)
	--  print ("released at position", WindowInfo (win, 17), WindowInfo (win, 18))
	end

--	[[ Window resize functions ]]

	local lastRefresh = 0

	function ResizeMoveCallback()
		local screen_width = GetInfo(281) - 100
		local screen_height = GetInfo(280) - 60
		if (GetPluginVariable("c293f9e7f04dde889f65cb90", "lock_down_miniwindows") == "1") then
			return
		end
		local x, y = WindowInfo (win, 17), WindowInfo (win, 18)
		win_width = win_width + x - startx
		startx = x
		if (win_width < win_width_min) then
			win_width = win_width_min
			startx = windowinfo.window_left+win_width
		elseif (win_width > screen_width) then
			win_width = screen_width
			startx = windowinfo.window_left+win_width
		end
		win_height = win_height + y - starty
		starty = y
		if (win_height < win_height_min) then
			win_height = win_height_min
			starty = windowinfo.window_top+win_height
		elseif (win_height > screen_height) then
			win_height = screen_height
			starty = windowinfo.window_top+win_height
		end
		WindowResize(win, win_width, win_height, win_bgcolor)
		local freq = 90
		local t = utils.timer()
		if ((t - lastRefresh) > (1/freq)) then	-- redraw rate while resizing (per second)
			xg_draw_window()
			lastRefresh = t
		end
	end

	function ResizeReleaseCallback()
		win_state = "max"
		w = win_width
		h = win_height
		WindowDeleteHotspot(win, "hsDrag1")
		win_hotspots["hsDrag1"] = WindowAddHotspot(win, "hsDrag1", 0, 0, w-1, 16, -- hotspot id, rectangle (left, top, right, bottom)
					"", "", "mousedown_drag", "", "mouseup_drag", --mouseover, cancelmouseover, mousedown_drag, cancelmousedown, mouseup_drag
					"Left click = Drag title bar to move\nRight click = Send window to front/back", miniwin.cursor_arrow, 0)
		WindowDragHandler(win, "hsDrag1", "dragmove", "dragrelease", 0)
		xg_draw_window()
	end

--	[[ Window right click menu]]
	function right_click_menu()
		local color_options = {}
		for i, details in ipairs(TEXT_COLOR_DETAILS) do
			if details.key == "quest_available" or details.key == "alternating_row" then
				table.insert(color_options, "-")
			end
			table.insert(color_options, details.menu_name)
		end
		table.insert(color_options, "-")
		table.insert(color_options, "Reset to Defaults")

		local hide_settings = "Hide Settings Button"
		if win_hide_settings_button == "on" then
			hide_settings = "+" .. hide_settings
		end

		local menu_options = {
			"Change Font",
			">Change Colors",
			table.concat(color_options, "|"),
			"<",
			"-",
			"Bring To Front",
			"Send To Back",
			"Collapse Window",
			"Expand Window",
			"-",
			hide_settings,
			"Check for Updates",
			"Changelog",
			"Help",
		}
		result = WindowMenu (win,
			WindowInfo (win, 14),		-- x position
			WindowInfo (win, 15),		-- y position
			table.concat(menu_options, "|"))					-- content

		if result == "Change Font" then
			local new_font = utils.fontpicker(win_font, win_font_size, 0)
			if new_font == nil then return end

			win_font = new_font.name
			win_font_size = new_font.size
			win_font_bold = new_font.bold
			win_font_italic = new_font.italic
			win_font_underline = new_font.underline

			WindowFont(win, "cplist", win_font, win_font_size, win_font_bold, win_font_italic, win_font_underline, false)

			SetVariable("mcvar_window_font", win_font)
			SetVariable("mcvar_window_font_size", win_font_size)
			SetVariable("mcvar_window_font_bold", win_font_bold)
			SetVariable("mcvar_window_font_italic", win_font_italic)
			SetVariable("mcvar_window_font_underline", win_font_underline)

			xg_draw_window()
			InfoNote("Window font changed to ", string.format("%s Size %i (%s)", win_font, win_font_size, new_font.style))
		elseif (result == "Bring To Front") then
			CallPlugin(plugin_id_z_order,"boostMe", win)
		elseif (result == "Send To Back") then
			CallPlugin(plugin_id_z_order,"dropMe", win)
		elseif (result == "Collapse Window") then
			win_state = "min"
			win_height = win_height_min
			WindowResize(win, win_width, win_height, ColourNameToRGB("black"))
			xg_draw_window()
			Redraw()
		elseif (result == "Expand Window") then
			win_state = "max"
			win_height = win_height_max
			WindowResize(win, win_width, win_height, ColourNameToRGB("black"))
			xg_draw_window()
		elseif result == "Check for Updates" then
			Note("Check for updates...")
			force_update_check(true)
		elseif result == "Reset to Defaults" then
			for i, details in ipairs(TEXT_COLOR_DETAILS) do
				text_colors[details.key] = details.default
				SetVariable("color_" .. details.key, details.default)
			end
			Note("All colors reset to default values.")
			xg_draw_window()
		elseif result == "Hide Settings Button" then
			if win_hide_settings_button == "off" then
				win_hide_settings_button = "on"
				InfoNote("\nSettings button will be ", "hidden", ". You can still access settings by right clicking on the title bar.")
			else
				win_hide_settings_button = "off"
				InfoNote("\nSettings button will be ", "shown")
			end
			SetVariable("mcvar_window_hide_settings_button", xcp_targets_quest_onoff)

			clear_window_menu_hotspots()
			xg_draw_window()
		elseif result == "Help" then
			Execute("xhelp")
		elseif result == "Changelog" then
			--show_changelog(true)
			get_changelog(true)
		elseif result == nil or result == "" then
			return
		else
			local color_details
			for i, details in ipairs(TEXT_COLOR_DETAILS) do
				if details.menu_name == result then
					color_details = details
					break
				end
			end
			if not color_details then
				ErrorNote("Invalid menu option ", result, ". How did you even do that?")
				return
			end
			local new_color = PickColour(ColourNameToRGB(text_colors[color_details.key]))
			if new_color == nil or new_color == -1 then
				return
			end

			new_color = RGBColourToName(new_color)
			text_colors[color_details.key] = new_color
			SetVariable("color_" .. color_details.key, new_color)
			if color_details.key == "alternating_row" then
				ColourNote("white", new_color, string.format("This is now color for %s.", color_details.desc))
			else
				ColourNote(new_color, "", string.format("This is now color for %s.", color_details.desc))
			end
			xg_draw_window()
		end
	end

	function xgui_RefreshLinks()
		if current_activity == "gq" then
			do_gq_check()
		else
			do_cp_check()
		end
		mouseup_drag(0, "hsMaximize")
	end

	function xgui_ReloadLinks()
		if current_activity == "gq" then
			do_gq_info()
		else
			do_cp_info()
		end
		mouseup_drag(0, "hsMaximize")
	end

	function xset_ToggleWindowDisplay(name, line, wildcards)
		local arg = wildcards.onoff
		if (arg == "on") or (arg == "show") or (arg == "1") then
			WindowShow(win, true)
			SetVariable("mcvar_xgui_window_onoff", "on")
		elseif (arg == "off") or (arg == "hide") or (arg == "0") then
			WindowShow(win, false)
			SetVariable("mcvar_xgui_window_onoff", "off")
		else
			if (arg == "max") or (arg == "maximize") or (arg == "expand") then
				win_state = "max"
				win_height = win_height_max
			elseif (arg == "min") or (arg == "minimize") or (arg == "collapse") then
				win_state = "min"
				win_height = win_height_min
			end

			WindowResize(win, win_width, win_height, ColourNameToRGB("black"))
			xg_draw_window()
			Redraw()
		end
	end

	function deprecated_xset_font_size()
		InfoNote("Changing font size is now done by right clicking on the title bar of the targets window and choosing 'Change Font'\n")
	end

	function deprecated_xset_line_space(name, line, wildcards)
		InfoNote("Line spacing is automatically picked up from the font which can be changed by right clicking on the title bar of the targets window and choosing 'Change Font'\n")
	end

	function OnPluginSaveState()
		movewindow.save_state(win)	-- save window location
		if WindowInfo(win, 3) and WindowInfo(win, 4) then
			win_width = WindowInfo(win, 3)
			win_height = WindowInfo(win, 4)
		end
		SetVariable("mcvar_window_pos_x", win_pos_x)
		SetVariable("mcvar_window_pos_y", win_pos_y)
		SetVariable("mcvar_window_state", win_state)
		SetVariable("mcvar_window_width", win_width)
		SetVariable("mcvar_window_height", win_height)
		SetVariable("mcvar_window_width_max", win_width_max)
		SetVariable("mcvar_window_height_max", win_height_max)
	end

	function OnPluginClose()
		OnPluginSaveState()
		WindowShow(win, false) 			-- hide window, refresh screen
	end

	function set_speed(name, line, wildcards)
		if (wildcards.speed ~= "") then
			speed = wildcards.speed
		else
			if (speed == "walk") then
				speed = "run"
			else
				speed = "walk"
			end
		end
		InfoNote("Move speed:", speed)
	end

-- Internal Utilities
	--function copytable(t)
	--	local new_t = {}
	--	table.foreachi(t,
	--		function (k, v)
	--			table.insert (new_t, v)
	--		end)
	--	return new_t
	--end

	function dbcheck(code, query)
		if (code ~= sqlite3.OK) and    -- no error
		(code ~= sqlite3.ROW) and   -- completed OK with another row of data
		(code ~= sqlite3.DONE) then -- completed OK, no more rows
			local err = db:errmsg ()  -- the rollback will change the error message
			err = err.."\n\nCODE: "..code.."\nQUERY: "..query.."\n"
			db:exec("ROLLBACK")      -- rollback any transaction to unlock the database
			error (err, 2)            -- show error in caller's context
		end
	end

	function fixsql(s)
		if s then
			return "'" .. (string.gsub (s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
		else
			return "NULL"
		end
	end

	function gmcp(s)
	local ret, datastring = CallPlugin(plugin_id_gmcp_handler, "gmcpdata_as_string", s)
	pcall(loadstring("data = "..datastring))
	return data
	end

	function send_gmcp_packet(s)
	CallPlugin(plugin_id_gmcp_handler, "Send_GMCP_Packet", s)
	end

	function int(n)
		if not tonumber(n) then
			return
		else
			return math.floor(n)
		end
	end

	function md5(s)
		local hash = utils.tohex(utils.md5(tostring(s)))
		return hash
	end

	function quote(text)
		return "\""..text.."\""
	end

	function round_banker(x)		-- round normally, but when number ends in exactly .5 round to nearest even value.
	if (x == 0) then return 0 end	-- prevent returning -0
	if (x + 0.5) % 2 == 0 then
		return math.floor(x + 0.5)
	else
		return math.ceil(x - 0.5)
	end
	end

	function rtrim(s)
		local n = #s
		while n > 0 and s:find("^%s", n) do n = n - 1 end
		return s:sub(1, n)
	end

	function sanitize_filename(str)
		str = string.gsub(str, "[^%w%s()_-]", "")
		return str
	end

	function spairs(t, f)
		local tbl = {}
		for n in pairs(t) do
			table.insert(tbl, n)
		end
		table.sort(tbl, f)
		local i = 0      -- iterator variable
		local iter = function ()   -- iterator function
			i = i + 1
			if (tbl[i] == nil) then
				return nil
			else
				return tbl[i], t[tbl[i]]
			end
		end
		return iter
	end

	function split(line, delim)
		local result = {}
		local index = 1
		for token in string.gmatch(line, delim) do
			result[index] = token
			index = index + 1
		end
		return result
	end

	function trim(s)
		return s:match'^()%s*$' and '' or s:match'^%s*(.*%S)'
	end

	function tier_level()
		local l = tonumber(gmcp("char.status.level"))
		local t = tonumber(gmcp("char.base.tier"))
		return (l + 10*t)
	end


-- [[ Random stuff that doesn't fit anywhere else (?) ]]
	function xtest_roomhist()
		ColourNote("#00FFFF", "", "\ni: 0    r: " .. string.format("%-5s", room_history[0].rmid) .. "  a: " .. room_history[0].arid)
		for i,v in ipairs (room_history) do
			print("i: " .. string.format("%-3s", i) .. "  r: " .. string.format("%-5s", v.rmid) .. "  a: " .. string.format("%-10s", v.arid))
		end
		print("")
	end

	function xtest_areadata()
		local db = assert(sqlite3.open(mapper_db_file))
		local sql = "SELECT uid, name FROM areas"
		local ar = { }
		local dasr = areaDefaultStartRooms	-- default start rooms
		local xasr = area_start_rooms	-- xset marked start rooms
		local alr = area_range_index	-- area level range table
		--local worldPath = GetInfo(66) .. "/worlds/plugins/"
		--local db = assert(sqlite3.open(worldPath .. "sddb.db"))
		local index = 0
		ColourNote("#00C040", "", "\nrunning sql: " .. sql)
		for row in db:nrows(sql) do
			index = index + 1
			local a = row.uid
			local an = row.name
			local q = (dasr[a].noquest == true) and "0" or "1"
			local d = dasr[a].start
			local c = (xasr[a] ~= nil) and ((xasr[a].roomid ~= d) and xasr[a].roomid or "-1") or "-1"
			ar[index] = { arid=a, area_name=an, def_startroom=d, cur_startroom=c, questable=q, minlvl="-1", maxlvl="-1", lock="-1" }
		end
		db:close_vm()
		for i,v in ipairs (ar) do
			local a = v.arid
			local an = v.area_name
			if (alr[an] ~= nil) then
				v.minlvl = alr[an].min
				v.maxlvl = alr[an].max
			end
		end
		--	if (dasr[v.arid].noquest == true) then
		--		v.questable = "0"
		--	else
		--		v.questable = "1"
		--	end
		--end
		--tprint(ar)
		--tprint(area_start_rooms)
		--tprint(alr)
	end

	function xtest_mcvars()
		local t = GetVariableList()
		tprint(t)
	end

	function xmap_rooms_linking_here(name, line, wildcards)
		local room_id = tonumber(wildcards.room_id) or tonumber(current_room.rmid) or -1
		local r1 = {}
		local list = {}
		local Q1 = string.format("SELECT uid, name, area FROM rooms WHERE uid = %s ", fixsql(room_id))
		local Q2 = string.format("SELECT exits.dir as edir, exits.fromuid as efrom, exits.touid as eto, rooms.name as name, rooms.area as arid FROM exits,rooms WHERE exits.touid = %s AND rooms.uid = exits.fromuid ORDER BY efrom ASC ", fixsql(room_id), fixsql(room_id))
		local db = assert(sqlite3.open(mapper_db_file))
		for row in db:nrows(Q1) do
			r1 = { rmid = row.uid, arid = row.area, roomname = row.name }
		end
		for row in db:nrows(Q2) do
			local ru = string.format("%5s", row.efrom)
			list[ru] = {
				roomname = row.name,
				arid = row.arid,
				exit_dir = row.edir, }
		end
		db:close_vm()
		print("\n" .. "Rooms linking to " .. r1.rmid .. ": " .. r1.roomname .. " (" .. r1.arid .. ")" .. "\n")
		for k,v in spairs (list) do
			print(k .. ": " .. v.roomname .. " (" .. v.arid .. ") - " .. v.exit_dir)
		end
		print("")
	end

	function xtest_loadroom(name, line, wildcards)
		local ri = current_room
		local room_id = tonumber(wildcards.room_id) or tonumber(ri.rmid) or -1
		local roomdata = {}
		local sql_roomdata = "SELECT uid, name, area, info, noportal, norecall, ignore_exits_mismatch " .. "FROM rooms " .. "WHERE uid = %s "
		local sql_exitrow = "SELECT dir, fromuid, touid, level " .. "FROM exits " .. "WHERE fromuid = %s "
		local sel_roomdata = string.format(sql_roomdata, fixsql(room_id))
		local sel_exits = string.format(sql_exitrow, fixsql(room_id))
		local db_results_found = false
		local db = assert(sqlite3.open(mapper_db_file))
		for row in db:nrows(sel_roomdata) do
			roomdata = {
				roomid = row.uid,
				roomname = row.name or "-no room name-",
				arid = row.area or "-no area-",
				--building = row.building,
				--terrain = row.terrain,
				info = row.info or "-no info-",
				--notes = row.notes,
				--x = row.x or 0,
				--y = row.y or 0,
				--z = row.z or 0,
				noportal = row.noportal or 0,
				norecall = row.norecall or 0,
				exits = {},
				exit_locks = {},
				ig_ex_mis = (row.ignore_exits_mismatch == 1)
				}
			for exitrow in db:nrows(sel_exits) do
				roomdata.exits[exitrow.dir] = tostring(exitrow.touid)
				roomdata.exit_locks[exitrow.dir] = tostring(exitrow.level)
			end -- for each ex
		end
		db:close_vm()

		if not (roomdata.roomid) then
			roomdata = {
				roomid = tostring(room_id),
				roomname = "-1",
				arid = "-1",
				info = "none",
				noportal = 0,
				norecall = 0,
				exits = {},
				exit_locks = {},
				ig_ex_mis = false
				}
		end
		table.insert(xtest_loadroom_table, roomdata)
		tprint(xtest_loadroom_table)
		print("")
	end

	function xtest_popmsg(name, line, wildcards)

	end

	function xtest_debug(name, line, wildcards)
		if debug_mode == "on" then
			InfoNote("Debug mode ", "disabled\n")
			debug_mode = "off"
		else
			InfoNote("Debug mode ", "enabled\n")
			debug_mode = "on"
		end
		SetVariable("debug_mode", debug_mode)
	end

	function InfoNote(...)
		print_alternating_note({...}, NOTE_COLORS.INFO, NOTE_COLORS.INFO_HIGHLIGHT)
	end

	function ErrorNote(...)
		print_alternating_note({...}, NOTE_COLORS.ERROR, NOTE_COLORS.ERROR_HIGHLIGHT, NOTE_COLORS.ERROR_BACKGROUND)
	end

	function ImportantNote(...)
		print_alternating_note({...}, NOTE_COLORS.IMPORTANT, NOTE_COLORS.IMPORTANT_HIGHLIGHT, NOTE_COLORS.IMPORTANT_BACKGROUND)
	end

	function DebugNote(...)
		if debug_mode == "on" then
			ColourTell(NOTE_COLORS.DEBUG_HIGHLIGHT, "", "DEBUG: ")
			print_alternating_note({...}, NOTE_COLORS.DEBUG, NOTE_COLORS.DEBUG_HIGHLIGHT)
		end
	end

	function print_alternating_note(messages, regular_color, highlight_color, background)
		local current_color, other_color = regular_color, highlight_color
		background = background or ""

		for i, message in ipairs(messages) do
			ColourTell(current_color, background, message)
			current_color, other_color = other_color, current_color
		end
		print("")
	end

-- [[ New code ]]
	function update_plugin()
		DebugNote("Checking version to see if it should update itself")
		download_version_file(do_update, true)
	end

	function force_update_plugin(name, line, wildcards)
		local branch = "master"

		if wildcards.branch ~= "" then
			branch = wildcards.branch
		end

		DebugNote("Forcing update from ", branch)
		download_plugin(branch, callback_update_plugin)
	end

	function check_for_updates()
		if automatic_update_checks ~= "on" then
			return
		elseif GetInfo(304) >= last_update_check + UPDATE_CHECK_INTERVAL then
			force_update_check()
		end
	end

	function force_update_check(log_no_updates)
		DebugNote("Checking if there's an updated version available")
		last_update_check = GetInfo(304)
		download_version_file(show_update_banner, log_no_updates)
	end

	function download_plugin(version, callback)
		DebugNote("Downloading plugin version ", version)
		local url = string.format(pluginURL, version)
		download_file(url, callback)
	end

	function download_version_file(callback, log_no_updates)
		DebugNote("Attempting to download master")
		local url = versionURL
		download_file(url, check_version_callback(callback, log_no_updates))
	end

	function download_file(url, callback)
		DebugNote("Starting download of ", url)

		if async_ok then
			plugin_page = async.doAsyncRemoteRequest(url, callback, "HTTPS")
		else
			ImportantNote("Error on file download")
		end
	end

	function check_version_callback(callback, log_no_updates)
		return function(retval, page, status, headers, full_status, request_url)
			if status ~= 200 then
				DebugNote("check_version_callback got ", status)
				if log_no_updates then
					ErrorNote("Error while fetching latest version number")
				end
				return
			end
			local upstream_version = Trim(page)
			if upstream_version ~= tostring(PLUGIN_VERSION) then
				callback(upstream_version)
			elseif log_no_updates then
				InfoNote("Search&Destroy: No new updates available")
			end
		end
	end

	function do_update(version)
		DebugNote("Attempting to do_update with version ", version)
		download_plugin("v" .. version, callback_update_plugin)
	end

	function callback_update_plugin(retval, page, status, headers, full_status, request_url)
		if status ~= 200 then
			DebugNote("callback_update_plugin got ", status)
			ErrorNote("Error while fetching latest plugin version")
			return
		end
		local upstream_version = tonumber(string.match(page, '<plugin version="([0-9%.]+)"'))
		ImportantNote("Updating from version ", PLUGIN_VERSION, " to ", upstream_version, ". Do not touch anything!")
		local file = io.open(GetPluginInfo(GetPluginID(), 6), "w")
		file:write(page)
		file:close()
		if "" == GetAlphaOption("script_prefix") then
			SetAlphaOption("script_prefix", "\\\\\\")
		end
		Execute(GetAlphaOption("script_prefix") .. "DoAfterSpecial(1, \"ReloadPlugin('" .. GetPluginID() .. "')\", sendto.script)")
		ImportantNote("Update complete!")
	end -- end Update code

	function show_update_banner(upstream_version)
		ColourNote(NOTE_COLORS.INFO, "", "\n+=================================================================+")
		ColourNote("silver", "", "              Search & Destroy ",
			"lime", "", "New Version Available")
		print("")
		ColourNote("silver", "", "             Current version: ",
			"tomato", "", PLUGIN_VERSION,
			"silver", "", " Latest version: ",
			"lime", "", upstream_version)
		print("")
		ColourNote("silver", "", "         Use ", "lime", "", "snd update", "silver", "", " to upgrade to the latest version.")
		print("")
		ColourNote("silver", "", "     Use ", "tomato", "", "snd check_update", "silver", "", " to disable automatic version checks.")
		ColourNote(NOTE_COLORS.INFO, "", "+=================================================================+\n")
	end

	function toggle_automatic_update_checking()
		if automatic_update_checks == "on" then
			automatic_update_checks = "off"
			EnableTimer("update_check_tick", false)
		else
			automatic_update_checks = "on"
			force_update_check()
			EnableTimer("update_check_tick", true)
		end
		SetVariable("mcvar_automatic_update_checks", automatic_update_checks)


		InfoNote("\nSearch&Destroy automatic update checking is now ", string.upper(automatic_update_checks))
	end

	function download_sounds(callback)
		local download_path = soundsURL
		local sounds = {
			other_target_here_sound,
			target_nearby_sound,
		}
		--local async_ok, async = pcall (require, "async")
		local file
		local files_to_download = {}

		if async_ok then
			for i, filename in ipairs(sounds) do
				file = io.open(GetInfo(74) .. filename)
				if file then
					file:close()
				else
					table.insert(files_to_download, filename)
				end
			end

			local callbacks_required = #files_to_download
			local all_downloads_successful = true
			function callbackWrapper(success)
				all_downloads_successful = all_downloads_successful and success
				callbacks_required = callbacks_required - 1
				if callbacks_required == 0 then
					callback(all_downloads_successful)
				end
			end

			for i, filename in ipairs(files_to_download) do
				ImportantNote("Downloading ", filename)
				async.doAsyncRemoteRequest(string.format(download_path, filename), download_sounds_callback(filename, callbackWrapper), "HTTPS")
			end

			if #files_to_download == 0 then
				callback(true)
			end
		else
			ErrorNote("Error downloading sounds: async could not be initialized.")
			callback(false)
		end
	end

	function download_sounds_callback(filename, callback)
		return function(retval, page, status, headers, full_status, request_url)
			if status == 200 then
				local file = io.open(GetInfo(74) .. filename, "wb")
				file:write(page)
				file:close()
				Note(string.format("Wrote %s successfully to sounds directory", filename))
				callback(true)
			else
				ErrorNote("Couldn't download ", filename)
				DebugNote("HTTP Status: ", status)
				DebugNote("Full status: ", full_status)
				DebugNote("Headers: ", require('json').encode(headers))
				if page and #page > 200 then
					if debug_mode == "on" then
						SetClipboard(page)
					end
					DebugNote("Page data was too large for display and has been save to the clipboard")
				else
					DebugNote("Page: ", page)
				end
				callback(false)
			end
		end
	end

	function helpWrap (str, limit, indent, indent1)
		indent = indent or ""
		indent1 = indent1 or indent
		limit = limit or 76
		local here = 1-#indent1
		local lastColor = ''
		return indent1 .. str:gsub("(%s+)()(%S+)()",
							function(sp, st, word, fi)
								local delta = 0
								here = here + delta
								if fi-here > limit then
									here = st - #indent + delta
									return "\n" .. word
								end
							end)
	end

	function onHelp(name, line, wildcards)
		local str = wildcards[1]
		local helpFiles = {
			"win",
			"speed",
			"vidblain",
			"mark",
			"index areas",
			"silent",
			"xm|xmall|rlh",
			"xmap",
			"roomnote",
			"qw",
			"ht",
			"ah",
			"ak|kk|qk",
			"qs",
			"xq",
			"xqt",
			"noexp",
			"kw|keyword",
			"nx",
			"go",
			"xset nx",
			"xset con_overwrite",
			"sound",
			"xrt|xrun",
			"cp|gq",
			"xcp",
			"xcp mode",
			"quest|xcp quest",
			"ms|msearch|xms|xmsearch",
			"mgo|mgoto|xmgo|xmgoto",
			"snd migrate|mergePwar",
			"snd update",
			"snd reload",
			"snd check_update",
			"snd changelog",
			"summary",
		}


		local headers = {"cyan",
			"", string.rep("-", 76) .. "\n", "darkcyan", "", "Help keywords", "antiquewhite", "", " : " .. str .. "\n", "cyan", "", string.rep("-", 76) .. "\n"}

		ColourNote(unpack(headers))

		if str == "" or "" == nil or str == "xhelp" then
			ColourNote("darkcyan", "", "Plugin name    ", "antiquewhite", "", " : Search & Destroy")
			ColourNote("darkcyan", "", "Maintained by  ", "antiquewhite", "", " : Crowley and Naricain")
			ColourNote("darkcyan", "", "Original Author", "antiquewhite", "", " : WinkleWinkle")
			ColourNote("darkcyan", "", "Credit to      ", "antiquewhite", "", " : Nokfah and Starling")
			Note()
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xhelp <command> (to view helpfiles below)")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Search & Destroy is a quality-of-life tool. It utilizes the mapper plugin in order to get to your quest mobs faster, your campaign targets faster, and yes, even global quest mobs. It makes every attempt to load up the keyword into an alias so all you have to do is type the alias and enter. It presents a window that displays your campaign or global targets (and eventually will show quest targets, perhaps tabbed). It uses its own runto feature in order to run to your personally chosen 'start' room of the area. To clarify, there are no 'start' rooms to any area. It's why the mapper plugin cannot just run you to an area because you tell it to.")}))
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("In short, it can speed up your quests/campaigns/global quests. It is NOT, however, a bot as some may claim.")}))
			Note()
			ColourNote("antiquewhite", "", "To get started, view the help files below:")
			Note()
			ColourNote("limegreen", "", unpack({helpWrap(table.concat(helpFiles, ", "))}))

		elseif str == "win" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset win <on|off|show|hide|max<imize>|min<imize>|expand|collapse>")
			ColourNote("antiquewhite", "", "        xset winreset")
			Note()
			ColourNote("limegreen", "", "xset win:")
			ColourNote("antiquewhite", "", unpack({helpWrap("This command toggles the Search & Destroy miniwindow. Use 'on' or 'show' to show the window, and use 'off' or 'hide' to close the window. Use max or expand to expand the window from a collapsed state, or use min or collapse to minimize the window.")}))
			Note()
			ColourNote("limegreen", "", "xset winreset:")
			ColourNote("antiquewhite", "", unpack({helpWrap("If, for any reason, the window goes missing and the previous command does not restore it, this command will reset the window to a default location on top of your windows.")}))

		elseif str == "speed" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset speed <walk|run>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Without an argument, it will display the current movement speed the mapper is using. With an argument, it will change the map speed to walk (without using portals) or run (using portals).")}))

		elseif str == "vidblain" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset vidblain")
			ColourNote("antiquewhite", "", "        xset vidblain level <#>")
			Note()
			ColourNote("limegreen", "", "xset vidblain:")
			ColourNote("antiquewhite", "", unpack({helpWrap("This will toggle a fix that allows you to run to areas within Vidblain. This was necessary because of the random drop locations when you runto Vidblain without a portal. See the next command if you have a portal to an area within Vidblain.")}))
			Note()
			ColourNote("limegreen", "", "xset vidblain level <#>:")
			ColourNote("antiquewhite", "", unpack({helpWrap("This command is used to display or set the lowest level portal you have to an area in Vidblain. For example, if you have a level 1 portal to Sendhia, you would simply type 'xset vidblain level 1'. ")}))

		elseif str == "mark" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset mark")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("This command will set your current room as the designated 'start' room of the area.")}))

		elseif str == "index areas" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset index areas")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Occasionally, SnD does not realize you've mapped an area for whatever reason. This becomes apparent when you see a lot of red links on your campaign or global quest check list. When this happen, this command SHOULD fix it, but again, only if you've mapped the areas linked in red. If it does not, something else is amiss, and you should probably note Crowley or Naricain about it.")}))

		elseif str == "silent" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset silent <on|off>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("This command will turn the display of campaign or global quest targets in the main window on or off. Soneone once mentioned it was redudant to have it in both the miniwindow and the main window, so for the sake of spamreduce, this was included.")}))

		elseif str == "xm" or str == "xmall" or str == "rlh" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xm <room name>")
			ColourNote("antiquewhite", "", "        xmall <room name>")
			ColourNote("antiquewhite", "", "        xm rlh <#>")
			Note()
			ColourNote("limegreen", "", "xm <room name>:")
			ColourNote("antiquewhite", "", unpack({helpWrap("Searches for the supplied room name within the area. It can match partial room names. To get a list of all rooms in the current area, use '%' as the room name.")}))
			Note()
			ColourNote("limegreen", "", "xmall <room name>:")
			ColourNote("antiquewhite", "", unpack({helpWrap("As with above, searches for the supplied room name, but across all zones. It can match partial room names. Would not suggest using '%' here as it will display every room you have mapped in Aardwolf.")}))
			Note()
			ColourNote("limegreen", "", "xm rlh <#>:")
			ColourNote("antiquewhite", "", unpack({helpWrap("Without an argument, displays rooms that link to the current room. With an argument, displays rooms that link to your chosen room ID. This will display room ID, room name, and room zone name that links to the room.")}))

		elseif str == "xmap" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xmap move <roomID> <walk|run>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Moves between rooms at default speed (see 'help xset speed') without argument, or, with argument, walks (without portals) or runs (with portals) to the supplied room ID.")}))

		elseif str == "roomnote" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": roomnote <area|area areakey>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Displays roomnotes for the current room, current area, or for the supplied area keyword.")}))

		elseif str == "qw" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": qw<x> <mobname>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Uses the 'where' command on the stored mobname based on quest, campaign, or global quest target. If an argument is supplied, it will 'where' the argument. Use 'x' if you want an exact match on mob name.")}))

		elseif str == "ht" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": ht <mob|stop>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Executes the 'hunt trick' for the current campaign target or supplied argument. Use 'stop' to stop the hunt trick, which will work in most cases but may fail if a mob has a keyword of 'stop'.")}))

		elseif str == "ah" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": ah<a> <mobname>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Automatically sends the 'hunt' command and executes the direction hunt leads you. Append 'a' in order to abort autohunting. This is useful for tracking quest mobs through mazes, or if you really want to, hunting players. However, you must have hunt practiced for it to work.")}))

		elseif str == "ak" or str == "kk" or str == "qk" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": <xset> <ak|kk|qk> <commands>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("With the 'xset' argument, sets the interchangable command of 'ak', 'kk', and 'qk' to the command supplied. Without the 'xset' argument, executes the 'quick kill' command. If you wish to stack multiple commands, you must separate each command with a double semicolon (or a single semicolon if you start the line with a semicolon). For example, 'xset kick;;bash;;slap' (or ';xset kick;bash;slap')  will kick the target, then bash the target, then slap the target.")}))

		elseif str == "qs" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": qs")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Executes a scan for the current quest, campaign, or global quest target.")}))

		elseif str == "xq" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xq")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Reloads and displays your current quest information.")}))

		elseif str == "xqt" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xqt")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Retargets the current quest mob if you changed it, for instance with 'xcp' or 'qw.'")}))

		elseif str == "nx" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": nx<->")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Moves to the next room in the list, or with '-', the previous room.")}))
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("See 'help xset nx' for information about the action that will be taken upon arriving in the room.")}))

		elseif str == "go" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": go <index #>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Moves to the first room in the index, or with a supplied argument to the index number supplied.")}))
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("See 'help xset nx' for information about the action that will be taken upon arriving in the room.")}))

		elseif str == "xset nx" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset nx <smartscan|con|scan|scanhere|qs|none>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Sets the behaviour when you arrive at a room via nx or go. Without an argument it will display the current action. With an argument, sets your action to:")}))
			ColourNote("antiquewhite", "", unpack({helpWrap("  * smartscan: scan for just your targets, and fallback on con when")}))
			ColourNote("antiquewhite", "", unpack({helpWrap("    potential noscan targets are encountered.")}))
			ColourNote("antiquewhite", "", unpack({helpWrap("  * con: consider the room")}))
			ColourNote("antiquewhite", "", unpack({helpWrap("  * scan: perform a scan.")}))
			ColourNote("antiquewhite", "", unpack({helpWrap("  * scanhere: perform a scan of the current room.")}))
			ColourNote("antiquewhite", "", unpack({helpWrap("  * qs: perform a quick scan, looking for only your current target mob.")}))
			ColourNote("antiquewhite", "", unpack({helpWrap("  * none: do nothing.")}))
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("When you scan or consider, mobs found in the current room are added to the mobs database.")}))

		elseif str == "xset con_overwrite" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset con_overwrite")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Disable replacing the output of consider. This is mainly for when you have other plugins that replace the output.")}))

		elseif str == "xrt" or str == "xrun" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": <xrt|xrun> <area keyword>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Executes a run to the supplied area keyword. If a room has been marked (help 'xset mark') as the start room of the area, it will run there instead.")}))

		elseif str == "noexp" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset noexp <off|#>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Without an argument, it will display the current setting. With an argument, it will turn off monitoring for noexp or set a threshhold for turning on noexp. This feature is to keep you from accidentally leveling while you're campaign leveling.")}))

		elseif str == "cp" or str == "gq" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": <cp|gq> <i|info|c|check>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Displays information/check for campaigns and global quests. With the 'i' or 'info' argument, it will load the list of mobs in the miniwindow.")}))

		elseif str == "xcp" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xcp <index>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Without an argument, this command will search for the first mob listed in the miniwindow. Otherwise, it will search for the mob based on the supplied index number.")}))

		elseif str == "xcp mode" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xcp mode <ht|qw|off>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Without an argument, displays your current default action to take when searching for a mob using 'xcp' (see 'help xcp'). With an argument, sets your default action to 'ht' (hunt trick, 'help ht'), 'qw' (quick where, 'help qw'), or 'off' (no action taken).")}))

		elseif str == "xcp quest" or str == "quest"then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xcp quest")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("When enabled, using 'xcp' with no arguments will target your quest mob if you are currently on a quest.")}))

		elseif str == "snd update" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": snd update")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Whenever Crowley announces a new version, this command will make it easy to update the Search & Destroy plugin.")}))

		elseif str == "ms" or str == "msearch" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": <<x>ms|<x>msearch> <here|area> <mob name>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("This command will search the mob database for the mob name supplied based on the area supplied (here, [area key], defaults to 'all' with no argument), returning the rooms the mob has been found, the area, and the times it has been found in that room. The leading 'x' is optional.")}))

		elseif str == "mgo" or str == "mgoto" or str == "xmgo" or str == "xmgoto" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": <x>mgo<to> <idx>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("This command is used after searching for a mob and will go to the room provided by the index number. The leading 'x' is optional.")}))

		elseif str == "snd reload" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": snd reload")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("If, for any reason, Search & Destroy stops functioning correctly, this theoretically should fix it. In some cases, it may be necessary to open up your plugins (Ctrl+Shift+P) and reinstall Search & Destroy.")}))

		elseif str == "snd check_update" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": snd check_update")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Toggles automatic checking for new versions of Search & Destroy.")}))

		elseif str == "snd migrate" or str == "mergePwar" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": snd migrate")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("This command is for previous users of Pwar's Search & Destroy. In an effort to not lose a previously built mob database, this command will migrate all data to this version of SnD.")}))
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("This will only work if the file name has not been altered from 'WinkleGold_Database.db' and that the file is located in the default plugin directory. If you have moved it or renamed it, please make sure it is located in the 'plugins' folder with the name 'WinkleGold_Database.db' and run this command again. Thank you.")}))

		elseif str == "kw" or str == 'keyword' then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset kw <mob keyword>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("This command will change a mob's keyword so that it is properly targeted. For example, say you have a campaign target of 'a yummy beef pot pie.' By default, S&D might target 'yummy pie' which doesn't actually match. Instead, you'll want it to target 'beef pie.'")}))
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("To do so, you can use 'xset kw beef pie' while it is a campaign, quest, or gquest target. Alternatively, you can use 'xset kw' with no arguments and follow the dialogs that appear.")}))

		elseif str == "sound" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset sound")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Toggles sounds. Currently this is only used to signify that a target is in a nearby room as determined by scan, or that one of the targets on your campaign/gquest, but not your current target, is in the same room as you. For full functionality, the soundpack plugin is expected to be enabled.")}))

		elseif str == "changelog" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": snd changelog")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Displays the entire changelog from oldest to newest top to bottom.")}))

		elseif str == "summary" then
		ColourNote("yellow", "", "Commands:")
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset win <on|off>: Shows your hides the window.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset winreset: Resets the window.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset speed <walk|run>: Displays current move speed, or changes it to argument.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset vidblain:  Fixes Vidblain's 'random drop' so you can still run to areas within Vidblain.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset mark:  Sets current room as 'start' for the current area.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset index areas:  Indexes areas. Use this if you get a lot of 'red' links but you've mapped the area.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset silent <on|off>:  Toggles displaying target list in main MUD window.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xm rlh <roomID>:  Displays rooms linking to <roomID> or current room.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xmall <room name>:  Displays rooms across the MUD matching the argument.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xm <room name>:  Displays rooms in zone matching the argument.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xmap move <roomID> <run|walk>:  Move to the room id at default speed, or walks (without portals) or runs (with portals) based on argument.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("roomnote <area|area areakey>:  Displays roomnotes for current room, current area, or area argument.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("qw<x> <mobname>:  Where's the current stored target or argument. Use 'x' to where exact mob name.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("ht <mob|stop>:  Executes the 'hunt trick' for current target or argument. Use 'stop' to abort.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("ah<a> <targ>:  Autohunts target. Append 'a' with no target to abort.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset <ak|kk|qk>:  Sets the 'quick kill' command. All options are interchangeable.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("<ak|kk|qk>:  Executes the 'quick kill' command. All options are interchangeable.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("qs:  Executes a 'quick scan' for the stored target.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xq:  Reloads the quest info.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xqt:  Retargets the current quest mob.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset noexp <off|#>:  Displays current setting with no argument. With argument, toggles noexp off or sets it to turn on at # exp remaining.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset kw <mob keyword>:  Set the keyword(s) that will be used to target a particular mob.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("nx<->:  Moves to the next room on the list, or the previous room with -.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("go <index>:  Runs to the first room in the index, or to the index number with argument.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset nx <smartscan|con|scan|scanhere|qs|none>:  Set the action to take upon arriving in a room via 'nx' or 'go'.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset con_overwrite:  Toggle overwriting the output of consider, for example if you have another plugin that also does this.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset sound:  Toggles sounds.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("<xrt|xrun> <area>:  Runs to the area matching the argument.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("<cp|gq> i|info:  Displays campaign/gquest info.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("<cp|gq> ch|check:  Displays campaign/gquest check.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xcp <index>:  Without argument, goes to top result in cp/gq check. Otherwise heads to the index chosen.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xcp mode <ht|qw|off>:  Sets whether you use hunt trick or quick where upon entering an area on cp/gq. Use 'off' to turn off this feature.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xcp quest:  Set whether or not 'xcp' will target quest mobs.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("snd update:  Automatically updates Search & Destroy.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("snd check_update:  Toggles automatically checking for new versions of Search & Destroy.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("ms<earch> <area|here|all> <mob>: Searches for mobs in the mob database.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("mgo<to> <idx>: After searching for mobs, goes to the index chosen.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("snd reload: Reloads the plugin if it errors out.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("snd migrate: If you used Pwar's plugin and have a database, this will migrate it over to this version so you do not lose your hard earned data.")}))

		else
			ColourNote("antiquewhite", "", "No help files found with your query. Please see the help files below:")
			Note()
			ColourNote("limegreen", "", unpack({helpWrap(table.concat(helpFiles, ", "))}))
		end
		ColourNote("cyan", "", string.rep("-", 76))
	end

	function sndReload()
		Execute(GetAlphaOption("script_prefix") .. "DoAfterSpecial(1, \"ReloadPlugin('" .. GetPluginID() .. "')\", sendto.script)")
	end

	function copyPwarWarn()
		InfoNote("Are you sure you want to do this? It will wipe out your existing mob and keyword data. Type ",
			"snd migrate confirm",
			" to migrate data from your pwar database.")
	end

	function copyPwarDB()
		local success, err = pcall(rawCopyPwarDB)

		if success then
			InfoNote("Finished migrating! You can now resume play!")
		else
			ErrorNote(err)
		end
	end

	function rawCopyPwarDB()
		local f = io.open(GetInfo(60) .. "WinkleGold_Database.db", "r")

		if not f then
			error("To start migration process, please locate the file 'WinkleGold_Database.db' and move it to the plugins folder. Then try again.")
		else
			InfoNote("Now rebuilding the database with data from Pwar's Search & Destroy.")

			os.remove(snd_db_file)
			migrate_database()

			f:close()

			local PwarDb = assert(sqlite3.open(GetInfo(60) .. "/WinkleGold_Database.db"))
			local mapperDb = assert(sqlite3.open(GetInfo(66) .. "Aardwolf.db"))
			local SnDdb = assert(sqlite3.open(GetInfo(66) .. "/SnDdb.db"))
			local roomsById = {}
			local roomsToLookup = {}
			local migrateTable = {}
			local insertStatements = {}
			local batch_size = 10000
			local err

			local mobQuery = "SELECT roomid, mobname, sum(freq) as count FROM mobs GROUP BY roomid, mobname"

			for row in PwarDb:nrows(mobQuery) do
				table.insert(roomsToLookup, row.roomid)
				table.insert(migrateTable, {roomid =  row.roomid,  mob = row.mobname, count = row.count})
			end

			roomQuery = string.format("SELECT uid, area, name FROM rooms WHERE uid IN (%s)", table.concat(roomsToLookup, ","))

			for row in mapperDb:nrows(roomQuery) do
				roomsById[tostring(row.uid)] = {area = row.area, name = row.name}
			end
			mapperDb:close()

			for i, mob in ipairs(migrateTable) do
				room = roomsById[tostring(mob.roomid)]
				if room then
					table.insert(insertStatements, string.format("INSERT INTO mobs (mob,room,roomid,zone,count) VALUES (%s,%s,%s,%s,%i);", fixsql(mob.mob), fixsql(room.name), mob.roomid, fixsql(room.area), mob.count))

					if #insertStatements > batch_size then
						execute_in_transaction(SnDdb, insertStatements)
						if SnDdb:errcode() > 0 then
							err = SnDdb:error_message()
							SnDdb:close()
							PwarDb:close()
							error("Encountered an error during migration: " .. err)
						end
						insertStatements = {}
					end
				end
			end

			local keyQuery = "SELECT mobname, areaid, subname FROM mobsubs"

			for row in PwarDb:nrows(keyQuery) do
				table.insert(insertStatements, string.format("INSERT OR REPLACE INTO mob_keyword_exceptions (area_name,mob_name,keyword) VALUES (%s,%s,%s);", fixsql(row.areaid), fixsql(row.mobname), fixsql(row.subname)))
				if #insertStatements > batch_size then
					execute_in_transaction(SnDdb, insertStatements)
					if SnDdb:errcode() > 0 then
						err = SnDdb:error_message()
						SnDdb:close()
						PwarDb:close()
						error("Encountered an error during migration: " .. err)
					end

					insertStatements = {}
				end
			end

			PwarDb:close()

			execute_in_transaction(SnDdb, insertStatements)
			if SnDdb:errcode() > 0 then
				err = SnDdb:error_message()
				SnDdb:close()
				error("Encountered an error during migration: " .. err)
			end

			SnDdb:close()
		end
	end

	function mobLookup (name, location, level, exact)
		SnDdb = sqlite3.open(snd_db_file)

		if exact ~= "" or exact ~= nil then exact = false end

		local locFound, locQuery, searchQuery, lvlQuery, searchMsg = false, "SELECT * FROM area WHERE key LIKE '%s'", "", " AND area.minlvl <= %s AND area.maxlvl >= %s", "Search for " .. name .. " in  " .. location

		if location ~= "" or location ~= nil then
			if location:upper() == "HERE" then
				location = gmcp("room.info.zone")
			elseif location:upper() == "ALL" then
				location = "%"
			end

			locQuery = locQuery:format(fixSQL(location))

			for a in SnDdb:rows(locQuery) do
				if a[1] then
					locFound = true
				end
			end
		end

		if locFound then
			if exact then
				searchQuery = "SELECT * FROM mobs, area WHERE zone LIKE '" .. fixSQL(location)  .. "' AND mob LIKE '" .. fixSQL(name) .. "'"
			else
				searchQuery = "SELECT * FROM mobs, area WHERE zone LIKE '" .. fixSQL(location) .. "' AND mob LIKE '%" .. fixSQL(name) .. "%'"
			end
		else
			if exact then
				searchQuery = "SELECT * FROM mobs, area WHERE mobs.mob LIKE '" .. fixSQL(name) .. "' AND mobs.room LIKE '" .. fixSQL(location) .. "' AND area.key = mobs.zone"
			else
				searchQuery = "SELECT * FROM mobs, area WHERE mobs.mob LIKE '%" .. fixSQL(name) .. "%' AND mobs.room LIKE '%" .. fixSQL(location) .. "%' AND area.key = mobs.zone"
			end
		end

		if tonumber(level) then
			searchQuery = searchQuery .. lvlQuery:format(level, level)
		end

		searchQuery = searchQuery .. " and area.noquest LIKE 'false' and mobs.zone = area.key ORDER BY mobs.zone, mobs.Count DESC"

		SnDdb:close()

		showResults(searchQuery, searchMsg)
	end

	function showResults(query, msg)
		DebugNote("Exceuting mob search query: ", query)
		SnDdb = sqlite3.open(snd_db_file)
		mshow = {}
		local searchMsg, failure = msg, "No matches found!"

		local dividers = "+" .. string.rep("-", 30) .. "+" .. string.rep("-", 25) .. "+" .. string.rep("-", 13) .. "+" .. string.rep("-", 12) .. "+" .. string.rep("-", 7) .. "+"

		ColourNote("orange", "", searchMsg .. " ...")
		ColourNote("dimgray", "", dividers)
		ColourNote("dimgray", "", "| ", "white", "", "Mob name" .. string.rep(" ", 28-#"Mob name"), "dimgray", "", " | ", "green", "", "Room name" .. string.rep(" ", 23-#"Room name"), "dimgray", "", " | ", "cyan", "", "ID" .. string.rep(" ", 11-#"ID"), "dimgray", "", " | ", "yellow", "", "Zone" .. string.rep(" ", 10-#"Zone"), "dimgray", "", " | ", "white", "", "Count ", "dimgray", "", "|"  )

		ColourNote("dimgray", "", dividers)

		local count = 0

		for a in SnDdb:rows(query) do
			count = count + 1
			if #a > 0 then
				mName, rName, rID, zName, mobCount = count .. ". " .. a[1], a[2], tostring(a[3]), a[4], a[5]
				if #mName > 28 then
					mName = string.sub(mName, 1, 28)
				end

				if #rName > 23 then
					rName = string.sub(rName, 1, 23)
				end

				ridStr = count .. ". " .. rID

				bgColor = "black"

				if count%2 == 0 then
					bgColor = "midnightblue"
				end

				table.insert(mshow, {a[1], zName, rID})

				ColourTell("dimgray", "", "|", "white", bgColor, " " .. string.format("%-29s",mName), "dimgray", "", "|", "limegreen", bgColor, " " .. string.format("%-24s", rName), "dimgray", "", "|", "cyan", bgColor, " " .. count .. ". ")
				Hyperlink("mapper goto " .. rID, rID, "goto id", "cyan", bgColor, 0, 1)
				ColourTell("", bgColor,  string.rep(" ", 12-#ridStr),"dimgray", "", "|", "yellow", bgColor, " " .. string.format("%-11s", zName), "dimgray", "", "|", "white", bgColor, " " .. string.format("%-5d", mobCount), "dimgray", bgColor, " |\n")

			end
		end

		if count == 0 then
			ColourNote("dimgray", "", "| ", "tomato", "", string.format("%-89s", failure), "dimgray", "", " |")
		end

		ColourNote("dimgray", "", dividers)

		if count > 0 and count < 2 then
			ColourNote("orange", "", count .. " match found")
		elseif count > 1 then
			ColourNote("orange", "", count .. " matches found")
		end

		SnDdb:close()
		SnDdb = nil
	end

	function mobShow(name, line, args)
		if #mshow ~= 0 then
			mob, zone, room, rid = mshow[tonumber(args[1])][1], mshow[tonumber(args[1])][2], mshow[tonumber(args[1])][3], mshow[tonumber(args[1])][4]
			Execute(args[2] .. " " .. string.format(showStr, mob, zone, room, rid))
		else
			InfoNote("No results loaded. Try searching for your mob first.")
		end
	end

	function mobGo(name, line, args)
		if #mshow ~= 0 then
			Execute("mapper goto " .. mshow[tonumber(args[1])][3])
		else
			InfoNote("No results loaded. Try searching for your mob first.")
		end
	end

	function fixSQL (str)
		return str:gsub("'", "''")
	end

	function onSearch(name, line, wildcards)
		local param1, param2, param3 = wildcards[1], wildcards[2], (tonumber(wildcards[3]) and tonumber(wildcards[3])) or nil

		if string.upper(param1) == "HELP" then
			onHelp()
		else
			local zone, name, sendit = param1, param2, false

			if #name < 1 then
				name = zone
				zone = "all"
				sendit = true
			 elseif #name >= 1 and #name < 2 then
				InfoNote("*** You need at least 2 characters of the mob name!")
			else
				sendit = true
			end

			if sendit then
				if param3 then
					mobLookup(name, zone, param3)
				else
					mobLookup(name, zone)
				end
			else
				InfoNote("*** Syntax error! Use: ", "msearch <areakey|here|all> <mob>")
			end
		end
	end

	function strip_colours (s)
		s = s:gsub("@@", "\0")  -- change @@ to 0x00
		s = s:gsub("@%-", "~")    -- fix tildes (historical)
		s = s:gsub("@x%d?%d?%d?", "") -- strip valid and invalid xterm color codes
		s = s:gsub("@.([^@]*)", "%1") -- strip normal color codes and hidden garbage
		return (s:gsub("%z", "@")) -- put @ back (has parentheses on purpose)
	end

	function xset_nx_check()
		InfoNote("xset nx is set to ", xset_nx_action)
		print_xset_nx_desc()
	end

	function xset_nx(name, line, wildcards)
		xset_nx_action = wildcards.action
		SetVariable("mcvar_xset_nx_action", xset_nx_action)
		print_xset_nx_desc()
	end

	function print_xset_nx_desc()
		if xset_nx_action == "smartscan" then
			InfoNote("You will ", "scan", " every room upon arrival after nx or go, filtering down to just campaign, gquest, and quest targets. If you encounter potential noscan mobs, follow up with a filtered ", "consider", " to check if they are here.\n")
		elseif xset_nx_action == "con" then
			InfoNote("You will ", "consider", " every room upon arrival after nx or go.\n")
		elseif xset_nx_action == "scan" then
			InfoNote("You will ", "scan", " surrounding rooms upon arrival after nx or go.\n")
		elseif xset_nx_action == "scanhere" then
			InfoNote("You will ", "scan the current room", " upon arrival after nx or go.\n")
		elseif xset_nx_action == "qs" then
			InfoNote("You will ", "quick scan", " every room upon arrival after nx or go, looking only for your target mob.\n")
		else
			InfoNote("You will take no action upon arrival after nx or go.\n")
		end
	end

	function xset_con_overwrite()
		if xset_overwrite_con == "on" then
			xset_overwrite_con = "off"
		else
			xset_overwrite_con = "on"
		end
		toggle_con_overwrite_triggers()
		SetVariable("mcvar_xset_overwrite_con", xset_overwrite_con)

		InfoNote("\nConsider overwriting is now ", string.upper(xset_overwrite_con))
	end

	function is_con_overwritten()
		return xset_overwrite_con == "on"
	end

	function toggle_con_overwrite_triggers()
		local enabled = is_con_overwritten()
		for i, name in ipairs(GetTriggerList()) do
			if GetTriggerInfo(name, 26) == "consider" then
				DebugNote("Setting omit_from_output to ", tostring(enabled), " for trigger ", name)
				SetTriggerOption(name, "omit_from_output", enabled)
			end
		end
	end

	function consider_trigger(name, line, wildcards, style)
		local con_details = {
			a = { level_range="-20 and below", 		colour="cornflowerblue", },
			b = { level_range="-10 to -19", 		colour="deepskyblue", },
			c = { level_range="-5 to -9", 			colour="turquoise", },
			d = { level_range="-2 to -4", 			colour="mediumspringgreen", },
			e = { level_range="-1 to +1", 			colour="lime", },
			f = { level_range="+2 to +4", 			colour="lawngreen", },
			g = { level_range="+5 to +9", 			colour="limegreen", },
			h = { level_range="+10 to +15", 		colour="greenyellow", },
			i = { level_range="+16 to +20", 		colour="#EFF22D", },
			j = { level_range="+21 to +30", 		colour="gold", },
			k = { level_range="+31 to +40", 		colour="darkorange", },
			l = { level_range="+41 to +50", 		colour="orangered", },
			m = { level_range="+51 and above", 		colour="red", },
		}

		local details = con_details[name]
		local on_target_list = false
		local mob_name = wildcards.mob_name
		local lower_mob_name = mob_name:lower()
		local tags = mob_activity_tags(mob_name, true)
		local mob_scanned = false

		EnableTrigger("consider_end", true)

		if con_after_scan then
			for i, scanned_mob in ipairs(scanned_mobs_here) do
				if scanned_mob == lower_mob_name then
					mob_scanned = true
					break
				end
			end
		end

		if not mob_scanned then
			table.insert(considered_mobs_here, lower_mob_name)
		end

		if is_con_overwritten() and (#tags > 0 or not con_after_scan) then
			for i, tag in ipairs(tags) do
				ColourTell(tag.colour, "", tag.text)
			end

			for i, s in ipairs(style) do
				if string.match(s.text, "^%s*%(.+%)%s*$") then
					ColourTell(RGBColourToName(s.textcolour), RGBColourToName(s.backcolour), s.text)
				else
					break
				end
			end

			ColourNote("silver", "", mob_name, details.colour, "", string.format(" (%s)", details.level_range))
		end
	end

	function consider_unkillable()
		EnableTrigger("consider_end", true)
	end

	function consider_end()
		EnableTriggerGroup("consider_end", false)

		if #considered_mobs_here > 0 then
			write_mob_list_to_db(considered_mobs_here)
		else
			DebugNote("No considered mobs found to update the mobs database")
		end

		-- Don't play sound when a quest target is here, assume soundpack will already play a sound
		if con_after_scan and not quest_target_found_here then
			if activity_target_found_here then
				-- The current target is found in the room, play a sound
				play_target_found_sound()
			else
				-- A non-active target on the campaign/gquest list is found in the current room, play a sound
				if other_target_found_here then
					play_other_target_here_sound()
				end
			end
		end

		activity_target_found_here = false
		quest_target_found_here = false
		other_target_found_here = false
		con_after_scan = false
		considered_mobs_here = {}
	end

	function play_target_found_sound()
		DebugNote("Play target found here sound")
		if is_sound_enabled() and IsPluginInstalled(plugin_id_soundpack) and GetPluginInfo(plugin_id_soundpack, 17) then
			CallPlugin(plugin_id_soundpack, "TriggerEvent", "quest_target_found")
		end
	end

	function play_target_nearby_sound()
		DebugNote("Play target found nearby sound")
		if is_sound_enabled() then
			PlaySound(0, GetInfo(74) .. target_nearby_sound, false, 100, 0)
		end
	end

	function play_other_target_here_sound()
		DebugNote("Play other target here sound")
		if is_sound_enabled() then
			PlaySound(0, GetInfo(74) .. other_target_here_sound, false, 100, 0)
		end
	end

	function scan_start()
		EnableTriggerGroup("scan", true)
		doors_in_scanned_room = {}
		scanned_mobs_here = {}
		scan_full_display = { { doors = doors_in_scanned_room } }
	end

	function scan_end()
		EnableTriggerGroup("scan", false)

		local anything_seen = false

		for i, room in ipairs(scan_full_display) do
			if room.mobs and #room.mobs > 0 then
				if room.header then
					for j, style in ipairs(room.header) do
						ColourTell(style[1], style[2], style[3])
					end
					print("")
				end

				for j, mob in ipairs(room.mobs) do
					anything_seen = true
					for k, style in ipairs(mob) do
						ColourTell(unpack(style))
					end
					print("")
				end
			end

			if #room.doors > 0 then
				for j, door in ipairs(room.doors) do
					for k, style in ipairs(door) do
						ColourTell(unpack(style))
					end
					print("")
				end
			end
		end

		if not anything_seen and running_smart_scan then
			ColourNote(RGBColourToName(GetNormalColour(8)), "", "You see no targets around.")
		end

		write_mob_list_to_db(scanned_mobs_here)

		if activity_target_found_here then
			play_target_found_sound()
		else
			if running_smart_scan and #scanned_mobs_here < mob_count_here then
				DebugNote("Saw ", mob_count_here, " mobs in the room but only ", #scanned_mobs_here, " on scan")
				InfoNote("Target not found on smart scan but potential noscan mobs found in this room. Running consider.")
				con_after_scan = true
				SendNoEcho("con")
			end

			if target_found_nearby then
				play_target_nearby_sound()
			end

			if other_target_found_here then
				play_other_target_here_sound()
			end
		end
		scanning_current_room = false
		activity_target_found_here = false
		quest_target_found_here = false
		target_found_nearby = false
		other_target_found_here = false
		running_smart_scan = false
	end

	function scan_location_current_room(name, line, wildcards, style)
		scanning_current_room = true
		scanned_mobs_here = {}
		setup_scan_room(style)
	end

	function scan_location_nearby_room(name, line, wildcards, style)
		scanning_current_room = false
		setup_scan_room(style)
	end

	function setup_scan_room(style)
		mobs_in_scanned_room = {}
		doors_in_scanned_room = {}
		table.insert(scan_full_display, { header = convert_full_styles(style), mobs = mobs_in_scanned_room, doors = doors_in_scanned_room })
	end

	function scan_door_nearby(name, line, wildcards, style)
		table.insert(doors_in_scanned_room, convert_full_styles(style))
	end

	function convert_full_styles(styles)
		local result = {}
		for i, style in ipairs(styles) do
			table.insert(result, convert_one_style(style))
		end
		return result
	end

	function convert_one_style(style)
		return { RGBColourToName(style.textcolour), RGBColourToName(style.backcolour), style.text }
	end

	function scan_mob(name, line, wildcards, style)
		local tags = {}
		if not string.find(wildcards.flags, "(Player)") then
			local mob_name = wildcards.mob_name
			tags = mob_activity_tags(mob_name, scanning_current_room)

			if scanning_current_room then
				table.insert(scanned_mobs_here, mob_name:lower())
			end
		end

		if #tags > 0 or not running_smart_scan then
			local padding = 5
			local mob_styled_text = {}
			for i, tag in ipairs(tags) do
				table.insert(mob_styled_text, {tag.colour, "", tag.text})
				padding = padding - #tag.text
			end

			for i, s in ipairs(style) do
				if i == 1 then
					s.text = string.gsub(s.text, "^     ", string.rep(" ", padding))
				end
				table.insert(mob_styled_text, convert_one_style(s))
			end
			table.insert(mobs_in_scanned_room, mob_styled_text)
		end
	end

	function scan_empty(name, line, wildcards, style)
		if not running_smart_scan then
			for i, s in ipairs(style) do
				ColourTell(RGBColourToName(s.textcolour), RGBColourToName(s.backcolour), s.text)
			end
		end
	end

	function roomchars_start()
		mob_count_here = 0
		EnableTrigger("roomchars", true)
	end

	function roomchars_end()
		EnableTrigger("roomchars", false)
		DebugNote("Detected ", mob_count_here, string.format(" mob%s in this room", mob_count_here == 1 and "" or "s"))
	end

	function roomchars()
		mob_count_here = mob_count_here + 1
	end

	function mob_activity_tags(mob_name, checking_current_room)
		local on_target_list = false
		local lower_mob_name = mob_name:lower()
		local result = {}

		for i, target in ipairs(main_target_list) do
			if current_room.arid == target.arid and target.mob:lower() == lower_mob_name then
				on_target_list = true
				break
			end
		end

		if on_target_list then
			if checking_current_room then
				if type(full_mob_name) == 'string' and full_mob_name:lower() == lower_mob_name then
					activity_target_found_here = true
				else
					other_target_found_here = true
				end
			else
				target_found_nearby = true
			end
			table.insert(result, { text = "[", colour = "gold" })
			table.insert(result, { text = current_activity:upper(), colour = "magenta" })
			table.insert(result, { text = "] ", colour = "gold" })
		end

		if quest_target.mob and quest_target.mob:lower() == lower_mob_name and quest_target.arid == current_room.arid then
			if checking_current_room then
				quest_target_found_here = true
			else
				target_found_nearby = true
			end
			table.insert(result, { text = "[", colour = "gold" })
			table.insert(result, { text = "Q", colour = "magenta" })
			table.insert(result, { text = "] ", colour = "gold" })
		end

		return result
	end

	function write_mob_list_to_db(mob_list)
		if #mob_list < 1 then
			DebugNote("No mobs to be written to the database")
			return
		end

		local rname = strip_colours(gmcp("room.info.name"))
		local zname = gmcp("room.info.zone")
		local writes = {}
		local sql_mobs = {}
		for i, mob in ipairs(mob_list) do
			table.insert(sql_mobs, fixsql(mob))
			table.insert(writes, string.format("INSERT OR IGNORE INTO mobs (mob,room,roomid,zone) VALUES (%s,%s,%i,%s);",
				fixsql(mob), fixsql(rname), tonumber(current_room.rmid), fixsql(zname)))
			table.insert(writes, string.format("UPDATE mobs SET Count = Count + 1 WHERE mob = %s AND roomid = %i;", fixsql(mob), tonumber(current_room.rmid)))
		end

		local db = assert(sqlite3.open(snd_db_file))

		execute_in_transaction(db, writes)

		if debug_mode == "on" then
			if db:errcode() > 0 then
				ErrorNote("Db error: " .. db:error_message())
			else
				DebugNote("Successfully inserted or updated ", #mob_list, " in the mobs database")
			end
		end
		db:close_vm()
	end

	function update_sounds_onoff_value(new_val)
		xset_sound_onoff = new_val
		SetVariable("mcvar_xset_sound_onoff", xset_sound_onoff)

		InfoNote("\nSearch&Destroy Sounds are now ", string.upper(xset_sound_onoff))
	end

	function xset_sound()
		if xset_sound_onoff == "on" then
			update_sounds_onoff_value("off")
		else
			download_sounds(function(success)
				if success then
					xset_sound_onoff = "on"
					update_sounds_onoff_value("on")
				else
					ErrorNote("Sound could not be enabled")
				end
			end)
		end
	end

	function is_sound_enabled()
		return xset_sound_onoff == "on"
	end

	function trigger_receive_xp()
		if last_mob_damaged then
			DebugNote("I suspect you just killed ", last_mob_damaged, " in room ", current_room.rmid, " (", current_room.arid, ")")
			last_mob_killed = last_mob_damaged
		else
			ErrorNote("****** ", "I don't know which mob you just killed", " ******")
		end
		last_mob_damaged = nil
	end

	function trigger_damage_done(name, line, wildcards)
		last_mob_damaged = Trim(wildcards.mob_name)
	end
]]>
</script>
<triggers>
+<!-- Receive xp -->
	<trigger match="^You (?:don't )?receive \d+(?:\+\d+)* experience points\."
		script="trigger_receive_xp" ignore_case="y" enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

<!-- Damage triggers -->
	<trigger match="^.+\w tickles +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w bruises +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w scratches +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w grazes +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w nicks +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w scars +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w hits +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w injures +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w wounds +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w mauls +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w maims +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w mangles +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w mars +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w LACERATES +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w DECIMATES +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w DEVASTATES +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w ERADICATES +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w OBLITERATES +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w EXTIRPATES +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w INCINERATES +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w MUTILATES +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w DISEMBOWELS +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w MASSACRES +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w DISMEMBERS +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w RENDS +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w - BLASTS - +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w -= DEMOLISHES =- +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w \*\* SHREDS \*\* +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w \*\*\*\* DESTROYS \*\*\*\* +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w \*\*\*\*\* PULVERIZES \*\*\*\*\* +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w -=- VAPORIZES -=- +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-==-> ATOMIZES <-==-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-:-> ASPHYXIATES <-:-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-\*-> RAVAGES <-\*-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <>\*<> FISSURES <>\*<> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <\*><\*> LIQUIDATES <\*><\*> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <\*><\*><\*> EVAPORATES <\*><\*><\*> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-=-> SUNDERS <-=-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <=-=><=-=> TEARS INTO <=-=><=-=> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <->\*<=> WASTES <=>\*<-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-\+-><-\*-> CREMATES <-\*-><-\+-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <\*><\*><\*><\*> ANNIHILATES <\*><\*><\*><\*> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <--\*--><--\*--> IMPLODES <--\*--><--\*--> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-><-=-><-> EXTERMINATES <-><-=-><-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-==-><-==-> SHATTERS <-==-><-==-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <\*><-:-><\*> SLAUGHTERS <\*><-:-><\*> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-\*-><-><-\*-> RUPTURES <-\*-><-><-\*-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-\*-><\*><-\*-> NUKES <-\*-><\*><-\*-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w -<\[=-\+-=\]<:::<>:::> GLACIATES <:::<>:::>\[=-\+-=\]>- +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-=-><-:-\*-:-><\*--\*> METEORITES <\*--\*><-:-\*-:-><-=-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-:-><-:-\*-:-><-\*-> SUPERNOVAS <-\*-><-:-\*-:-><-:-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w does UN\w+ things to +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w damages? +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +shreds +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +destroys +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +pulverizes +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +vaporizes +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +atomizes +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +asphyxiates +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +ravages +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +fissures +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +liquidates +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +evaporates +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +sunders +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +into +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +wastes +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +cremates +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +annihilates +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +implodes +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +exterminates +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +shatters +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +slaughters +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +ruptures +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +nukes +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +glaciates +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +meteorites +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +supernovas +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^(?:You assassinate |You catch |You attempt to bury .* deep into |You lunge at)(?<mob_name>.*)(?: with cold efficiency\.| completely off-guard and inflict massive damage on .*\.|'s? back!|with a .*!)$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

<!-- Gquest operations -->
	<!-- group: trg_gq -->
	<trigger match="^Quest Name\.\.\.\.\.\.\.\.\.: \[ Global quest # (?<gq_id>\d{1,5}) \]$"
		script="gq_info_quest_name"
		name="trg_gq_info_quest_name" 		group="trg_gq"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_gq_info_quest_name", false) </send> </trigger>

	<trigger match="^Quest Status\.\.\.\.\.\.\.: \[ (?<status>\w+) \]$"
		script="gq_info_quest_status"
		name="trg_gq_info_quest_status" 	group="trg_gq"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_gq_info_quest_status", false) </send> </trigger>

	<trigger match="^Level range\.\.\.\.\.\.\.\.: \[\s+(?<minlvl>\d{1,3}) \] - \[\s+(?<maxlvl>\d{1,3}) \]$"
		script="gq_info_level_range"
		name="trg_gq_info_level_range" 		group="trg_gq"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_gq_info_level_range", false)
					EnableTrigger("trg_gq_info_target_header", true) </send> </trigger>

	<trigger match="^To complete this quest, you must:$"
		name="trg_gq_info_target_header" 	group="trg_gq"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_gq_info_target_header", false)
					EnableTrigger("trg_gq_info_line", true)
					EnableTrigger("trg_gq_info_end", true)
					EnableTriggerGroup("trg_gqmsg_2", true) </send> </trigger>

	<trigger match="^Kill at least (?<qty>[1-3]) \* (?<mob>\w[^(]+) \((?<loc>\S.+)\)\.$"
		script="gq_info_line"
		name="trg_gq_info_line" 			group="trg_gq"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^(?!Kill at least [1-3] \* \w[^(]+ \(\S.+\)\.)$"
		script="gq_info_end"
		name="trg_gq_info_end" 				group="trg_gq"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_gq_info_line", false)
					EnableTrigger("trg_gq_info_end", false) </send> </trigger>

	<trigger match="^You still have to kill (?<qty>[1-3]) \* (?<mob>\w[^(]+) \((?<loc>\S.+?)(?<isdead> - Dead)?\)$"
		script="gq_check_line"
		name="trg_gq_check_line" 			group="trg_gq"
		enabled="n"	regexp="y" sequence="500" keep_evaluating="y" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_gq_check_end", true) </send> </trigger>

	<trigger match="^(?!You still have to kill [1-3] \* \w[^(]+ \(\S.+?(?: - Dead)?\))$"
		script="gq_check_end"
		name="trg_gq_check_end" 			group="trg_gq"
		enabled="n"	regexp="y" sequence="500" keep_evaluating="y" omit_from_output="n" send_to="12" >
			<send>	EnableTrigger("trg_gq_check_line", false)
					EnableTrigger("trg_gq_check_end", false) </send> </trigger>

	<!-- group: trg_gqmsg_1 -->
	<trigger match="^You have now joined Global Quest # (?<gq_id>\d{1,5})\. See 'help gquest' for available commands\.$"
		script="gqmsg_joined"
		name="trg_gqmsg_joined" 			group="trg_gqmsg_1"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest: Global quest # (?<gq_id>\d{1,5}) for levels (?<min_lvl>\d{1,3}) to (?<max_lvl>\d{1,3})(?: - (?:200|10) or fewer wins only)? has now started\.$"
		script="gqmsg_started"
		name="trg_gqmsg_started" 			group="trg_gqmsg_1"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<!-- group: trg_gqmsg_2 -->
	<trigger match="^You have finished this global quest\.$"
		script="player_not_on_gq"
		name="trg_gq_finished_extended" 	group="trg_gqmsg_2"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest: Global Quest # (?<gq_id>\d{1,5}) has been won by (?<winner>[A-Z][A-Za-z]+) - \d*(?:1st|2nd|3rd|\dth) win\.$"
		script="gqmsg_winner"
		name="trg_gqmsg_winner" 			group="trg_gqmsg_2"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest: Global Quest # (?<gq_id>\d{1,5}) will go into extended time for 5 more minutes\.$"
		script="gqmsg_extended_time"
		name="trg_gqmsg_extended_time" 		group="trg_gqmsg_ext"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest: Global quest # (?<gq_id>\d{1,5})(?: \(extended\))? is now over\.$"
		script="gq_ended"
		name="trg_gqmsg_extended_end" 		group="trg_gqmsg_2"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest: Global quest # (?<gq_id>\d{1,5}) has been cancelled due to lack of activity\.$"
		script="gq_ended"
		name="trg_gqmsg_extended_end2" 		group="trg_gqmsg_2"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^You are no longer part of Global Quest # (?<gq_id>\d{1,5}) and will be unable to rejoin\.$"
		script="player_not_on_gq"
		name="trg_gqmsg_quit" 				group="trg_gqmsg_2"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Congratulations, that was one of the GLOBAL QUEST mobs\!$"
		script="gq_mob_killed"
		name="trg_gq_mob_killed" 			group="trg_gq_status"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^You are not in a global quest\.$"
		script="player_not_on_gq"
		name="trg_player_not_on_gq" 		group="trg_gq_status"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^There are no global quests running\.$"
		script="player_not_on_gq"
		name="trg_no_gqs_running" 			group="trg_gq_status"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest # (?<gq_id>\d{1,5}) has not yet started\.$"
		script="gq_check_not_yet_started"
		name="trg_gq_check_not_yet_started" group="trg_gq_status"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

<!-- CAMPAIGN OPERATIONS -->
	<trigger match="^Level Taken\.{8}: \[\s+(?<level>[1-2]?\d{1,2}) \]$"
		script="cp_info_level_taken"
		name="trg_cp_info_level_taken" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_info_level_taken", false) </send> </trigger>

	<trigger match="^The targets for this campaign are:$"
		script=""
		name="trg_cp_info_targets" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_info_targets", false)
					EnableTrigger("trg_cp_info_line", true)
					EnableTrigger("trg_cp_info_end", true) </send> </trigger>

	<trigger match="^Find and kill 1 \* (?<mob>\w[^(]+) \((?<loc>\S.+)\)$"
		script="cp_info_line"
		name="trg_cp_info_line" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^(?!Find and kill 1 \* \w[^(]+ \(\S.+\))$"
		script="cp_info_end"
		name="trg_cp_info_end" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_info_line", false)
					EnableTrigger("trg_cp_info_end", false) </send> </trigger>

	<trigger match="^You still have to kill \* (?<mob>\w[^(]+) \((?<loc>\S.+?)(?<isdead> - Dead)?\)$"
		script="cp_check_line"
		name="trg_cp_check_line" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_check_end", true)</send> </trigger>


	<trigger match="^(?!You still have to kill \* \w[^(]+ \(\S.+?(?: - Dead)?\))$"
		script="cp_check_end"
		name="trg_cp_check_end" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_check_gag_dead", true)
					EnableTrigger("trg_cp_check_line", false)
					EnableTrigger("trg_cp_check_end", false) </send> </trigger>

	<trigger match="^Note: Dead means that the target is dead, not that you have killed it\.$"
		name="trg_cp_check_gag_dead" group="trg_campaign"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_check_gag_dead", false) </send> </trigger>

<!-- CAMPAIGN STATUS TRACKING -->
	<trigger match="^Congratulations, that was one of your CAMPAIGN mobs\!$"
		script="cp_mob_killed"
		name="trg_cp_mob_killed" 	group="trg_cp_2"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^CONGRATULATIONS\! You have completed your campaign\.$"
		script="do_cp_complete"
		name="trg_cp_complete" 		group="trg_cp_2"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y"> </trigger>

	<trigger match="^Campaign cleared\.$"
		script="player_not_on_cp"
		name="trg_cp_quit" 			group="trg_cp_2"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^\w.+ tells you 'Good luck in your campaign\!'$"
		script="player_start_new_cp"
		name="trg_cp_request" 		group="trg_cp_2"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^You are not currently on a campaign\.$"
		script="player_not_on_cp"
		name="trg_player_not_on_cp" group="trg_cp_2"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^(?:(?:## )?You may now take another campaign\.|You may take (?:a campaign at this level|another campaign)\.)$"
		script="cp_check_can_get_new_cp"
		name="trg_can_get_new_cp" group="trg_cp_2"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^You (?:will have to level before you can go on another campaign|cannot take another campaign for (?:(?:\d+ hours?, )?\d+ minutes? and )?\d+ seconds?)\.$"
		name="trg_cannot_get_new_cp" group="trg_cp_2"
		script="cp_check_cannot_get_new_cp"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^You use a daily blessing campaign reset token to reset your campaign\.$"
		name="trg_cp_reset_token" group="trg_cp_2"
		script=""
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" omit_from_output="n" send_to="12" > </trigger>

<!-- QUICK WHERE -->
	<trigger match="^(?<mobname>\w.{29}) (?<roomname>[^ (0-9].*)$"
		script="qw_match"
		name="trg_quick_where_match" group="QuickWhere"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^There is no \w.+ around here\.$"
		script="qw_no_match"
		name="trg_quick_where_no_match" group="QuickWhere"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

<!-- HUNT TRICK -->
	<trigger match="^You are (?:almost )?certain that \w.+ is (?:north|south|east|west|up|down) from here\.|You are confident that \w.+ passed through here, heading (?:north|south|east|west|up|down)\.|The trail of \w.+ is confusing, but you're reasonably sure \w.+ headed (?:north|south|east|west|up|down)\.|There are traces of \w.+ having been here. Perhaps they lead (?:north|south|east|west|up|down)\?|You have no idea what you\'re doing\, but maybe \w.+ is (?:north|south|east|west|up|down)\?|You couldn\'t find a path to \w.+ from here\.|\w.+ is here\!$"
		script="ht_continue"
		name="trg_hunt_trick_continue_dir" group="HuntTrick"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You are (?:almost )?certain that \w.+ is through .+\.|You are confident that \w.+ passed through here, heading through .+\.|The trail of \w.+ is confusing, but you're reasonably sure \w.+ headed through .+\.|There are traces of \w.+ having been here\. Perhaps they lead through \w.+\?|You have no idea which way \w.+ went\.$"
		script="ht_continue"
		name="trg_hunt_trick_continue_portal" group="HuntTrick"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You seem unable to hunt that target for some reason\.$"
		script="ht_complete"
		name="trg_hunt_trick_complete" group="HuntTrick"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^\w.+ is here\!$"
		name="trg_hunt_trick_continue_2" group="HuntTrick"
		script="ht_continue"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^No one in this area by the name '\w.+'\.$"
		name="trg_hunt_trick_fail" group="HuntTrick"
		script="ht_fail"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^Not while you are fighting\!|You can't hunt while (?:resting|sitting)\.|You dream about going on a nice hunting trip, with pony rides, and campfires too\.$"
		name="trg_hunt_trick_abort" group="HuntTrick"
		script="ht_abort"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

<!--  AUTO HUNT -->
	<trigger match="^You are (?:almost )?certain that (?<mob>\w.+) is (?<dir>north|south|east|west|up|down) from here\.$"
		script="auto_hunt_next"
		name="trg_autohunt_next_1" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You are confident that (?<mob>.+) passed through here\, heading (?<dir>north|south|east|west|up|down)\.$"
		script="auto_hunt_next"
		name="trg_autohunt_next_2" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^The trail of \w.+ is confusing, but you\'re reasonably sure .+ headed (?:north|south|east|west|up|down)\.|There are traces of \w.+ having been here\. Perhaps they lead (?:north|south|east|west|up|down)\?|You have no idea what you\'re doing, but maybe \w.+ is (?:north|south|east|west|up|down)\?$"
		script="auto_hunt_lowskill"
		name="trg_autohunt_lowskill" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You are (?:almost )?certain that \w.+ is through .+\.|You are confident that \w.+ passed through here, heading through .+\.|The trail of \w.+ is confusing, but you're reasonably sure \w.+ headed through .+\.|There are traces of \w.+ having been here\. Perhaps they lead through .+\?|You have no idea what you\'re doing\, but maybe \w.+ is through .+\?$"
		script="auto_hunt_portal"
		name="trg_autohunt_portal" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^No one in this area by the name '\w.+'\.|You couldn\'t find a path to \w.+ from here\.|No one in this area by that name\.|Not while you are fighting\!|You can't hunt while (?:resting|sitting)\.|You dream about going on a nice hunting trip, with pony rides, and campfires too\.$"
		script="auto_hunt_abort"
		name="trg_autohunt_abort" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^You seem unable to hunt that target for some reason\.$"
		script="auto_hunt_abort"
		name="trg_hunt_trick" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^\w.+ is here\!$"
		script="auto_hunt_complete"
		name="trg_autohunt_complete" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^Magical wards around \w.+ bounce you back\.$"
		name="trg_autohunt_nopass" group="AutoHunt"
		script="auto_hunt_door"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^The \w.+ is closed\.$"
		name="trg_autohunt_door" group="AutoHunt"
		script="auto_hunt_door"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You do not have a key for \w.+\.$"
		name="trg_autohunt_no_key" group="AutoHunt"
		script="auto_hunt_abort"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You open \w.+\.$"
		name="trg_autohunt_door_open" group="AutoHunt"
		script="auto_hunt_door_open"
		enabled="n" regexp="y" sequence="100" > </trigger>

	auto_hunt_door_open
<!-- AUTO SET NOEXP -->
	<trigger match="^You will no longer receive experience\. Happy questing\!$"
		script="anex_automatic_off"
		name="trg_anex_automatic_off"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^You will now receive experience\. Happy leveling\!$"
		script="anex_automatic_on"
		name="trg_anex_automatic_on"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^You (?:don't )?receive (\d+)(?:\+\d+)? experience points?\.$"
		script="anex_mobdeath_xp1"
		name="trg_anex_mobdeath_xp1"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^You raise a level\! You are now level \d+\.$"
		script="player_level_up"
		name="trg_player_level_up"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y"> </trigger>

<!-- AREA INDEX PROCESS -->
	<trigger match="^              \[ Listing all areas in range 1 to 300 \]$"
		script="area_index_start"
		name="trg_area_index_start" group="AreaIndex"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_gag_headers", true)
					EnableTrigger("trg_area_index_gag_header_lines", true)
					EnableTrigger("trg_area_index_line", true)
					EnableTrigger("trg_area_index_gag_lock_means", true)
					EnableTrigger("trg_area_index_end", true) </send> </trigger>

	<trigger match="^From To   Lock  Keyword          Area Name                      $"
		name="trg_area_index_gag_headers" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_gag_headers", false) </send> </trigger>

	<trigger match="^---- ---- ----  ---------------  ------------------------------$"
		name="trg_area_index_gag_header_lines" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_gag_header_lines", false) </send> </trigger>

	<trigger match="^\s+(?<min>\d+)\s+(?<max>\d+)\s+(?<lock>\d+)?\s+?(?<arid>[0-9a-z]+?)\s+(?<areaName>[A-Z].+?)$"
		script="area_index_line"
		name="trg_area_index_line" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^'Lock' means you cannot enter until you are that level or higher\.$"
		name="trg_area_index_gag_lock_means" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_gag_lock_means", false) </send> </trigger>

	<trigger match="^---------------------------------------------------------------$"
		script="area_index_end"
		name="trg_area_index_end" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_line", false)
					EnableTrigger("trg_area_index_end", false) </send> </trigger>

<!-- Consider -->
	<trigger match="^(?<flags>\(.*\) )?You would stomp (?<mob_name>.+?) into the ground\.$"
		script="consider_trigger" group="consider"
		name="a"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?(?<mob_name>.+?) would be easy, but is it even worth the work out\?$"
		script="consider_trigger" group="consider"
		name="b"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?No Problem! (?<mob_name>.+?) is weak compared to you\.$"
		script="consider_trigger" group="consider"
		name="c"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?(?<mob_name>.+?) looks a little worried about the idea\.$"
		script="consider_trigger" group="consider"
		name="d"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?(?<mob_name>.+?) should be a fair fight!$"
		script="consider_trigger" group="consider"
		name="e"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?(?<mob_name>.+?) snickers nervously\.$"
		script="consider_trigger" group="consider"
		name="f"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?(?<mob_name>.+?) chuckles at the thought of you fighting \S+\.$"
		script="consider_trigger" group="consider"
		name="g"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?Best run away from (?<mob_name>.+?) while you can!$"
		script="consider_trigger" group="consider"
		name="h"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?Challenging (?<mob_name>.+?) would be either very brave or very stupid\.$"
		script="consider_trigger" group="consider"
		name="i"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?(?<mob_name>.+?) would crush you like a bug!$"
		script="consider_trigger" group="consider"
		name="j"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?(?<mob_name>.+?) would dance on your grave!$"
		script="consider_trigger" group="consider"
		name="k"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?(?<mob_name>.+?) says 'BEGONE FROM MY SIGHT unworthy\!'$"
		script="consider_trigger" group="consider"
		name="l"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?You would be completely annihilated by (?<mob_name>.+?)!$"
		script="consider_trigger" group="consider"
		name="m"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(.+ has divine protection\.|If you killed .+, who would serve .+ customers\?)$"
		script="consider_unkillable" name="consider_unkillable" group="consider"
		enabled="y" regexp="y" sequence="100" omit_from_output="n" send_to="12" > </trigger>

	<trigger match="^$"
		name="consider_end"
		group="consider_end"
		script="consider_end"
		enabled="n" regexp="y" sequence="100" omit_from_output="n" send_to="12" > </trigger>

	<trigger match="^(?:You see no one here but yourself!|Strange forces prevent violence here\.)$"
		name="consider_end_empty"
		group="consider_end"
		script="consider_end"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

<!-- Scan -->
	<trigger match="^Tag option scan turned ON$"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="{scan}"
		script="scan_start"
		enabled="y" regexp="n" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="{/scan}"
		script="scan_end"
		enabled="y" regexp="n" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^Right here you see:$"
		script="scan_location_current_room"
		group="scan"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(\d )?(North|East|South|West|Up|Down) from here you see:$"
		script="scan_location_nearby_room"
		group="scan"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^You see .+\.$"
		script="scan_door_nearby"
		group="scan"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^ {5}-(?<flags> [\[\(].+[\]\)])? (?<mob_name>.+)$"
		script="scan_mob"
		group="scan"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^Nothing to see around here, might as well move on\.$"
		script="scan_empty"
		group="scan"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

<!-- Roomchars -->
	<trigger match="^Tag option roomchars turned ON$"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="{roomchars}"
		script="roomchars_start"
		enabled="y" regexp="n" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="{/roomchars}"
		script="roomchars_end"
		enabled="y" regexp="n" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^[^{].+$"
		script="roomchars" name="roomchars"
		enabled="n" regexp="y" sequence="100" omit_from_output="n" send_to="12" > </trigger>

<!-- PAGE SIZE -->
	<trigger match="^You currently display ([0-9]+) lines per page\.|You do not page long messages\.$"
		script="capture_page_size"
		name="trg_capture_page_size"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" omit_from_output = "y" > </trigger>

	<trigger match="^Use 'pagesize \<lines\>' to change, or 'pagesize 0' to disable paging\.$"
		script=""
		name="trg_pagesize_gag_1"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" omit_from_output = "y" send_to="12" >
			<send>	EnableTrigger("trg_pagesize_gag_1", false) </send> </trigger>

<!-- Misc. gag triggers -->
	<trigger match="^Players found: \[\d+\], Max this reboot: \[\d+\], Connections this reboot: \[\d+\]$"
		name="trg_gag_who_footer_1"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" > </trigger>

	<trigger match="^Players invis: \[\d+\], Max on ever: \[\d+\]$"
		name="trg_gag_who_footer_2"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" > </trigger>

	<trigger match="^[\s\S]*$"
		name="trg_gag_everything"
		enabled="n" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="y" > </trigger>
</triggers>

<aliases>
<!-- Plugin Update automatic -->
	<alias enabled="y" match="snd update" script="update_plugin" sequence="100">
	</alias>
	<alias enabled="y" match="^xhelp(?:\s(.*))?$" regexp="y" script="onHelp" sequence="100">
	</alias>

	<alias enabled="y" match="^snd force update(?: (?<branch>\S+))?$" script="force_update_plugin" regexp="y" sequence="100">
	</alias>

	<alias enabled="y" match="snd check_update" script="toggle_automatic_update_checking" sequence="100">
	</alias>

	<alias enabled="y" match="^xset silent(?: (on|off))?" regexp="y" script="xset_silentMode" sequence="100">
	</alias>

<!-- Auto-hunt commands-->
	<alias	match="^ah (?<arg>\w.+)$"
			script="auto_hunt"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:aha|ah0)$"
			script="auto_hunt_abort"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- campaign data input: cp info, check -->
	<alias	match="^cp (?:i|info)$"
			script="do_cp_info"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^cp (?:ch|check)$"
			script="do_cp_check"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- gquest data input: gq info, check -->
	<alias	match="^gq (?:i|info)$"
			script="do_gq_info"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" >
				<send>	EnableTriggerGroup("trg_gq", false) </send>	</alias>

	<alias	match="^(?:gq (?:c|ch|check)|gg|qq)$"
			script="do_gq_check"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- xcp commands  -->
	<alias	match="^xcp$"
			script="xcp_noarg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xcp (?<index>[0-9]+)$"
			script="xcp_arg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xcp mode(?: (?<option>ht|qw|off))?$"
			script="xcp_set_action_mode"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xcp q(uest)?$"
		script="xcp_toggle_quest_targeting"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- movement: xrunto, go, nx, etc.  -->
	<alias	match="^(?:xrt|xrun|xrunto) (?<destination>.+)$"
			script="xrun_to_alias"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:go|goto)( (?<index>[0-9]+))?$"
			script="goto_number"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" keep_evaluating="y" > </alias>

	<alias	match="^nx$"
			script="goto_next"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^nx-$"
			script="goto_previous"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Automatic noexp -->
	<alias	match="^xset noexp( (?<arg>off|[0-9]+))?$"
			script="xset_noexp_tnl"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Quest commands -->
	<alias	match="^(?:xq|xq1)$"
			script="xq_command"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xqt$"
			script="retarget_quest"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Quick scan -->
	<alias	match="^qs$"
			script="quick_scan"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Quick-kill commands: qk, ak, kk, xset attack -->
	<alias	match="^(?:quick kill|ak|kk|qk)$"
			script="quick_kill"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset (?:kk|ak|qk|qkill)( (?<arg>.+?)(?<notarg> notarg)?)?$"
			script="xset_quick_kill_command"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Hunt trick -->
	<alias	match="^ht$"
			script="ht_noarg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^ht (?:(?<index>\d+)\.)?(?<mob>.+)?$"
			script="ht_arg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^ht(?:a|0| abort| stop)$"
			script="ht_abort"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Quick where -->
	<alias	match="^qw$"
			script="qw_noarg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^qw (?:(?<index>\d+)\.)?(?<mob>.+)?$"
			script="qw_arg_alias"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^qwx$"
			script="qw_exact"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- roomnotes -->
	<alias	match="^(?:roomnote|rn)$"
			script="room_note"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:roomnote|rn) a(?:rea)?(?: (?<arid>.+))?$"
			script="room_note_area"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:roomnote|rn) (?<roomid>\d+)$"
			script="room_note_room"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Sql Execution -->
	<alias	match="^runsql (?<sql>.+)$"
			script="RunSql"
			enabled="y" regexp="y" sequence="1" ignore_case="y" send_to="12" > </alias>

	<alias	match="^execsql (?<sql>.+)$"
			script="ExecSql"
			enabled="y" regexp="y" sequence="1" ignore_case="y" send_to="12" > </alias>

<!-- xmapper  -->
	<alias	match="^(?:xmap|xmapper) move (?<roomid>\d+|-1)(?: (?<speed>run|walk))?$"
			script="xmapper_move"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xm(?:\ {(?<mob>[^\}]+)\})? (?<loc>.+)$"
			script="map_area"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xmall(?:\ {(?<mob>[^\}]+)\})? (?<loc>.+)$"
			script="map_area_all"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:xm|xmap|xmapper) rlh(?: (?<room_id>\d+))?$"
			script="xmap_rooms_linking_here"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- xset commands -->
	<alias  match="^xset (?:index areas|area index)$"
			script="area_index_process"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset (?:mark|start)$"
			script="xset_to_mark"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias  match="^xset vidblain$"
			script="xset_vidblain"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias  match="^xset vidblain level(?: (?<level>\d{1,3}))?$"
			script="xset_vidblain_setlevel"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias  match="^xset speed ?(?<speed>run|walk)?$"
			script="set_speed"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset sendecho$"
			script=""
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset kw$"
		script="set_mob_keyword"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset kw (?<keyword>.+)$"
		script="set_current_mob_keyword"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset nx$"
		script="xset_nx_check"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset nx (?<action>smartscan|con|scan|scanhere|qs|none)$"
		script="xset_nx"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias  match="^xset con_overwrite"
		script="xset_con_overwrite"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset sound$"
		script="xset_sound"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- xset window commands -->
	<alias	match="^xset fontsize.*$"
			script="deprecated_xset_font_size"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset linespace.*$"
			script="deprecated_xset_line_space"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset winreset$"
			script="xg_create_window"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" >
				<send>	win_init = false	</send> </alias>

	<alias	match="^xset (?:window|win) (?<onoff>on|off|show|hide|0|1|true|false|max(?:imize)?|expand|min(?:imize)?|collapse)$"
			script="xset_ToggleWindowDisplay"
			enabled="y" regexp="y" sequence="100" > </alias>

	<alias	match="^(?:xw|xwh|xwhere)( (?<n1>\d+))?( (?<n2>\d+))?( (?<mob>.+))?$"
			script="do_xwhere"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:xg|xgui) (?:ref|refresh)$"
			script="xgui_RefreshLinks"
			enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>

	<alias	match="^(?:xg|xgui) (?:rel|reload)$"
			script="xgui_ReloadLinks"
			enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>

<!-- xset page size (area index process) -->
	<alias	match="^xset suspend page size$"
			script="suspend_page_size"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset resume page size$"
			script="resume_page_size"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- xtest commands -->
	<alias  match="^xtest areadata$"
			script="xtest_areadata"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest mcvars$"
			script="xtest_mcvars"
			enabled="y" regexp="y" sequence="100" > </alias>

	<alias	match="^xtest roomhist$"
			script="xtest_roomhist"
			enabled="y" regexp="y" sequence="100" > </alias>

	<alias	match="^xtest simulate cp(?: (?<type>area|room))?$"
			script="simulate_cp"
			enabled="y" regexp="y" sequence="1" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest simulate level (?<level>\d{1,3})$"
			script="spoof_level"
			enabled="y" regexp="y" sequence="1" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest simulate q(?:uest)?(?: (?<status>start|status|killed|comp|fail|reset|ready|timeout|statkilled|wait|ready))?$"
			script="simulate_quest"
			enabled="y" regexp="y" sequence="1" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest loadroom(?: (?<roomid>\d+))?$"
			script="xtest_loadroom"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest popmsg$"
			script="xtest_popmsg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest debug$"
			script="xtest_debug"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias  match="^snd reload$"
			script="sndReload"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- New commands -->
	<alias	match="^x?m(?:ob)?s(?:earch)? ([\p{P}\w]+)(?:\s([^0-9]+))?(?:\s+(\d+))?$"
			script="onSearch"
			group="Mob_Database"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias 	match="^x?mgo(?:to)? (\d+)$"
			script="mobGo"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias 	match="^(snd migrate|mergePwar)$"
			script="copyPwarWarn"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias 	match="^(snd migrate|mergePwar) confirm$"
			script="copyPwarDB"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>


	<alias	match="snd changelog"
			enabled="y" sequence="100" ignore_case="y" send_to="12" >
			<send>get_changelog(true)</send> </alias>
</aliases>
</muclient>

<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE muclient>
<!-- Saved on Saturday, July 05, 2008, 4:46 PM -->
<muclient>
<plugin version="5.5" name="Search_and_Destroy" id="30000000537461726C696E67" date_written="2018-12-31 23:00:00" author="Crowley, branched from Starling" language="Lua" purpose="Safe, legal Search and Destroy" save_state="y" requires="4.90" >
<description trim="n"> </description> </plugin>

<!-- Isolinear intermatrix (utility module) -->
<include name="constants.lua"/>
<variables><variable name="example"></variable></variables>

<timers>
	<timer name="tim_init_plugin"
		second="0.5" active_closed="y"
		script="init_plugin"
		enabled="y" send_to="12" > </timer>

	<timer name="execute_in_area_timer"
		second="0.1"
		script=""
		enabled="n" send_to="12">
			<send>	execute_in_area_tick() </send> </timer>

	<timer name="vidblain_nav_timer"
		second="0.1"
		script=""
		enabled="n" send_to="12">
			<send>	vidblain_nav_tick() </send> </timer>
</timers>

<script>
<![CDATA[
--Line 152
	-- This script was originally improved upon by Starling. Credit is due to Starling for the job she did on the plugin in the past, but in order to ensure future compliance with Aardwolf and MUSHclient, maintenance will now be provided by me. If you have any questions, feel free to shoot me a message on Personal or through tells. I'll make changes as I see fit to the code. // Crowley

	--[[ ToDo List:
		* Add ability to keyword mobs, tie in with mob database
		* Change way XRT works - if no shortname found, run to best matching area

		Fix gq: You are no longer part of Global Quest # 4683 and will be unable to rejoin. -- gq quit
				"You have now joined Global Quest # 4685. See 'help gquest' for available commands.", "You may win 2 more gquests at this level.", "You can be rewarded for 50 more kills this level."
		]]--

	--require "copytable"
	require "movewindow"
	require "serialize"
	require "tprint"
	require "wait"

	function mapFind(query)
		return CallPlugin("b6eae87ccedd84f510b74714", "map_find_query", query)
	end

--line 171

	mshow                           = {}
	showStr                         = "@W%s @wis found in @Y%s @win/around @G%s @w(@Cmapper goto %s@w)"

	PLUGIN_VERSION  = GetPluginInfo(GetPluginID(), 19)
	PLUGIN_NAME 	= GetPluginInfo(GetPluginID(), 1)
	SCHEMA_VERSION  = 2

	local current_sd_version 		= "Search & Destroy v" .. PLUGIN_VERSION
	local plugin_id_gmcp_handler 	= "3e7dedbe37e44942dd46d264"		-- easier to remember the var names than the plugin id's
	local plugin_id_gmcp_mapper		= "b6eae87ccedd84f510b74714"
	local plugin_id_z_order 		= "462b665ecb569efbf261422f"
	local plugin_id_soundpack 		= "23832d1089f727f5f34abad8"

	gqCheckPass = false

	local plugins_folder = GetPluginInfo(GetPluginID(), 20)
	local db_file_1
	local db_file_2
	local mapper_db_file = GetInfo(66)..WorldName()..".db"	-- typically aardwolf.db, normally found in main Mushclient folder
	local snd_db_file = GetInfo(66) .. "/SnDdb.db"

-- [[ Current, previous room data GMCP_room_info ]]
	local current_room  = { rmid = "-1", arid = "-1", maze = "no", exits = {} }
	local previous_room = { rmid = "-2", arid = "-2", maze = "no", exits = {} }
	local room_history = { }

-- [[ player status ]]
	local current_character_state = "0"
	local silentMode = GetVariable("mcvar_silentMode_command") or "off"
	local sortBy = GetVariable("mcvar_sortBy") or "all"

-- [[ Execute in area, room ]]
	local execute_in_area_tbl = { i=0, j=0, arid="", f="", stat=1 }
	local execute_in_room_tbl = { i=0, j=0, rmid="", f="", stat=1 }
	local vidblain_nav_tbl    = { i=0, j=0, rmid="", f="", stat=1 }

-- [[ main target data / current activity type ]]
	local main_target_list = {}
	local room_targets_ignored = {}
	local area_room_type = "init"
	local current_activity = "init"	-- valid: cp, gq, init, none = "init"

-- [[ campaign data (cpmd) ]]
	local cp_info_level = tonumber(GetVariable("mcvar_cp_level_taken")) or 0
	local cp_info_list = {}
	local cp_check_list = {}
	local last_cp_check = os.clock()

-- [[cp status, etc. ]]
	local can_get_new_cp = "no"
	local player_on_cp = "no"

-- [[ gquest data ]]
	local gqid_declared = GetVariable("mcvar_gqid_declared") or "-1"
	local gqid_joined = GetVariable("mcvar_gqid_joined") or "-1"
	local gqid_started = GetVariable("mcvar_gqid_started") or "-1"
	local gqid_extended = GetVariable("mcvar_gqid_extended") or "-1"
	local player_on_gq = "no"
	local gq_info_list = {}
	local gq_check_list = {}
	local last_gq_check = os.clock()
	local gq_info_minlvl = tonumber(GetVariable("mcvar_gq_info_minlvl")) or 0
	local gq_info_maxlvl = tonumber(GetVariable("mcvar_gq_info_maxlvl")) or 0
	local gq_info_efflvl = tonumber(GetVariable("mcvar_gq_info_efflvl")) or 0

-- [[ current target data - cp, gq, quest ]]
	local xcp_index = 0
	local quest_target = {}	-- {qmob = "", area = "", room = "", keyword="", status="0"}
	local short_mob_name = -1
	local full_mob_name = -1

-- [[ xcp action mode ]]
	local xcp_action_mode = GetVariable("mcvar_xcp_action_mode") or "qw"

-- [[ goto/nx data ]]
	local gotoArea = -1
	local gotoIndex = 0
	local gotoList = {}
	local next_room = -1

-- [[ auto-hunt ]]
	local auto_hunt_dir = ""
	local auto_hunt_mob = ""
	local autoHuntData = {}

-- [[ hunt trick ]]
	local ht = { index = 1 }

-- [[ quick where ]]
	local qw = { index = 1 }

-- [[ quick kill ]]
	local quick_kill_command = GetVariable("mcvar_quick_kill_command") or "k"

-- [[ automatic noexp ]]
	local anex_tnl_cutoff = tonumber(GetVariable("mcvar_anex_tnl_cutoff")) or 0
	local noexp_onoff = "off"
	local anex_automatic_onoff = GetVariable("mcvar_anex_automatic_onoff") or "on"

-- [[ Vidblain navigation ]]
	local xset_vidblain_level = tonumber(GetVariable("mcvar_xset_vidblain_level")) or 300
	local xset_vidblain_onoff = GetVariable("mcvar_xset_vidblain_onoff") or "off"

-- [[ Variables from old Mapper Extender ]]
	local area_range_index = {}
	local area_start_rooms = {}
	local last_area = ""
	local mapper_area_index = 0
	local speed = "run"
	local start_room_type

-- [[ Variables from old Search and Destroy ]]
	local dir_map = { north = "n", south = "s", east = "e", west = "w", up = "u", down = "d" }

-- [[ game time data ]]
	local gCycle
	local gYear
	local gYearName
	local gSeason
	local gDay
	local gHour

-- [[ Log players ]]
	local logplayer_table = {}
	local logplayer_levels
	local logplayer_hours
	local logplayer_stats
	local logplayer_qp
	local logplayer_timestamp
	local logplayer_datestamp

-- [[ S&D window data ]]
	local win = "sd_window_" .. GetPluginID()
	local windowinfo
	local win_pos_x = tonumber(GetVariable("mcvar_window_pos_x")) or 0			-- window position x,y coordinates
	local win_pos_y = tonumber(GetVariable("mcvar_window_pos_y")) or 0
	local win_width = tonumber(GetVariable("mcvar_window_width")) or 325
	local win_width_min = 325
	local win_width_max = tonumber(GetVariable("mcvar_window_width_max")) or win_width_min
	local win_height = tonumber(GetVariable("mcvar_window_height")) or 280
	local win_height_min = 60
	local win_height_max = tonumber(GetVariable("mcvar_window_height_max")) or 280
	local win_dragmove_start_x
	local win_dragmove_start_y
	local win_state = GetVariable("mcvar_window_state") or "max"
	local win_init = false
	local win_line_space = tonumber(GetVariable("mcvar_window_line_space")) or 14
	local win_font_size = tonumber(GetVariable("mcvar_window_font_size")) or 8
	local win_hotspots = {}
	local win_target_hotspots = {}

-- [[ S&D window color data]]
	local win_bgcolor = 0x000000

-- [[ Con and scan stuff ]]
	local xset_autocon_onoff = GetVariable("mcvar_xset_autocon_onoff") or "on"

	local consider_destination_room = false
	local mobs_here = {}
	local activity_target_found_here = false
	local quest_target_found_here = false
	local target_found_nearby = false
	local other_target_found_here = false
	local scanning_current_room = false
	local scan_after_con = false

-- [[ Sound settings ]]
	-- Defaults on if soundpack is enabled, off otherwise
	local xset_sound_onoff = GetVariable("mcvar_xset_sound_onoff") or (IsPluginInstalled(plugin_id_soundpack) and GetPluginInfo(plugin_id_soundpack, 17) and "on") or "off"

	local target_nearby_sound = "target_nearby.wav"
	local other_target_here_sound = "other_target_here.wav"

-- [[ S&D dev stuff ]]
	local debug_mode = GetVariable("debug_mode") or "off"

--	[[ Plugin broadcast/receive process ]]
	function OnPluginBroadcast(msg, id, name, text)
		if (id == plugin_id_gmcp_handler) then
			if (text == "char.status") then		-- character status
				current_character_state = gmcp("char.status.state")
			elseif (text == "room.info") then	-- current/previous room info
				local ri = gmcp("room.info")
				ri.maze = (string.match(ri.details, "maze") == "maze") and 1 or 0
				previous_room = current_room or { rmid="-2", arid="-2" }
				current_room = { rmid = ri.num, arid = ri.zone, exits = ri.exits, maze = ri.maze } or {}
				if (current_room.rmid == previous_room.rmid) then
					-- do nothing
				else
					if (#room_history == 300) then
						room_history[300] = nil
					end
					table.insert(room_history, 1, room_history[0])
					room_history[0] = { rmid = current_room.rmid, arid=current_room.arid }
				end

			elseif (text == "comm.quest") then	-- quest info
				local q = gmcp("comm.quest")
				quest_status_gmcp(q)
			elseif (text == "config") then		-- config data, needed for automatic noexp
				noexp_onoff = (gmcp("config.noexp") == "YES") and "on" or "off"
			end
		end
	end

-- [[ Plugin installation ]]
	function OnPluginInstall()
		ColourNote("#808080", "", "\n+=================================================================+")
		ColourNote("#FF3000", "", "    " .. current_sd_version .. " installed at " .. os.time() )
		print("")
		ColourNote("#FF3000", "", "    " .. "For support, contact Crowley" )
		ColourNote("#FF3000", "", "    " .. "Note: It's beneficial to run 'xset index areas' if you have never run it before." )
		ColourNote("#808080", "", "+=================================================================+\n")
		windowinfo = movewindow.install (win, miniwin.pos_center, miniwin.create_absolute_location, false, nil, {mouseup=MouseUp, mousedown=LeftClickOnly, dragmove=LeftClickOnly, dragrelease=LeftClickOnly},{x=win_pos_x, y=win_pos_y})
		xg_create_window()

		migrate_database()
		move_sounds()
	end

	function migrate_database()
		local db = sqlite3.open(GetInfo(66) .. "/SnDdb.db")
		local current_version

		create_initial_tables(db)

		for row in db:nrows("PRAGMA user_version") do
			current_version = row.user_version
		end

		if current_version >= SCHEMA_VERSION then return end

		Note("Migrating datase")

		-- Inidividual migrations go here
		if current_version == 0 then
			Note("Indexing areas")
			area_index_process()
		end

		if current_version < 2 then
			create_mob_keywords_table(db)
			strip_mobs_table(db)
		end

		db:execute(string.format("PRAGMA user_version = %i;", SCHEMA_VERSION))

		db:close_vm()
	end

	function create_initial_tables(db)
		local db_tables = {}
		local query = "SELECT name FROM sqlite_master WHERE type='table'"
		local create_tables = {}

		for row in db:nrows(query) do
			db_tables[row.name] = true
		end

		if not db_tables['mobs'] then
			Note("Creating table 'mobs'")
			table.insert(create_tables, [[
				CREATE TABLE mobs (
					mob 		TEXT NOT NULL,
					room 		TEXT NOT NULL,
					roomid 		INTEGER NOT NULL,
					zone 		TEXT NOT NULL,
					count 		INTEGER NOT NULL,
					keyword 	TEXT NOT NULL);
			]])
		end

		if not db_tables['area'] then
			Note("Creating table 'area'")
			table.insert(create_tables, [[
				CREATE TABLE 	area (
					name		TEXT NOT NULL,
					key			TEXT NOT NULL,
					minlvl		INTEGER NOT NULL,
					maxlvl		INTEGER NOT NULL,
					lock		INTEGER NOT NULL,
					startRoom	INTEGER,
					noquest		TEXT,
					vidblain	TEXT,
					userKey		TEXT);
			]])
		end

		if #create_tables > 0 then
			db:execute(table.concat(create_tables, ""))
		end
	end

	function create_mob_keywords_table(db)
		Note("Creating mob aliases database table")
		db:execute([[
			CREATE TABLE IF NOT EXISTS mob_keyword_exceptions (
				area_name	TEXT NOT NULL,
				mob_name	TEXT NOT NULL,
				keyword		TEXT NOT NULL,
				UNIQUE(area_name, mob_name)
			);
		]])
		populate_mob_keyword_table(db)
	end

	function strip_mobs_table(db)
		Note("Updating mobs table")
		db:execute([[
			BEGIN TRANSACTION;
			ALTER TABLE mobs RENAME TO old_mobs;
			CREATE TABLE mobs (
				mob 		TEXT NOT NULL COLLATE NOCASE,
				room 		TEXT NOT NULL COLLATE NOCASE,
				roomid 		INTEGER NOT NULL,
				zone 		TEXT NOT NULL,
				count 		INTEGER NOT NULL DEFAULT 0,
				UNIQUE(mob, roomid));
			INSERT INTO mobs SELECT mob COLLATE NOCASE, room COLLATE NOCASE, roomid, zone, SUM(count) as count FROM old_mobs GROUP BY mob COLLATE NOCASE, roomid;
			DROP TABLE old_mobs;
			COMMIT;
		]])
	end

	function move_sounds()
		move_sound(target_nearby_sound)
		move_sound(other_target_here_sound)
	end

	function move_sound(filename)
		local path = GetInfo(60) .. filename
		local f = io.open(path, "r")
		if f then
			DebugNote(string.format("Moving %s to sounds directory.", path))
			f:close()
			os.rename(path, GetInfo(74) .. filename, GetInfo)
			os.remove(path)
		end
	end

	local init_called = 0
	function init_plugin()
		if not IsConnected() then return end
		local ch_state = current_character_state
		if ((ch_state ~= "3") and (ch_state ~= "8") and (ch_state ~= "9") and (ch_state ~= "11")) then
			send_gmcp_packet("request char")
			return
		end
      	SendNoEcho("tags scan on")
		send_gmcp_packet("request room")
		init_called = init_called + 1
		if (init_called == 2) then
			EnableTimer("tim_init_plugin", false)
			load_saved_table_data()
			send_gmcp_packet("config noexp")
		end
	end

	-- Expecting an array of operations
	function execute_in_transaction(db, operations)
		query = "BEGIN TRANSACTION;" .. table.concat(operations, "") .. "COMMIT;"
		db:exec(query)
	end

-- [[ Lookup table:  Area start room, noquest true/false, vidblain areas ]]
	local areaDefaultStartRooms = {
		["abend"] 		= { start = "24909", ct = "3" },		-- Continents
		["alagh"] 		= { start =  "3224", ct = "4" },
		["gelidus"] 	= { start = "18780", ct = "2" },
		["mesolar"] 	= { start = "12664", ct = "0" },
		["southern"] 	= { start =  "5192", ct = "1" },
		["uncharted"] 	= { start =  "7701", ct = "5" },
		["vidblain"] 	= { start = "33570", ct = "6", vidblain = true },

		["aardington"] 	= { start = "47509" },		-- A --
		["academy"] 	= { start = "35233" },
		["adaldar"] 	= { start = "34400" },
		["afterglow"] 	= { start = "38134" },
		["agroth"] 		= { start = "11027" },
		["ahner"] 		= { start = "30129" },
		["alehouse"] 	= { start =   "885" },
		["amazon"] 		= { start =  "1409" },
		["amusement"] 	= { start = "29282" },
		["andarin"] 	= { start =  "2399" },
		["annwn"] 		= { start = "28963" },
		["anthrox"] 	= { start =  "3993" },
		["arboretum"] 	= { start = "39100" },
		["arena"] 		= { start = "25768" },
		["arisian"] 	= { start = "28144" },
		["ascent"] 		= { start = "43150" },
		["astral"] 		= { start = "27882" },
		["atlantis"] 	= { start = "10573" },
		["autumn"] 		= { start = "13839" },
		["avian"] 		= { start =  "4334" },
		["aylor"] 		= { start = "32418" },
		["bazaar"] 		= { start = "34454" },		-- B --
		["beer"] 		= { start = "20062" },
		["believer"] 	= { start = "25940" },
		["blackrose"] 	= { start =  "1817" },
		["bliss"] 		= { start = "29988" },
		["bonds"] 		= { start = "23411" },
		["caldera"] 	= { start = "26341" },		-- C --
		["callhero"] 	= { start = "33031" },
		["camps"] 		= { start =  "4714" },
		["canyon"] 		= { start = "25551" },
		["caravan"] 	= { start = "16071" },
		["cards"] 		= { start =  "6255" },
		["carnivale"] 	= { start = "28635" },
		["cataclysm"] 	= { start = "19976" },
		["cathedral"] 	= { start = "27497" },
		["cats"] 		= { start = "40900" },
		["chasm"] 		= { start = "29446" },
		["chessboard"]	= { start = "25513" },
		["childsplay"] 	= { start =   "678" },
		["cineko"] 		= { start =  "1507" },
		["citadel"] 	= { start = "14963" },
		["conflict"] 	= { start = "27711" },
		["coral"] 		= { start =  "4565" },
		["cougarian"] 	= { start = "14311" },
		["cove"] 		= { start = "49941" },
		["cradle"] 		= { start = "11267" },
		["crynn"] 		= { start = "43800" },
		["damned"] 		= { start = "10469" },		-- D --
		["darklight"] 	= { start = "19642", vidblain = true },
		["darkside"] 	= { start = "15060" },
		["ddoom"] 		= { start =  "4193" },
		["deadlights"] 	= { start = "16856" },
		["deathtrap"] 	= { start =  "1767" },
		["deneria"] 	= { start = "35006" },
		["desert"] 		= { start = "20186" },
		["desolation"] 	= { start = "19532" },
		["dhalgora"] 	= { start = "16755" },
		["diatz"] 		= { start =  "1254" },
		["diner"] 		= { start = "36700" },
		["dortmund"] 	= { start = "16577" },
		["drageran"] 	= { start = "25894" },
		["dread"] 		= { start = "26075" },
		["dsr"] 		= { start = "30030" },
		["dundoom"] 	= { start = "25661" },
		["dunoir"] 		= { start = "14222" },
		["duskvalley"] 	= { start = "37301" },
		["dynasty"] 	= { start = "30799" },
		["earthlords"] 	= { start = "42000" },		-- E --
		["earthplane"] 	= { start =  "1354" },
		["elemental"] 	= { start = "41624" },
		["empire"] 		= { start = "32203" },
		["empyrean"] 	= { start = "14042" },
		["entropy"] 	= { start = "29773" },
		["fantasy"] 	= { start = "15205" },		-- F --
		["farm"] 		= { start = "10676" },
		["fayke"] 		= { start = "30418" },
		["fens"] 		= { start = "16528" },
		["fields"] 		= { start = "29232" },
		["firebird"] 	= { start = "32885" },
		["firenation"] 	= { start = "41879" },
		["fireswamp"] 	= { start = "34755" },
		["fortress"] 	= { start = "31835" },
		["fortune"] 	= { start = "38561" },
		["fractured"] 	= { start = "17033" },
		["ft1"] 		= { start =  "1205" },
		["ftii"] 		= { start = "26673" },
		["gallows"] 	= { start =  "4344" },		-- G --
		["gathering"] 	= { start = "36451" },
		["gauntlet"] 	= { start = "31652" },
		["gilda"] 		= { start =  "4243" },
		["glamdursil"] 	= { start = "35055" },
		["glimmerdim"] 	= { start = "26252" },
		["gnomalin"] 	= { start = "34397" },
		["goldrush"] 	= { start = "15014" },
		["graveyard"] 	= { start = "28918" },
		["greece"] 		= { start =  "2089" },
		["gwillim"] 	= { start = "25974" },
		["hades"] 		= { start = "29161" },		-- H --
		["hatchling"]	= { start = "34670" },
		["hawklord"] 	= { start = "40550" },
		["hedge"] 		= { start = "15146" },
		["helegear"] 	= { start = "30699" },
		["hell"] 		= { start = "30984" },
		["hoard"] 		= { start =  "1675" },
		["hodgepodge"] 	= { start = "30469" },
		["horath"] 		= { start =    "91" },
		["horizon"] 	= { start = "31959" },
		["illoria"] 	= { start = "10420" },
		["imagi"] 		= { start = "36800" },		-- I --
		["imperial"] 	= { start = "16966", vidblain = true },
		["infamy"] 		= { start = "26641" },
		["infest"] 		= { start = "16165" },
		["insan"] 		= { start =  "6850" },
		["jenny"] 		= { start = "29637" },		-- J --
		["jotun"] 		= { start = "31508" },
		["kearvek"] 	= { start = "29722" },		-- K --
		["kerofk"] 		= { start = "16405" },
		["ketu"] 		= { start = "35114" },
		["kingsholm"] 	= { start = "27522" },
		["knossos"] 	= { start = "28193" },
		["kobaloi"] 	= { start = "10691" },
		["kultiras"] 	= { start = "31161" },
		["lab"] 		= { start = "28684" },		-- L --
		["labyrinth"] 	= { start = "31405" },
		["lagoon"] 		= { start = "30549" },
		["landofoz"] 	= { start =   "510" },
		["laym"] 		= { start =  "6005" },
		["legend"] 		= { start = "16224" },
		["lemdagor"] 	= { start =  "1966" },
		["lidnesh"] 	= { start = "27995" },
		["livingmine"] 	= { start = "37008" },
		["longnight"] 	= { start = "26367" },
		["losttime"] 	= { start = "28584" },
		["lowlands"] 	= { start = "28044" },
		["lplanes"] 	= { start = "29364" },
		["maelstrom"] 	= { start = "38058" },		-- M --
		["manor"] 		= { start = "10621" },
		["masq"] 		= { start = "29840" },
		["mayhem"] 		= { start =  "1866" },
		["melody"] 		= { start = "14172" },
		["minos"] 		= { start = "20472" },
		["mistridge"] 	= { start =  "4491" },
		["monastery"] 	= { start = "15756" },
		["mudwog"] 		= { start =  "2347" },
		["nanjiki"] 	= { start = "11203" },		-- N --
		["necro"] 		= { start = "29922" },
		["nenukon"] 	= { start = "31784" },
		["newthalos"] 	= { start = "23853" },
		["ninehells"] 	= { start =  "4613" },
		["northstar"] 	= { start = "11127" },
		["nottingham"] 	= { start = "11077" },
		["nulan"] 		= { start = "37900" },
		["nursing"] 	= { start = "31977" },
		["nynewoods"] 	= { start = "23562" },
		["oceanpark"] 	= { start = "39600" },		-- O --
		["omentor"] 	= { start = "15579", vidblain = true },
		["ooku"] 		= { start = "39000" },
		["origins"] 	= { start = "35900" },
		["orlando"] 	= { start = "30331" },
		["paradise"] 	= { start = "29624" },		-- P --
		["partroxis"] 	= { start =  "5814" },
		["peninsula"] 	= { start = "35701" },
		["petstore"] 	= { start =   "995" },
		["pompeii"] 	= { start =    "57" },
		["promises"] 	= { start = "25819" },
		["prosper"] 	= { start = "28268" },
		["qong"] 		= { start = "16115" },		-- Q --
		["quarry"] 		= { start = "23510" },
		["radiance"] 	= { start = "19805" },		-- R --
		["raga"] 		= { start = "19861" },
		["raukora"] 	= { start =  "6040" },
		["rebellion"] 	= { start = "10305" },
		["remcon"] 		= { start = "25837" },
		["reme"] 		= { start = "32703" },
		["rosewood"] 	= { start =  "6901" },
		["ruins"] 		= { start = "16805" },
		["sagewood"] 	= { start = "28754" },		-- S --
		["sahuagin"] 	= { start = "34592" },
		["salt"] 		= { start =  "4538" },
		["sanctity"] 	= { start = "10518" },
		["sanctum"] 	= { start = "15307" },
		["sandcastle"] 	= { start = "37701" },
		["sanguine"] 	= { start = "15436" },
		["scarred"] 	= { start = "34036" },
		["sendhian"] 	= { start = "20288", vidblain = true },
		["sennarre"] 	= { start = "15491" },
		["shadowsend"]	= { start = "40096" },
		["shouggoth"] 	= { start = "34087" },
		["siege"] 		= { start = "43265" },
		["sirens"] 		= { start = "16298" },
		["slaughter"] 	= { start =  "1601" },
		["snuckles"] 	= { start =   "182" },
		["soh"] 		= { start = "25611" },
		["sohtwo"] 		= { start = "30752" },
		["solan"] 		= { start = "23713" },
		["songpalace"] 	= { start = "47013" },
		["spyreknow"] 	= { start = "34800" },
		["stone"] 		= { start = "11386" },
		["storm"] 		= { start =  "6304" },
		["stormhaven"] 	= { start = "20649" },
		["stronghold"] 	= { start = "20572" },
		["stuff"] 		= { start = "40400" },
		["takeda"] 		= { start = "15952" },		-- T --
		["talsa"] 		= { start = "26917" },
		["temple"] 		= { start = "31597" },
		["tanra"] 		= { start = "46913" },
		["terra"] 		= { start = "19679" },
		["terramire"] 	= { start =  "4493" },
		["thieves"] 	= { start =     "7" },
		["tilule"]		= { start = "39771"	},
		["times"] 		= { start = "28463" },
		["tirna"] 		= { start = "20136" },
		["titan"] 		= { start = "38234" },
		["tol"] 		= { start = "16325" },
		["tombs"] 		= { start = "15385" },
		["umari"] 		= { start = "36601" },		-- U --
		["underdark"] 	= { start = "27341" },
		["uplanes"] 	= { start = "29364" },
		["uprising"] 	= { start = "15382" },
		["vale"] 		= { start =  "1036" },		-- V --
		["verdure"] 	= { start = "24090" },
		["verume"] 		= { start = "30607" },
		["village"] 	= { start = "30850" },
		["vlad"] 		= { start = "15970" },
		["volcano"] 	= { start =  "6091" },
		["weather"] 	= { start = "40499" },		-- W --
		["werewood"] 	= { start = "30956" },
		["wildwood"] 	= { start =   "322" },
		["winter"] 		= { start =  "1306" },
		["wizards"] 	= { start = "31316" },
		["wonders"] 	= { start = "32981" },
		["wooble"] 		= { start = "11335" },
		["woodelves"] 	= { start = "32199" },
		["wtc"] 		= { start = "37895" },
		["wyrm"] 		= { start = "28847" },
		["xmas"] 		= { start =  "6212" },		-- X --
		["xylmos"] 		= { start =   "472" },
		["yarr"] 		= { start = "30281" },
		["ygg"] 		= { start = "24186" },		-- Y --
		["yurgach"] 	= { start = "29450" },
		["zangar"] 		= { start =  "6164" },		-- Z --
		["zodiac"] 		= { start = "15857" },
		["zoo"] 		= { start =  "5920" },
		["zyian"] 		= { start =   "729" },
		-- Non-questable Areas
		["manor1"] 		= { start = "14460", noquest = true },		-- Manor areas
		["manor3"] 		= { start = "20836", noquest = true },
		["manorisle"] 	= { start =  "6366", noquest = true },
		["manormount"] 	= { start = "39449", noquest = true },
		["manorsea"] 	= { start = "35003", noquest = true },
		["manorville"] 	= { start = "35004", noquest = true },
		["manorwoods"] 	= { start = "35002", noquest = true },
		["blackclaw"]	= { start = "   -1", noquest = true }, -- epic areas
		["geniewish"] 	= { start = "38464", noquest = true },
		["icefall"] 	= { start = "38701", noquest = true },
		["inferno"]		= { start =    "-1", noquest = true },
		["oradrin"] 	= { start = "25436", noquest = true },
		["winds"] 		= { start = "39900", noquest = true },

		["badtrip"] 	= { start = "32877", noquest = true },		-- Other no-quest areas
		["birthday"]	= { start = "10920", noquest = true },
		["seaking"]		= { start =    "-1", noquest = true },
		["amazonclan"] 	= { start = "34212", noquest = true },		-- Public clan halls
		["bard"] 		= { start = "30538", noquest = true },
		["bootcamp"] 	= { start = "49256", noquest = true },
		["cabal"] 		= { start = "15704", noquest = true },
		["chaos"] 		= { start = "28909", noquest = true },
		["crimson"] 	= { start = "27989", noquest = true },
		["crusaders"] 	= { start = "31122", noquest = true },
		["daoine"] 		= { start = "30949", noquest = true },
		["doh"] 		= { start = "16803", noquest = true },
		["dominion"] 	= { start =  "5863", noquest = true },
		["dragon"] 		= { start =   "642", noquest = true },
		["druid"] 		= { start = "29582", noquest = true },
		["emerald"] 	= { start =   "831", noquest = true },
		["gaardian"] 	= { start = "20026", noquest = true },
		["imperium"] 	= { start = "30415", noquest = true },
		["light"] 		= { start =  "2339", noquest = true },
		["loqui"] 		= { start = "28580", noquest = true },
		["masaki"] 		= { start = "15852", noquest = true },
		["perdition"] 	= { start = "19968", noquest = true },
		["pyre"] 		= { start = "15141", noquest = true },
		["romani"] 		= { start = "24180", noquest = true },
		["seekers"] 	= { start = "14165", noquest = true },
		["shadokil"] 	= { start = "32407", noquest = true },
		["tanelorn"] 	= { start = "31561", noquest = true },
		["tao"] 		= { start = "29210", noquest = true },
		["touchstone"] 	= { start = "28346", noquest = true },
		["twinlobe"] 	= { start = "15575", noquest = true },
		["vanir"] 		= { start =   "878", noquest = true },
		["watchmen"] 	= { start = "32342", noquest = true },

		["baal"] 		= { start =    "-1", noquest = true },		-- Closed clan halls
		["hook"] 		= { start =    "-1", noquest = true },
		["retri"] 		= { start =    "-1", noquest = true },
		["rhabdo"] 		= { start =    "-1", noquest = true },
		["rogues"] 		= { start =    "-1", noquest = true },
		["xunti"] 		= { start =    "-1", noquest = true },

		["challenge"]	= { start =    "-1", noquest = true },		-- Normally inaccessible areas, or which lack a sensible starting room.
		["immhomes"]	= { start =    "-1", noquest = true },
		["lasertwo"]	= { start =    "-1", noquest = true },
		["limbo"]		= { start =    "-1", noquest = true },
		["lualand"]		= { start =    "-1", noquest = true },
		["midgaard"]	= { start =    "-1", noquest = true },
		["oldclanone"] 	= { start =    "-1", noquest = true },
		["oldclantwo"] 	= { start =    "-1", noquest = true },
		["oldclanthr"] 	= { start =    "-1", noquest = true },
		["oldclanfou"] 	= { start =    "-1", noquest = true },
		["vault"]		= { start =    "-1", noquest = true },
		["warzone"]		= { start =    "-1", noquest = true },
		["wolfmaze"]	= { start =    "-1", noquest = true } }

	local vidblain_area_list = {
		["darklight"] 	= { },
		["imperial"] 	= { },
		["omentor"] 	= { },
		["sendhian"] 	= { },
		["vidblain"] 	= { } }

--	[[ Lookup table to get area id from area long name ]]
	local areaNameXref = {
		["A Genie's Last Wish"] 				= "geniewish",
		["A Magical Hodgepodge"] 				= "hodgepodge",
		["A Peaceful Giant Village"]			= "village",
		["Aardington Estate"]					= "aardington",
		["Aardwolf Zoological Park"] 			= "zoo",
		["Adventures in Sendhia"] 				= "sendhian",
		["Aerial City of Cineko"] 				= "cineko",
		["Afterglow"] 							= "afterglow",
		["Alagh, the Blood Lands"] 				= "alagh",
		["All in a Fayke Day"] 					= "fayke",
		["Ancient Greece"] 						= "greece",
		["Andolor's Ocean Adventure Park"] 		= "oceanpark",
		["Annwn"] 								= "annwn",
		["Anthrox"] 							= "anthrox",
		["Arboretum"] 							= "arboretum",
		["Arisian Realm"] 						= "arisian",
		["Art of Melody"] 						= "melody",
		["Artificer's Mayhem"] 					= "mayhem",
		["Ascension Bluff Nursing Home"] 		= "nursing",
		["Atlantis"] 							= "atlantis",
		["Avian Kingdom"] 						= "avian",
		["Battlefields of Adaldar"] 			= "adaldar",
		["Black Lagoon"] 						= "lagoon",
		["Black Rose"] 							= "blackrose",
		["Brightsea and Glimmerdim"]			= "glimmerdim",
		["Canyon Memorial Hospital"] 			= "canyon",
		["Castle Vlad-Shamir"] 					= "vlad",
		["Chaprenula's Laboratory"] 			= "lab",
		["Child's Play"] 						= "childsplay",
		["Christmas Vacation"] 					= "xmas",
		["Cloud City of Gnomalin"] 				= "gnomalin",
		["Cradlebrook"] 						= "cradle",
		["Crossroads of Fortune"] 				= "fortune",
		["Crynn's Church"] 						= "crynn",
		["Dark Elf Stronghold"] 				= "stronghold",
		["Death's Manor"] 						= "manor",
		["Deathtrap Dungeon"] 					= "deathtrap",
		["Den of Thieves"] 						= "thieves",
		["Descent to Hell"] 					= "hell",
		["Desert Doom"] 						= "ddoom",
		["Dhal'Gora Outlands"] 					= "dhalgora",
		["Diamond Soul Revelation"] 			= "dsr",
		["Dortmund"] 							= "dortmund",
		["Dread Tower"] 						= "dread",
		["Dusk Valley"] 						= "duskvalley",
		["Earth Plane 4"] 						= "earthplane",
		["Elemental Chaos"] 					= "elemental",
		["Empyrean, Streets of Downfall"] 		= "empyrean",
		["Entrance to Hades"] 					= "hades",
		["Eternal Autumn"] 						= "autumn",
		["Faerie Tales II"] 					= "ftii",
		["Faerie Tales"] 						= "ft1",
		["Fantasy Fields"] 						= "fantasy",
		["Foolish Promises"] 					= "promises",
		["Fort Terramire"] 						= "terramire",
		["Gallows Hill"] 						= "gallows",
		["Gelidus"] 							= "gelidus",
		["Giant's Pet Store"] 					= "petstore",
		["Gilda And The Dragon"] 				= "gilda",
		["Gnoll's Quarry"] 						= "quarry",
		["Gold Rush"] 							= "goldrush",
		["Guardian's Spyre of Knowledge"] 		= "spyreknow",
		["Gypsy Caravan"] 						= "caravan",
		["Halls of the Damned"] 				= "damned",
		["Hatchling Aerie"] 					= "hatchling",
		["Hedgehogs' Paradise"] 				= "hedge",
		["Helegear Sea"] 						= "helegear",
		["Hotel Orlando"] 						= "orlando",
		["House of Cards"] 						= "cards",
		["Icefall"] 							= "icefall",
		["Imagi's Nation"] 						= "imagi",
		["Imperial Nation"] 					= "imperial",
		["Insanitaria"] 						= "insan",
		["Into the Long Night"] 				= "longnight",
		["Intrigues of Times Past"] 			= "times",
		["Island of Lost Time"] 				= "losttime",
		["Jenny's Tavern"] 						= "jenny",
		["Jotunheim"] 							= "jotun",
		["Jungles of Verume"] 					= "verume",
		["Keep of the Kobaloi"] 				= "kobaloi",
		["Kerofk"] 								= "kerofk",
		["Ketu Uplands"] 						= "ketu",
		["Kiksaadi Cove"] 						= "cove",
		["Kimr's Farm"] 						= "farm",
		["Kingdom of Ahner"] 					= "ahner",
		["Kingsholm"] 							= "kingsholm",
		["Kobold Siege Camp"] 					= "siege",
		["Kul Tiras"] 							= "kultiras",
		["Land of Legend"] 						= "legend",
		["Living Mines of Dak'Tai"] 			= "livingmine",
		["Masquerade Island"] 					= "masq",
		["Mount duNoir"] 						= "dunoir",
		["Mudwog's Swamp"] 						= "mudwog",
		["Nanjiki Ruins"] 						= "nanjiki",
		["Nebulous Horizon"] 					= "horizon",
		["Necromancers' Guild"] 				= "necro",
		["Nenukon and the Far Country"] 		= "nenukon",
		["New Thalos"] 							= "newthalos",
		["Northstar"] 							= "northstar",
		["Nottingham"] 							= "nottingham",
		["Olde Worlde Carnivale"]				= "carnivale",
		["Onyx Bazaar"] 						= "bazaar",
		["Ookushka Garrison"] 					= "ooku",
		["Paradise Lost"] 						= "paradise",
		["Plains of Nulan'Boar"] 				= "nulan",
		["Pompeii"] 							= "pompeii",
		["Prosper's Island"] 					= "prosper",
		["Qong"] 								= "qong",
		["Radiance Woods"] 						= "radiance",
		["Raganatittu"] 						= "raga",
		["Realm of Deneria"] 					= "deneria",
		["Realm of the Firebird"] 				= "firebird",
		["Realm of the Sacred Flame"] 			= "firenation",
		["Realm of the Zodiac"] 				= "zodiac",
		["Rebellion of the Nix"] 				= "rebellion",
		["Rosewood Castle"] 					= "rosewood",
		["Sagewood Grove"] 						= "sagewood",
		["Sanctity of Eternal Damnation"] 		= "sanctity",
		["Sen'narre Lake"] 						= "sennarre",
		["Seven Wonders"] 						= "wonders",
		["Shadow's End"]						= "shadowsend",
		["Sheila's Cat Sanctuary"] 				= "cats",
		["Sho'aram, Castle in the Sand"] 		= "sandcastle",
		["Siren's Oasis Resort"] 				= "sirens",
		["Snuckles Village"] 					= "snuckles",
		["Storm Mountain"] 						= "storm",
		["Storm Ships of Lem-Dagor"] 			= "lemdagor",
		["Sundered Vale"] 						= "vale",
		["Swordbreaker's Hoard"] 				= "hoard",
		["Tairayden Peninsula"] 				= "peninsula",
		["Tai'rha Laym"] 						= "laym",
		["Takeda's Warcamp"] 					= "takeda",
		["Tanra'vea"] 							= "tanra",
		["Thandeld's Conflict"] 				= "conflict",
		["The Abyssal Caverns of Sahuagin"] 	= "sahuagin",
		["The Amazon Nation"] 					= "amazon",
		["The Amusement Park"] 					= "amusement",
		["The Archipelago of Entropy"] 			= "entropy",
		["The Astral Travels"] 					= "astral",
		["The Aylorian Academy"] 				= "academy",
		["The Blighted Tundra of Andarin"] 		= "andarin",
		["The Blood Opal of Rauko'ra"] 			= "raukora",
		["The Blood Sanctum"] 					= "sanctum",
		["The Broken Halls of Horath"] 			= "horath",
		["The Call of Heroes"] 					= "callhero",
		["The Cataclysm"] 						= "cataclysm",
		["The Chasm and The Catacombs"] 		= "chasm",
		["The Chessboard"] 						= "chessboard",
		["The Continent of Mesolar"] 			= "mesolar",
		["The Coral Kingdom"] 					= "coral",
		["The Cougarian Queendom"] 				= "cougarian",
		["The Council of the Wyrm"] 			= "wyrm",
		["The Covenant of Mistridge"] 			= "mistridge",
		["The Cracks of Terra"] 				= "terra",
		["The Curse of the Midnight Fens"] 		= "fens",
		["The Dark Continent, Abend"] 			= "abend",
		["The Dark Temple of Zyian"] 			= "zyian",
		["The DarkLight"] 						= "darklight",
		["The Darkside of the Fractured Lands"] = "darkside",
		["The Deadlights"] 						= "deadlights",
		["The Desert Prison"] 					= "desert",
		["The Drageran Empire"] 				= "drageran",
		["The Dungeon of Doom"] 				= "dundoom",
		["The Earth Lords"] 					= "earthlords",
		["The Eighteenth Dynasty"] 				= "dynasty",
		["The Empire of Aiighialla"] 			= "empire",
		["The Empire of Talsa"] 				= "talsa",
		["The Fabled City of Stone"] 			= "stone",
		["The Fire Swamp"] 						= "fireswamp",
		["The First Ascent"] 					= "ascent",
		["The Flying Citadel"] 					= "citadel",
		["The Forest of Li'Dnesh"] 				= "lidnesh",
		["The Fractured Lands"] 				= "fractured",
		["The Gathering Horde"] 				= "gathering",
		["The Gauntlet"] 						= "gauntlet",
		["The Gladiator's Arena"] 				= "arena",
		["The Glamdursil"] 						= "glamdursil",
		["The Goblin Fortress"] 				= "fortress",
		["The Grand City of Aylor"] 			= "aylor",
		["The Graveyard"] 						= "graveyard",
		["The Great City of Knossos"]			= "knossos",
		["The Great Salt Flats"] 				= "salt",
		["The Icy Caldera of Mauldoon"] 		= "caldera",
		["The Imperial City of Reme"] 			= "reme",
		["The Infestation"] 					= "infest",
		["The Keep of Kearvek"] 				= "kearvek",
		["The Killing Fields"] 					= "fields",
		["The Labyrinth"] 						= "labyrinth",
		["The Land of Oz"] 						= "landofoz",
		["The Land of the Beer Goblins"] 		= "beer",
		["The Lower Planes"] 					= "lplanes",
		["The Maelstrom"] 						= "maelstrom",
		["The Marshlands of Agroth"] 			= "agroth",
		["The Misty Shores of Yarr"] 			= "yarr",
		["The Monastery"] 						= "monastery",
		["The Mountains of Desolation"] 		= "desolation",
		["The Nine Hells"] 						= "ninehells",
		["The Nyne Woods"] 						= "nynewoods",
		["The Old Cathedral"] 					= "cathedral",
		["The Palace of Song"] 					= "songpalace",
		["The Partroxis"] 						= "partroxis",
		["The Path of the Believer"] 			= "believer",
		["The Realm of Infamy"] 				= "infamy",
		["The Realm of the Hawklords"] 			= "hawklord",
		["The Relinquished Tombs"] 				= "tombs",
		["The Reman Conspiracy"] 				= "remcon",
		["The Ruins of Diamond Reach"] 			= "ruins",
		["The Ruins of Stormhaven"] 			= "stormhaven",
		["The Sanguine Tavern"] 				= "sanguine",
		["The Scarred Lands"] 					= "scarred",
		["The School of Horror"] 				= "soh",
		["The Shadows of Minos"] 				= "minos",
		["The Silver Volcano"] 					= "volcano",
		["The Slaughter House"] 				= "slaughter",
		["The Southern Ocean"] 					= "southern",
		["The Stuff of Shadows"] 				= "stuff",
		["The Temple of Shal'indrael"] 			= "temple",
		["The Temple of Shouggoth"] 			= "shouggoth",
		["The Three Pillars of Diatz"] 			= "diatz",
		["The Titans' Keep"] 					= "titan",
		["The Tournament of Illoria"] 			= "illoria",
		["The Town of Solan"] 					= "solan",
		["The Tree of Life"] 					= "tol",
		["The Trouble with Gwillimberry"] 		= "gwillim",
		["The Uncharted Oceans"] 				= "uncharted",
		["The UnderDark"] 						= "underdark",
		["The Upper Planes"] 					= "uplanes",
		["The Uprising"] 						= "uprising",
		["The Were Wood"] 						= "werewood",
		["The Witches of Omen Tor"] 			= "omentor",
		["The Wobbly Woes of Woobleville"] 		= "wooble",
		["The Wood Elves of Nalondir"] 			= "woodelves",
		["The Yurgach Domain"] 					= "yurgach",
		["Tilule Rehabilitation Clinic"]		= "tilule",
		["Tir na nOg"] 							= "tirna",
		["Tournament Camps"] 					= "camps",
		["Tribal Origins"] 						= "origins",
		["Tumari's Diner"] 						= "diner",
		["Umari's Castle"] 						= "umari",
		["Unearthly Bonds"] 					= "bonds",
		["Verdure Estate"] 						= "verdure",
		["Vidblain, the Ever Dark"] 			= "vidblain",
		["War of the Wizards"] 					= "wizards",
		["Warrior's Training Camp"] 			= "wtc",
		["Wayward Alehouse"] 					= "alehouse",
		["Weather Observatory"] 				= "weather",
		["Wedded Bliss"] 						= "bliss",
		["Wildwood"] 							= "wildwood",
		["Winds of Fate"] 						= "winds",
		["Winterlands"] 						= "winter",
		["Xyl's Mosaic"] 						= "xylmos",
		["Yggdrasil: The World Tree"] 			= "ygg",
		["Zangar's Demonic Grotto"] 			= "zangar" }

-- 	[[ Lookup table: Game calendar data]]
	local gCalendar = { }

--	[[ Load saved table data ]]
	function load_saved_table_data()
		load_area_start_rooms()
		load_area_range_index()
	end

	function load_area_start_rooms()
		if (GetVariable("mcvar_areaStartRooms") ~= nil) then
			code = "obj = " .. GetVariable("mcvar_areaStartRooms")
			assert (loadstring (code or "")) ()
			area_start_rooms = obj
		end
	end

	function load_area_range_index()
		send_gmcp_packet("request room")
		if (GetVariable("mcvar_area_range") ~= nil) then
			code = "obj = " .. GetVariable("mcvar_area_range")
			assert(loadstring (code or "")) ()
			area_range_index = obj
			do_cp_info()
		else
			area_index_process()
		end
	end

--	[[ Area index process ]]
	function area_index_process()
		Execute("xset suspend page size")
		DoAfterSpecial(0.1, [[ SendNoEcho("areas 1 300 keyword") ]], sendto.script)
	end

	function area_index_start()		-- called by trigger for "Showing areas from 0 to 300" line at start of areas list.
		area_range_index = {}
		ColourNote("#FF5000", "", "*** Indexing area levels")
	end

function area_index_line(name, line, wildcards) -- 1055
	SnDdb = assert(sqlite3.open(GetInfo(66) .. "/SnDdb.db"))
	local sqlQuery = "INSERT INTO area VALUES (\"%s\", \"%s\", \"%d\", \"%d\", \"%d\", \"%d\", \"%s\", \"%s\", \"%s\")"

	local areaName = Trim(wildcards.areaName)
	local arid = Trim(wildcards.arid)
	local minLvl = tonumber(Trim(wildcards.min)) or 1
	local maxLvl = tonumber(Trim(wildcards.max)) or 201
	local levelLock = tonumber(Trim(wildcards.lock)) or 0
	local noQuest = (areaDefaultStartRooms[arid].noquest == true and "true") or "false"
	local vidblain = (tostring(areaDefaultStartRooms[arid].vidblain) == true and "true") or "false"

	if arid == "sahuagin" then
		areaName = "The Abyssal Caverns of Sahuagin"
	elseif arid == "darkside" then
		areaName = "The Darkside of the Fractured Lands"
	elseif arid == "academy" or arid == "lowlands" then
		maxLvl = 10
	elseif arid == "sohtwo" then
		minLvl = 170
	end

	area_range_index[areaName] = { arid = arid, min = minLvl, max = maxLvl }	-- lock = levelLock }

	local queryExists = "SELECT * FROM area WHERE name LIKE '%s'"

	local areaExists = false

	for a in SnDdb:rows(queryExists:format(areaName:gsub("'", "''"))) do
		if a[1] then
			areaExists = true
			break
		end
	end

	if not areaExists then
		if areaDefaultStartRooms[arid] then
			sqlQuery = sqlQuery:format(areaName, arid, minLvl, maxLvl, levelLock, areaDefaultStartRooms[arid].start, noQuest, vidblain, arid)
		else
			sqlQuery = sqlQuery:format(areaName, arid, minLvl, maxLvl, levelLock, -1, noQuest, vidblain, arid)
			ColourNote("#002800", "", "*** Missing default start room - " .. areaName)
			ColourNote("#002800", "", "*** Please update by manually running to the area and using 'xset mark'.")
		end

		SnDdb:exec(sqlQuery)
	end

	SnDdb:close()
end

	function area_index_end(name, line, wildcards)
		SetVariable("mcvar_area_range", serialize.save_simple(area_range_index))
		ColourNote("#FF5000", "", "\n*** Area levels indexed!")
		Execute("xset resume page size")
		DoAfterSpecial(0.1, "cp info", sendto.execute)
	end

--	[[ Guess mob keywords ]]
	local gmkw_omit = {	["a"] = "",	["an"] = "", ["and"] = "", ["of"] = "", ["or"] = "", ["some"] = "", ["the"] = "" }
	local gmkw_area_filters = {
		["adaldar"]		= { { f= "^.*(el)vish (%a*%s?%a+)$",			g="%1 %2" 	}, },

		["bonds"]		= { { f= "^(.*[bgry]%a+) dragon$",				g="%1"		}, },

		["citadel"]   	= {	{ f= "^([bgjlmsv]%a+) ([ap]r%a+[el]) .+$",	g="%1 %2"	}, },

		["elemental"]   = {	{ f= "^(%a+)%'(%a+) (%a+)$",				g="%1%2 %3"	},
							{ f= "^wandering (%a+)%'(%a+) (%a+)$",		g="%1%2 %3"	}, },

		["hatchling"] 	= {	{ f= "^(%a+) dragon (egg)$", 				g="%1 %2"	},
							{ f= "^(%a+) dragon (hatchling)$", 			g="%1 %2"	},
							{ f= "^(%a+ %a+) dragon whelp$", 			g="%1"		},
							{ f= "^(%a+) dragon (whelp)$", 				g="%1 %2"	}, },

		["sirens"] 		= {	{ f= "^miss ([%a']+)%s?(%a*).*%a$", 		g="%1 %2"	}, },

		["sohtwo"]		= { { f= "^(evil) %a+",							g="%1"		},
							{ f= "^(good) %a+",							g="%1"		}, },

		["verume"]		= {	{ f= "^lizardman (temple %a+)$", 			g="%1"		}, },

		["wooble"]		= {	{ f= "^sea (%a+)$", 						g="%1"		},
							{ f= "^sea (%a+ %a+)$", 					g="%1"		}, }, }

	local gmkw_exceptions = {
		["aardington"]	= { ["a very large portrait"]				= { kw="large port"			}, },

		["alehouse"]		= { ["a dancing male patron"]				= { kw="dancing male"		},
								["a dancing female patron"]				= { kw="dancing female"		},},

		["anthrox"]		= { ["the little white rabbit"]				= { kw="rabb"				},
							["the bee"]								= { kw="worker bee"			},
							["an escaped creature"]					= { kw="prisoner creature"	},
							['a "business" man']					= { kw="business man"	},},

		["ddoom"]		= { ["a dangerous scorpion"]				= { kw="scorp"				},
							["Lwji, the Sunrise great warrior"]		= { kw="lwji"				},
							["Taji, the Sunset leader"]				= { kw="taji lead"			},
							["Taji's personal advisor"]				= { kw="pers advi"			},
							["Tjac, the Sunrise leader"]			= { kw="tjac lead"			},
							["Tjac's personal advisor"]				= { kw="sunr advis"			},
							["Yki, the great Sunset warrior"]		= { kw="yki"				}, },

		["deneria"]		= { ["High Priest of Miad'Bir"] 			= { kw="high miad" 			}, },

		["desert"]		= { ["a village citizen"] 					= { kw="citi" 				}, },

		["fields"]		= { ["a mutated goat"] 						= { kw="goat" 				}, },

		["fortress"]	= { ["a grizzled goblin dressed in skins"]	= { kw="grizz gobl"		 	},
							["Blood Silk, Collector of souls, Queen of the spiders"] = { kw="silk queen" }, },

		["hell"]		= { ["a scrumptious chicken pot pie"] 		= { kw="chicken pot pie"	},
							["a yummy vegetable pot pie"] 			= { kw="vegetable pot pie"	},
							["a yummy beef pot pie"] 				= { kw="beef pot pie"		}, },

		["illoria"]		= { ["the King and Queen's Guard"]			= { kw="pers guard"			}, },

		["landofoz"]	= { ["one of Dorothy's uncles"] 			= { kw="doroth uncle"		}, },

		["laym"]		= { ["an elite guard of the church"]		= { kw="elit guar"			}, },

		["livingmine"]	= { ["a member of the 'Cal tribe"]			= { kw="memb cal"			},
							["a member of the 'Sorr tribe"]			= { kw="memb sorr"			},
							["a member of the 'Tai tribe"]			= { kw="memb tai"			},
							["Dak'tai's shaman"]					= { kw="dakt shama"			},
							["the 'Tai chieftain"]					= { kw="tai chief"			}, },

		["longnight"]	= { ["Mr. Roberge"]							= { kw="car rober"			}, },

		["losttime"]	= { ["T-Rex"]								= { kw="T-rex"				},
							["Great White Shark"]					= { kw="white shark"				}, },

		["manor"]		= { ["Aremata-Popua"] 						= { kw="aremata-pop"	 	},
							["Aremata-Rorua"] 						= { kw="aremata-ror" 		}, },

		["masq"]		= { ["a gentleman on the way to the ball"]	= { kw="gentl"				},
							["a very attractive woman"]				= { kw="attr woman"			}, },

		["necro"] 		= { ["the head necromancer's assistant"]	= { kw="old mage assist" 	}, },

		["northstar"]	= { ["a Blood Ring elite warrior"]			= { kw="elit warr"			},
							["Daryoon, a priest of nature"]			= { kw="dary pries"			},
							["Tristam, the Prince of the Orcs"]		= { kw="trist orc"			}, },

		["sanctity"]	= { ["a half-converted human"]				= { kw="human"				}, },

		["siege"]		= { ["a kobold eating lunch"]				= { kw="kobold eating"		},
							["a large mole"]						= { kw="mole"				},
							["a very large firefly"]				= { kw="larg firef"			},
							["the fattest kobold ever"]				= { kw="fat kobold"			},
							["an oddly tall and clean kobold"]		= { kw="tall kobold"			}, },

		["snuckles"]	= { ["the snuckle"]							= { kw="male snuckle"		}, },

		["sohtwo"]      = { ["An evil form of Sagen"]               = { kw="notcarlsagen"        },
							["Angelic Demonspawn"]                  = { kw="angelic"             },
							["Bubbly Obyron"]                       = { kw="fuzzybunny"          },
							["Dejected Broud"]                      = { kw="dejected"            },
							["Disagreeable Rumour"]                 = { kw="obstinate"           },
							["Disoriented Dadrake"]                 = { kw="letsturnlefthere"    },
							["Evil Aaeron"] 	                    = { kw="shinythings"         },
							["Evil Althalus"]                       = { kw="homeskillet"         },
							["Evil Belmont"]                        = { kw="bridgetroll"         },
							["Evil Domain"]                         = { kw="66"                  },
							["Evil Euphonix"]                       = { kw="ragbrai"             },
							["Evil Ghaan"]                          = { kw="longghaan"           },
							["Evil Halo"]                           = { kw="jackandcoke"         },
							["Evil Ikyu"]                           = { kw="ickypoo"             },
							["Evil Justme"]                         = { kw="helperisme"          },
							["Evil Kharpern"]                       = { kw="kittyimm"            },
							["Evil KlauWaard"]                      = { kw="tricksy"             },
							["Evil Kt"]                             = { kw="ktkat"               },
							["Evil Lasher"]                         = { kw="thearchitect"        },
							["Evil Madcatz"]                        = { kw="mathizard"           },
							["Evil Maerchyng"]                      = { kw="maerchyng"           },
							["Evil Morrigu"]                        = { kw="morrigu"             },
							["Evil OrcWarrior"]                     = { kw="sheepshagger"        },
							["Evil Pane"]                           = { kw="painintheneck"       },
							["Evil Plaideleon"]                     = { kw="crazycanadian"       },
							["Evil Rekhart"]                        = { kw="hartsawreck"         },
							["Evil Sarlock"]                        = { kw="l33td00d"            },
							["Evil Tela"]                           = { kw="telllllllla"         },
							["Evil Timeghost"]                      = { kw="floppyimm"           },
							["Good Tripitaka"]                      = { kw="laketripitaka"       },
							["Evil Tymme"]                          = { kw="hourglass"           },
							["Evil Vladia"]                         = { kw="sexyvamp"            },
							["Evil Whitdjinn"]                      = { kw="thundercat"          },
							["Evil Windjammer"]                     = { kw="justsomeimm"         },
							["Evil Wolfe"]                          = { kw="likeobybutbritish"   },
							["Evil Xyzzy"]                          = { kw="weirdcode"           },
							["Good Aerianne"]                       = { kw="pointyears"          },
							["Good Cadaver"]                        = { kw="newbiehater"         },
							["Good Delight"]                        = { kw="turkishdelight"       },
							["Good Dirtworm"]                       = { kw="wormy"                },
							["Good Eclaboussure"]                   = { kw="dropbearimm"          },
							["Good Filt"]                           = { kw="plainolefilt"         },
							["Good Glimmer"]                        = { kw="betterhalfofclaire"   },
							["Good Kinson"]                         = { kw="upgradeboy"           },
							["Good Lumina"]                         = { kw="thievesrus"           },
							["Good Oladon"]                         = { kw="spellingbee"          },
							["Good Rhuli"]                          = { kw="rulistheworld"        },
							["Good Sausage"]                        = { kw="fatbreakfast"         },
							["Good Sirene"]                         = { kw="warriorprincess"      },
							["Good Takihisis"]                      = { kw="dragonlady"           },
							["Good Terrill"]                        = { kw="askcitron"            },
							["Good Tyanon"]                         = { kw="tieoneon"             },
							["Good Valkur"]                         = { kw="demonlord"            },
							["Good Vilgan"]                         = { kw="unabridged"           },
							["Good Xantcha"]                        = { kw="pokerimm"             },
							["Good Zane"]                           = { kw="inzanity"             },
							["Goodie Goodie Jaenelle"]              = { kw="goodie"               },
							["Impatient Styliann"]                  = { kw="willyouhurryup"       },
							["Kinda-Sorta Good Whisper"]            = { kw="kinda"                },
							["Master Shen"]                         = { kw="master"               },
							["Mathematical Mordist"]                = { kw="complex"              },
							["Nascaard Rezit"]                      = { kw="nascaard"             },
							["Pandemonium Penthesilea"]             = { kw="pandemonium"          },
							["Record Holding Guinness"]             = { kw="cantwriteatall"       },
							["Singing Paramore"]                    = { kw="failedmusician"       },
							["Sith Lord Neeper"]                    = { kw="sith"                 },
							["Smurfy Laren"]                        = { kw="lovethemsmurfs"       },
							["Sober Citron"]                        = { kw="sober"                },
							["Socialite Arthon"]                    = { kw="airhead"              },
							["Straight Dreamfyre"]                  = { kw="straight"             },
							["The cool version of Xeno"]            = { kw="onex"                 },
							["The Pancake Flat"]                    = { kw="pancake"              },
							["Tjopping Quadrapus"]                  = { kw="tjopping"             },
							["Unhelpful Claire"]                    = { kw="cookies"              },
							["Unremarkable Korridel"]               = { kw="unremarkable"         },
							["Unrestrained Elvandar"]               = { kw="omgsheneverstopstalking"},
							["Warsnail Anaristos"]                  = { kw="warsnail"             },
							["Cuddlebear Koala"]                    = { kw="cuddlebear"           },
							["(Helper) Fenix"]                      = { kw="helper"               },},

		["snuckles"]	= {	["Sarah, the grieving snuckle"]			= { kw="sarah griev"		}, },

		["stone"]		= { ["a Citadel of Stone Cityguard"]		= { kw="cit guar"			,} },

		["talsa"]		= { ["a dwarven mercenary"]					= { kw="dwar merc"			}, },

		["wooble"]		= { ["the Sea Snake Master-at-Arms"] 		= { kw="snake mast" 		}, },

		["yarr"]		= {	["a pirate sorting the treasure"]		= { kw="pirat sort"			},
							["a pirate stealing some treasure"]		= { kw="pirat steal"		}, },

		["zoo"]			= { ["a black-footed pine marten"]			= { kw="pine marte"			}, }, }

	function populate_mob_keyword_table(db)
		local inserts = {}
		for area, mob_keywords in pairs(gmkw_exceptions) do
			for mob_name, keyword in pairs(mob_keywords) do
				local str = string.format("INSERT INTO mob_keyword_exceptions VALUES (%s,%s,%s);", fixsql(area), fixsql(mob_name), fixsql(keyword["kw"]))
				table.insert(inserts, str)
			end
		end
		execute_in_transaction(db, inserts)
		db:execute(table.concat(inserts, ""))
	end

	function set_mob_keyword(name, line, wildcards)
		local current_area = current_room.arid
		local area_list = {}
		local db = assert(sqlite3.open(mapper_db_file))
		local i
		local area
		local mob_name
		local keyword

		for row in db:nrows("SELECT uid FROM areas ORDER BY uid ASC") do
			area_list[row.uid] = row.uid
		end

		area = utils.choose("Area", "Please choose the mob's area.", area_list, current_area)
		if not area then return end

		function require_input(input)
			return #Trim(input) > 0
		end

		mob_name = utils.inputbox("Enter the mob's full name.\nFor example: a yummy beef pot pie", "Enter mob name", nil, nil, 0, {validate = require_input})
		if not mob_name then return end
		mob_name = Trim(mob_name)

		keyword = utils.inputbox(string.format("Enter the new keyword for '%s'.\nFor example: beef pie", mob_name), "Enter new keyword", nil, nil, 0, {validate = require_input})
		if not keyword then return end
		keyword = Trim(keyword)

		if save_mob_keyword_keyword(area, mob_name, keyword) then
			if full_mob_name == mob_name then
				short_mob_name = keyword
			end
			update_main_target_list_keyword(area, mob_name, keyword)
		end
	end

	function set_current_mob_keyword(name, line, wildcards)
		local keyword = Trim(wildcards.keyword)
		local area

		if (short_mob_name == nil) or (short_mob_name == "") or (short_mob_name == "-1") or (short_mob_name == -1) then
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'kw' has no target.  Use 'ht', 'qw', or 'xcp' to select a target, or use 'xset kw' with no arguments.")
		else
			if quest_target.mob and quest_target.mob == full_mob_name then
				area = quest_target.arid
			end

			if not area then
				area = main_target_list[xcp_index].arid
			end

			if not area then
				ColourNote("#FF5000", "", "\nSearch and Destroy: Target's area could not be identified. Try visiting its area and trying again.")
				return
			end

			if save_mob_keyword_keyword(area, full_mob_name, keyword) then
				short_mob_name = keyword
				update_main_target_list_keyword(area, full_mob_name, keyword)
			end
		end
	end

	function update_main_target_list_keyword(area, mob_name, keyword)
		for i, mobdesc in ipairs(main_target_list) do
			if area == mobdesc.arid and mob_name == mobdesc.mob then
				mobdesc.kw = keyword
			end
		end
	end

	function save_mob_keyword_keyword(area, mob_name, keyword)
		local found_area = false
		local query

		local db = assert(sqlite3.open(snd_db_file))
		query = string.format("INSERT OR REPLACE INTO mob_keyword_exceptions VALUES (%s,%s,%s);", fixsql(area), fixsql(mob_name), fixsql(keyword))
		db:exec(query)
		db:close_vm()

		ColourNote(
			"", "", "Updated keyword for ",
			"lime", "", mob_name,
			"", "", " to ",
			"lime", "", keyword,
			"", "", " in area ",
			"lime", "", area .. "\n"
		)
		return true
	end

	function gmkw(s, a)	-- guess mob keywords
		if not s then return "" end
		local ri = current_room
		local ar = a or ri.zone
		local guess

		local db = sqlite3.open(snd_db_file)
		query = string.format("SELECT keyword FROM mob_keyword_exceptions WHERE area_name = %s AND mob_name = %s LIMIT 1;", fixsql(ar), fixsql(s))
		for row in db:nrows(query) do
			guess = row.keyword
		end
		db:close_vm()

		if guess then
			DebugNote(string.format("Found custom keyword for '%s': %s", s, guess))
			return guess
		end

		local omit = gmkw_omit
		local s1 = {}
		for w in string.gmatch(string.lower(s), "[^ ]+") do
			w = string.gsub(w, "%p%-", "")
			w = string.gsub(w, ",", "")
			w = string.gsub(w, "%.", "")
			w = string.gsub(w, "'s$", "")
			w = string.gsub(w, "[!?]+$", "")
			table.insert(s1, w)
		end

		local s2
		for i,v in ipairs (s1) do
			if omit[v] then
				-- do nothing
			else
				s2 = (s2 == nil) and v or s2 .. " " .. v
			end
		end

		local s3
		if gmkw_area_filters[ar] then
			for i,v in ipairs (gmkw_area_filters[ar]) do
				s3 = string.gsub(s2, v.f, v.g)
				if (s3 ~= s2) then
					break
				end
			end
		else
			s3 = s2
		end
		s3 = string.gsub(s3, "-", " ")

		local s4 = {}
		for w in string.gmatch(s3, "[^ ]+") do
			table.insert(s4, w)
		end
		local len1 = #(s4[1])
		local len2 = #(s4[#s4]) or 0
		if (#s4 > 1) then	-- mob name has multiple words
			local x,y = math.random(4,6), math.random(4,6)
			guess = string.sub(s4[1], 1, x) .. " " .. string.sub(s4[#s4], 1, y)
		elseif (#s4 == 1) then	-- mob name has one word
			local x = math.random(2 + round_banker(len1*0.5), len1)
			guess = string.sub(s4[1], 1, x)
		else										-- Sometimes all of the mob words get deleted, if so just use original input.  In theory, if we reached this step
			guess = s or "gmkw error in stage 4"  	-- then the input is non-nil and I've never seen it be "" ... so, if it errors it means Lua is propagating a nil
		end-- somehow or doing one of the other mickey mouse nonsense things that Lua likes to do.
		return guess
	end

--	[[ Detect campaign (or gquest) type - area or room ]]
	function area_room_type_check(list)
		local areaCount = 0
		local roomCount = 0
		local ar_rm
		for i,v in ipairs (list) do
			if areaNameXref[v.loc] then
				areaCount = areaCount + 1
			else
				roomCount = roomCount + 1
			end
		end
		if (areaCount >= roomCount) then
			ar_rm = "area"
		else
			ar_rm = "room"
		end
		return ar_rm
	end

--	[[ Quest target process ]]
	function xq_command()	-- enables 'xq' command (reload quest info)
		send_gmcp_packet("request quest")
	end

	function target_quest_mob(bool)	-- Re-targets your quest mob if you un-target it somehow (xcp, etc.)
		local qt = quest_target
		xcp_clear_target(true)
		qw_reset(false)
		if (qt.mob == "missing") and (qt.arid == nil) and (qt.areaName == nil) and (qt.room == nil) then
			qt.mob = GetVariable("mcvar_qt_mob")
			qt.arid = GetVariable("mcvar_qt_arid")
			qt.areaName = GetVariable("mcvar_qt_areaName")
			qt.room = GetVariable("mcvar_qt_mob")
			if (bool == true) then
				ColourNote("#FF1010", "", "\n'Target quest mob' (xq) not done - the mob is currently dead, or you can't see it (check detects).")
				ColourNote("#FF1010", "", "\n'The last known location, before it went missing, was:\n")
				ColourNote("#FF5000", "", "mob : ",
							"#00C040", "", qt.mob.." ")
				ColourNote("#FF5000", "", "area: ",
							"#00C040", "", qt.areaName .. " ("..qt.arid..")")
				ColourNote("#FF5000", "", "room: ",
							"#00C040", "", qt.room)
			end
		else
			full_mob_name = qt.mob
			short_mob_name = gmkw(qt.mob, qt.arid)
			SetVariable("mcvar_qt_mob", qt.mob)
			SetVariable("mcvar_qt_arid", qt.arid)
			SetVariable("mcvar_qt_areaName", qt.areaName)
			SetVariable("mcvar_qt_room", qt.room)
			if (bool == true) then
				ColourNote("#FF5000", "", "\nYour quest mob is: \n")
				ColourNote("#FF5000", "", "mob : ",
						"#00C040", "", qt.mob.." ")
				ColourNote("#FF5000", "", "area: ",
						"#00C040", "", qt.areaName .. " ("..qt.arid..")")
				ColourNote("#FF5000", "", "room: ",
						"#00C040", "", qt.room)
			end
		end
		search_rooms(string.format("%s|%s", qt.room, qt.arid), "area", qt.mob)
	end

	function quest_status_gmcp(q)	-- sets quest status when you take a new quest, kill qmob, complete quest, etc.
		if (q.action == "start") then									-- you've just taken a new quest
			quest_target = { qstat = "2", mob = q.targ,	areaName = q.area, arid = areaNameXref[q.area], room = (string.gsub(q.room, "@[bcgmrwyBCDGMRWY]", "")) }
			target_quest_mob(true)
		elseif (q.action == "status" and q.targ and q.timer) then		-- on quest, qmob not yet killed
			quest_target = { qstat="2", mob = q.targ, areaName = q.area, arid = areaNameXref[q.area], room = (string.gsub(q.room, "@[bcgmrwyBCDGMRWY]", "")) }
			target_quest_mob(true)
		else
			if (q.action == "killed") then	-- you've just killed the target
				quest_target.qstat = "3"
			--elseif (q.action == "start") then	-- you've just taken a new quest
			--	quest_target = { qstat = "2", mob = q.targ,	areaName = q.area, arid = areaNameXref[q.area], room = (string.gsub(q.room, "@[bcgmrwyBCDGMRWY]", "")) }
			--	target_quest_mob(true)
			elseif (q.action == "comp") or (q.action == "fail") or (q.action == "reset") then -- quest has ended (completed, failed, or reset)
				quest_target = { qstat="1"}
				xcp_clear_target(false)
				qw_reset(false)
			elseif (q.action == "ready") or (q.action == "timeout") then -- can take new quest immediately
				quest_target = { qstat="0"}

			-- in all of these, the action is "status"
			elseif (q.action == "status" and q.target == "killed") then		-- on quest, qmob has been killed (do not confuse q.target with q.targ above!)
				quest_target.qstat = "3"
				ColourNote("#FF5000", "", "\nSearch and Destroy: You have already killed your quest target!\n")
			--elseif (q.action == "status" and q.targ and q.timer) then		-- on quest, qmob not yet killed
			--	quest_target = { qstat="2", mob = q.targ, areaName = q.area, arid = areaNameXref[q.area], room = (string.gsub(q.room, "@[bcgmrwyBCDGMRWY]", "")) }
			--	target_quest_mob(true)
			elseif (q.action == "status" and (q.wait)) then					-- off quest, must wait before requesting new
				quest_target = { qstat="1"}
				ColourNote("#FF5000", "", "\nSearch and Destroy: Not on quest - must wait before requesting new.\n")
			elseif (q.action == "status" and q.status == "ready") then		-- off quest, can request new quest immediately
				quest_target = { qstat="0"}
				ColourNote("#FF5000", "", "\nSearch and Destroy: Not on quest - can request new quest immediately. \n")
			end
			SetVariable("mcvar_qt_mob", "")
			SetVariable("mcvar_qt_arid", "")
			SetVariable("mcvar_qt_areaName", "")
			SetVariable("mcvar_qt_room", "")
		end
	end

--	[[ "cp info" process path ]]
	function do_cp_info()
		cp_info_list = {}
		main_target_list = {}
		room_targets_ignored = {}
		xcp_index = 0
		EnableTrigger("trg_cp_info_level_taken", true)
		EnableTrigger("trg_cp_info_targets", true)
		SendNoEcho("cp info")
		xg_draw_window()	-- redraw window during latency period between sending the command and receiving a response, which would otherwise be 'dead' time.
	end

	function cp_info_level_taken(name, line, wildcards)
		local x = tonumber(wildcards.level)
		cp_info_level = x
		SetVariable("mcvar_cp_level_taken", x)
	end

	function cp_info_line(name, line, wildcards)
		local t = cp_info_list
		local mob = wildcards.mob
		local loc = wildcards.loc
		local ord = #t+1
		table.insert(t, { mob=mob, loc=loc, ord=ord } )
	end

	function cp_info_end()
		player_on_cp = "yes"
		current_activity = "cp"
		local t = cp_info_list
		area_room_type = area_room_type_check(t)
		print("cp type detection: ".. area_room_type .." (level "..cp_info_level..")\n")
		xg_draw_window()
		DoAfterSpecial(0.1, [[ do_cp_check() ]], sendto.script)
	end

--	[[ "cp check" process path ]]
	function do_cp_check()
		local time_check = os.clock()					-- prevent double cp checks from different plugins
		if ((time_check - last_cp_check) < 1.0) then
			return
		end
		last_cp_check = time_check
		cp_check_list = {}
		EnableTrigger("trg_cp_check_line", true)
		SendNoEcho("cp ch")
	end

	function cp_check_line(name, line, wildcards)
		local t = cp_check_list
		local mob = wildcards.mob
		local qty = 1
		local kw = ""
		local loc = wildcards.loc
		local is_dead = ((wildcards.isdead == "") and "no" or "yes")
		local ord = #t + 1
		table.insert(t, { mob=mob, qty=qty, loc=loc, is_dead=is_dead, ord=ord })
	end

	function cp_check_end(name, line, wildcards)
		player_on_cp = "yes"
		current_activity = "cp"
		build_main_target_list("cp", area_room_type)
		if (xcp_retry_stat == 2) then						-- About xcp_retry_stat:
			if (xcp_index == 0) or (xcp_index == 1) then
				xcp_retry_stat = 0							-- after killing cp mob, it's possible to 'xcp' after tables are cleared,
				xcp_noarg()									-- but before they're refreshed, which would cause 'xcp' to fail with the
			else											-- message "no data yet".  Instead, cp_mob_killed sets a flag that does
				xcp_retry_stat = 0							-- two things: 1) tells 'xcp' to silently abort, 2) tells cp_check_end to
				xcp_arg("", "", {index=xcp_index}) 			-- do xcp again (with or without arg), which works normally now that
			end												-- table data is available.
		end
		xcp_retry_stat = 0				--Execute("xcp " .. xcp_index)
	end

--	[[ general cp status functions ]]
	function player_start_new_cp()	-- called by line "good luck on your campaign" when starting new cp
		player_on_cp = "yes"
		can_get_new_cp = "no"
		local x = tonumber(gmcp("char.status.level"))
		cp_info_level = x
		current_activity = "cp"
		xg_draw_window()
		if (noexp_onoff == "on") and (anex_tnl_cutoff > 0) then
			ColourNote("#FF5000", "#000000", "Search and Destroy: Turning 'noexp' OFF (you have started a new CP)")
			anex_set_noexp("off")
		end
		do_cp_info()
	end

	function cp_mob_killed()
		if (player_on_gq == "no") then
			xcp_retry_stat = 1
			qw_reset(false)
			if main_target_list[xcp_index] then
				main_target_list[xcp_index].color = "#404040"
			end
			xcp_clear_target(true)
			DoAfterSpecial(0.1, "do_cp_check()", 12)
		end
	end

	function player_level_up()
		can_get_new_cp = "yes"
		xg_draw_window()
	end

	function player_is_on_cp()
		player_on_cp = "yes"
	end

	function do_cp_complete(name, line, wildcards)
		player_not_on_cp()
	end

	function player_not_on_cp()
		player_on_cp = "no"
		EnableTriggerGroup ("trg_campaign", false)
		cp_info_level = "0"
			SetVariable("mcvar_cp_level_taken", "0")
		cp_info_list = {}
		cp_check_list = {}
		if (player_on_gq == "yes") then
			-- do nothing, we don't want to clear our gq info
		else
			main_target_list = {}
			room_targets_ignored = {}
			area_room_type = "none"
			current_activity = "none"
			xcp_index = 0
			xg_draw_window()
		end
	end

	function cp_check_can_get_new_cp()
		can_get_new_cp = "yes"
		anex_can_get_new_cp()
		xg_draw_window()
	end

	function cp_check_cannot_get_new_cp()
		can_get_new_cp = "no"
		anex_must_level_new_cp()
		xg_draw_window()
	end

	function can_player_get_new_cp()
		return (can_get_new_cp == "yes") and true or false
	end

--	[[ Gquest beginning event messages: declare, join, start ]]
	function gqmsg_declared(name, line, wildcards)
		gqid_declared = wildcards.gq_id
			SetVariable("mcvar_gqid_declared", gqid_declared)
		gqid_joined = "-1"
			SetVariable("mcvar_gqid_joined", "-1")
		gqid_started = "-1"
			SetVariable("mcvar_gqid_started", "-1")
		gqid_extended = "-1"
			SetVariable("mcvar_gqid_extended", "-1")
	end

	function gqmsg_joined(name, line, wildcards)
		gqid_joined = wildcards.gq_id
		SetVariable("mcvar_gqid_joined", gqid_joined)
		if (gqid_joined == gqid_started) then
			EnableTriggerGroup("trg_gqmsg_2", true)
			do_gq_info()
		end
	end

	function gqmsg_started(name, line, wildcards)
		gqid_started = wildcards.gq_id
		SetVariable("mcvar_gqid_started", gqid_started)
		if (gqid_started == gqid_joined) then
			EnableTriggerGroup("trg_gqmsg_2", true)
			do_gq_info()
		end
	end

--	[[ Gquest info functions ]]
	function do_gq_info()
		if (gqid_joined ~= "-1") then
			xcp_clear_target(false)
			main_target_list = {}
			room_targets_ignored = {}
			gq_info_list = {}
			EnableTrigger("trg_gq_info_quest_name", true)
			SendNoEcho("gq info " .. gqid_joined)
			--DoAfterSpecial(0.1, [[ Send("gq info .. ]] .. gqid_joined .. [[")]], sendto.script)
		else
			print("\ndo_gq_info: You haven't joined a gquest.")
		end
	end

	function gq_info_quest_name(name, line, wildcards)
		local gqid = wildcards.gq_id
		if (gqid == gqid_joined) then
			EnableTrigger("trg_gq_info_quest_status", true)
			player_is_on_gq()
		elseif gqCheckPass then
			gqid_joined = gqid
			gqCheckPass = false
			EnableTrigger("trg_gq_info_quest_status")
			player_is_on_gq()
		else
			print("gq info name fail")
		end
	end

	function gq_info_quest_status(name, line, wildcards)
		local status = wildcards.status
		if (status == "Active") or (status == "Extended") then
			EnableTrigger("trg_gq_info_level_range", true)
		end
	end

	function gq_info_level_range(name, line, wildcards)
		local min = tonumber(wildcards.minlvl)
		local max = tonumber(wildcards.maxlvl)
		local eff = math.floor((min + max) / 2)
		gq_info_minlvl = min
			SetVariable("mcvar_gq_info_minlvl", min)
		gq_info_maxlvl = max
			SetVariable("mcvar_gq_info_maxlvl", max)
		gq_info_efflvl = eff
			SetVariable("mcvar_gq_info_efflvl", eff)
	end

	function gq_info_line(name, line, wildcards)
		local t = gq_info_list
		local mob = wildcards.mob
		local qty = wildcards.qty
		local loc = wildcards.loc
		local ord = #t+1
		table.insert(t, { mob=mob, qty=qty, loc=loc, ord=ord } )
	end

	function gq_info_end()
		player_is_on_gq()	-- more redundancy.  gq's are a pain
		area_room_type = area_room_type_check(gq_info_list)
		cp_info_level = tonumber(gmcp("char.status.level"))	-- room target builder will crash without a sensible value here.  Just use current player level.
		print("gq type detection: " .. area_room_type .. " (level " .. cp_info_level .. ")\n")
		xg_draw_window()
		DoAfterSpecial(0.1, "do_gq_check()", sendto.script)
	end

--	[[ Gquest check functions ]]
	function do_gq_check()
		player_is_on_gq()
		local time_check = os.clock()					-- prevent double cp checks from different plugins
		if ((time_check - last_cp_check) < 1.0) then
			return
		end
		last_gq_check = time_check
		gq_check_list = {}
		EnableTrigger("trg_gq_check_line", true)
		DoAfterSpecial(0.1, 'SendNoEcho("gq ch")', sendto.script)
	end

	function gq_check_line(name, line, wildcards)
		local t = gq_check_list
		local mob = wildcards.mob
		local qty = wildcards.qty
		local loc = wildcards.loc
		local is_dead = (wildcards.isdead == "" and "no" or "yes")
		local ord = #t+1
		table.insert(t, { mob=mob, qty=qty, loc=loc, is_dead=is_dead, ord=ord })
	end

	function gq_check_end()
		player_is_on_gq()
		build_main_target_list("gq", area_room_type)
		if (xcp_retry_stat == 2) then						-- About xcp_retry_stat:
			if (xcp_index == 0) or (xcp_index == 1) then
				xcp_retry_stat = 0							-- after killing gq mob, it's possible to 'xcp' after tables are cleared,
				xcp_noarg()									-- but before they're refreshed, which would cause 'xcp' to fail with the
			else											-- message "no data yet".  Instead, gq_mob_killed sets a flag that does
				xcp_retry_stat = 0							-- two things: 1) tells 'xcp' to silently abort, 2) tells gq_check_end to
				Execute("xcp " .. xcp_index)				-- do 'xcp' again (with or without arg), which works normally now that
			end												-- table data is available.
		end
		xcp_retry_stat = 0
	end

--	[[ Gquest general status functions ]]
	function gq_mob_killed()
		if main_target_list[xcp_index] then
			local x = tonumber(main_target_list[xcp_index].qty) - 1
			main_target_list[xcp_index].qty = x
			if (#main_target_list > 1) then
				if x and (x > 0) then
					xg_draw_window()
					print_target_links(main_target_list)
				else
					qw_reset(false)
					xcp_retry_stat = 1
					main_target_list[xcp_index].color = "#404040"
					xcp_clear_target(true)
					DoAfterSpecial(0.1, "do_gq_check()", 12)
				end
			elseif (#main_target_list == 1) then
				if x and (x > 0) then
					xg_draw_window()
					print_target_links(main_target_list)
				else
					qw_reset(false)
					xcp_clear_target(false)
				end
			end
		else
			qw_reset(false)
			xcp_retry_stat = 1
			xcp_clear_target(false)
			DoAfterSpecial(0.1, "do_gq_check()", 12)
		end
	end

	function gqmsg_winner(name, line, wildcards)
		local gqid = wildcards.gq_id
		local winner = wildcards.winner
		local you = gmcp("char.base.name")
		if (winner == you) then
			ColourNote("#FFFFFF", "", "\nA WINNER IS YOU\n")
			player_not_on_gq()
		elseif (gqid == gqid_joined) then
			EnableTrigger("trg_gqmsg_extended_time", true)
			DoAfterSpecial(0.5, "gq_check_if_extended()", sendto.script)
		else
			-- do nothing, message is for a different gq.
		end
	end

	function gqmsg_extended_time(name, line, wildcards)
		local gqid = wildcards.gq_id
		if (gqid == gqid_joined) then
			gqid_extended = gqid
		end
	end

	function gq_check_if_extended()
		EnableTrigger("trg_gqmsg_extended_time", false)
		if (gqid_extended == gqid_joined) then
			-- do nothing
		else
			player_not_on_gq()
		end
	end

	function gq_check_not_yet_started(name, line, wildcards)
		gqid_joined = wildcards[1]
		player_is_on_gq()
		gqid_started = "-1"
			SetVariable("mcvar_gqid_started", "-1")
	end

	function player_is_on_gq()
		player_on_gq = "yes"
		current_activity = "gq"
	end

	function player_not_on_gq()
		EnableTriggerGroup("trg_gq", false)
		EnableTriggerGroup("trg_gqmsg_2", false)
		EnableTrigger("trg_gqmsg_extended_time", false)
		player_on_gq = "no"
		area_room_type = "none"
		current_activity = "none"
		gq_info_list = {}
		gq_check_list = {}
		main_target_list = {}
		room_targets_ignored = {}

		gqid_declared = "-1"
			SetVariable("mcvar_gqid_declared", gqid_declared)
		gqid_joined = "-1"
			SetVariable("mcvar_gqid_joined", gqid_joined)
		gqid_started = "-1"
			SetVariable("mcvar_gqid_started", gqid_started)
		gqid_extended = "-1"
			SetVariable("mcvar_gqid_extended", gqid_extended)

		gq_info_minlvl = "-1"
			SetVariable("mcvar_gq_info_minlvl", gq_info_minlvl)
		gq_info_maxlvl = "-1"
			SetVariable("mcvar_gq_info_maxlvl", gq_info_maxlvl)

		xcp_clear_target(true)

		if (player_on_cp == "yes") then
			DoAfterSpecial(0.4, [[ ColourNote("#FF5000", "#000000", "Reloading your cp targets....")
								do_cp_info() ]], sendto.script)
		end
	end

--	[[ Build main target list process path ]]
	function build_main_target_list(cp_or_gq, area_or_room)
		local cp_gq = cp_or_gq
		local ar_rm = area_or_room

		local sqla = " SELECT uid as arid, name as areaName " .. "FROM areas " .. "WHERE name = %s " .. "ORDER BY arid ASC "
		local sqlr = " SELECT r.uid as roomid, r.name as roomName, a.uid as arid, a.name as areaName, 'room' as link_type " .. "FROM rooms r " .. "INNER JOIN areas a ON r.area = a.uid " .. "WHERE r.name = %s " .. "ORDER BY arid ASC "
		if (ar_rm == "area") then
			main_target_list = build_area_targets(cp_gq, sqla)
		elseif (ar_rm == "room") then
			main_target_list, room_targets_ignored = build_room_targets(cp_gq, sqlr, sqla)
		elseif (ar_rm == "none") then	-- should never be called but who knows
			print("main_target_list build error - tried to run while on " .. cp_gq .. " but area/room type is 'none'.")
		end
		xg_draw_window()
		print_target_links(main_target_list)
	end

	function build_area_targets(cp_gq, sqla)
		local t, list = {}, {}
		if (cp_gq == "cp") then
			list = cp_check_list
		elseif (cp_gq == "gq") then
			list = gq_check_list
		end
		local db = assert(sqlite3.open(mapper_db_file))
		for i,v in ipairs (list) do
			local dead = v.is_dead
			local cx
			local cy
			if (dead == "yes") then
				cx = "#484848"
				cy = "#900000"
			else
				cx = "#E0E0E0"
				cy = "#FF0000"
			end
			local results_found = false
			local select = string.format(sqla, fixsql(v.loc))
			for row in db:nrows(select) do
				results_found = true
				table.insert(t,
				{	mob = v.mob,
					arid = row.arid,
					qty = v.qty,
					is_dead = dead,
					color = cx,
					link_type = "area",
					index = #t+1,
					ord = v.ord } )
			end
			if (results_found == false) then
				table.insert(t,
				{	mob = v.mob,
					location = v.loc,
					arid = "-1",
					qty = v.qty,
					is_dead = dead,
					color = cy,
					link_type = "unknown",
					index = #t+1,
					ord = v.ord } )
			end
		end
		db:close_vm()
		for i,v in ipairs (t) do
			v.kw = gmkw(v.mob, v.arid)
		end
		return t
	end

	function build_room_targets(cp_gq, sqlr, sqla)
		local t, ig, list = {}, {}, {}
		local level_taken
		if (cp_gq == "cp") then
			list = cp_check_list
			level_taken = tonumber(cp_info_level)
		elseif (cp_gq == "gq") then
			list = gq_check_list
			level_taken = tonumber(gq_info_efflvl)
		end
		local db = assert(sqlite3.open(mapper_db_file))
		for i,v in ipairs (list) do
			local dead = v.is_dead
			local cx -- color of link text
			local lt -- link type (area, room, unknown)
			if (dead == "yes") then
				cx = "#484848"
				lt = "area"
			else
				cx = "#E0E0E0"
				lt = "room"
			end
			local results_found = false
			local select = string.format(sqlr, fixsql(v.loc))
			local last_mob_sig = ""
			for row in db:nrows(select) do			-- if not row then / print("error - room db search returned no rows") / elseif not row.areaName then / print("area name missing from row") / end
				if (area_range_index[row.areaName]) then	-- don't include areas that never contain quest mobs
					results_found = true
					local mob_sig = row.arid .. "|" .. v.mob
					if (mob_sig ~= last_mob_sig) then
						last_mob_sig = mob_sig
						local area_min_lvl = (area_range_index[row.areaName].min) or 1
						local area_max_lvl = (area_range_index[row.areaName].max) or 300
						if (level_taken >= area_min_lvl) and (level_taken <= (area_max_lvl+25)) then	-- limit results to sensible level range.
							table.insert(t, {
								mob = v.mob,
								arid = row.arid,
								roomid = row.roomid,
								roomName = row.roomName,
								qty = v.qty,
								is_dead = dead,--v.is_dead,
								color = cx,	--((v.is_dead == false) and "#E0E0E0" or "#484848"),
								minlvl = area_min_lvl,
								maxlvl = area_max_lvl,
								link_type = lt,	--((v.is_dead == false) and "room" or "area"),	-- deals with dead mobs when area contains roomnames same as area name e.g. Aardington Estate
								index = #t+1,
								ord = v.ord	} )
								if sortBy == "all" or sortBy == "area" then
									table.sort(t, function (a,b) return a.arid < b.arid end)
								end
						else
							table.insert(ig, {	-- build table of search results for areas out of your level range.
								mob = v.mob,	-- Usually invalid, but valid links can wind up here if area's level range is too broad, or wrong.
								arid = row.arid,
								roomid = row.roomid,
								roomName = row.roomName,
								qty = v.qty,
								is_dead = dead,
								color = "#002460",
								minlvl = area_min_lvl,
								maxlvl = area_max_lvl,
								link_type = "ignored",
								index = #ig+1,
								ord = v.ord } )
								if sortBy == "all" or sortBy == "room" then
									table.sort(t, function (a,b) return a.arid > b.arid end)
								end
						end
					end
				end
			end
			if (results_found == false) then	-- no results were returned: either the mob is dead, or the location is unknown.
				if (dead == "yes") then	-- mob is dead
					local results_found = false
					local select = string.format(sqla, fixsql(v.loc))	-- dead mobs only give area name (even in room cp's) so search area info only.
					for dead_row in db:nrows(select) do	-- mob is dead, location is known
						results_found = true
						table.insert(t, { mob=v.mob, arid=dead_row.arid, qty = v.qty, is_dead="yes", color="#484848", link_type="area", index=#t+1, ord=v.ord } )
					end
					if (results_found == false) then	-- mob is dead, location is unknown
						table.insert(t, { mob=v.mob, arid="-1", location=v.loc, qty = v.qty, is_dead="yes", color="#900000", link_type="unknown", index=#t+1, ord=v.ord } )
					end
				else	-- mob is alive, but location is unknown
					table.insert(t, { mob=v.mob, arid="-1", location=v.loc, qty = v.qty, is_dead="no", color="#FF0000", link_type="unknown", index=#t+1, ord=v.ord } )
				end
			end
		end
		db:close_vm()
		for i,v in ipairs (t) do
			v.kw = gmkw(v.mob, v.arid)
		end
		return t, ig
	end

--	[[ Display target links in MUD window ]]
	function print_target_links(list)
		if (#room_targets_ignored > 0) then
			print_room_links_ignored()
		end
		if silentMode == "off" then
			if (#list > 0) then
				ColourNote("#808080", "", string.rep("-", 90))
				--[[if list[1].link_type == "room" then
					for _,v in ipairs(list) do
						if string.match(v.roomName, "^Hiding from") then
							v.arid = "zz" .. v.arid ]]--

				for i,v in ipairs (list) do
					local mob_text = v.mob .. ((v.is_dead == "no") and "" or " [Dead]")
					local link_text
					local tooltip
					local notehelp = "Show notes for item " .. i
					if (v.link_type == "area") then
						link_text = string.format(" %2d  %s - %s", padRight(i, 6, " "), padRight(mob_text, 32, " "), padRight(v.arid, 10, " "))
						tooltip = "Target cp mob " .. i .. " - " .. mob_text .. " (" .. v.arid .. ")"
						Hyperlink("xcp " .. i, link_text, tooltip, v.color, "", 0)
						Hyperlink("roomnote area " .. v.arid, "  [notes]", notehelp, ((v.is_dead == "yes") and "#006000" or "lightgreen"), "", 0)
					elseif (v.link_type == "room") then
						local roomText = string.format("%5s", v.roomid) .. ": '" .. v.roomName .. "'"
						link_text = string.format(" %2d  %s - %s  %s", padRight(i, 4, " "), padRight(mob_text, 32, " "), padRight(v.arid, 10, " "), padRight(roomText, 40, " "))
						tooltip = "Target cp mob " .. i .. " - " .. mob_text .. " (" .. v.arid .. ")"
						Hyperlink("xcp " .. i, link_text, tooltip, v.color, "", 0)
					elseif (v.link_type == "unknown") then
						link_text = string.format(" %2d  %s - unknown: '%s'", padRight(i, 4, " "), padRight(mob_text, 32, " "), v.location)
						tooltip = "Location not found in mapper database"
						Hyperlink(" ", link_text, tooltip, v.color, "", 0)
					end
					print("")
				end
					ColourNote("#808080", "", string.rep("-", 90))
					ColourNote("#808080", "", "Type 'xcp <index>' or click link to go to that target.")
			else
				ColourNote("#FF5000", "", "   No target items to show.")
			end
		end
	end

	function print_room_links_ignored()
		local ig = room_targets_ignored
		ColourNote("#808080", "", string.rep("-", 90))
		for i,v in ipairs (ig) do
			local link = string.format(" ** Ignoring due to level: %s - %5s '%s' (%s) [%s-%s]", v.mob, v.roomid, v.roomName, v.arid, v.minlvl, v.maxlvl)
			Hyperlink("xmapper move " .. v.roomid, link, "Move to room " .. v.roomid, "#002460", "", 0)
			print("")
		end
	end


-- [[ "xcp" command ]]
	function xcp_noarg()	-- xcp with no argument given, so find the first available mob (alive, location known) and go to it.
		local t = main_target_list
		if (area_room_type == "none") then	-- abort if not on cp
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'xcp' aborted - you're not on a cp.\n")
		elseif (#t == 0) then	-- abort if on a cp, but target list is empty
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'xcp' aborted - cp is active but target list is empty.\n")
		else
			for i,v in ipairs (t) do	-- loop through list and try to find something to kill.
				if (v.is_dead == "no") and (v.link_type == "area" or v.link_type == "room") then	-- if mob is alive and location known, go to it.
					xcp_index = i
					xg_draw_window()
					xcp_goto_target(i)
					break
				else
					local index = i + 1
					if (index > #t) then 	-- if we reach this step, all mobs are dead and/or unknown.
						ColourNote("#FF5000", "", "\nSearch and Destroy: 'xcp' aborted - lack of targets (dead, or location unknown)")
					end
				end
			end
		end
	end

	function xcp_arg(name, line, wildcards)
		local index = tonumber(wildcards.index)
		local cp_list = main_target_list
		if (area_room_type == "none") then
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'xcp' aborted - you're not on a cp.\n")
		elseif (#cp_list == 0) then
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'xcp' aborted - cp is active but target list is empty.\n")
		elseif (index > #cp_list) or (index < 0) then	-- index doesn't exist
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'xcp' aborted - index doesn't exist (".. index .. ")\n")
		elseif (index == 0) then	-- clear xcp target
			xcp_clear_target(true)
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'xcp' current target cleared.\n")
		elseif (cp_list[index].link_type == "unknown") then -- or (cp_list[index].link_type == "unknown_room") then	-- abort if unknown
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'xcp' aborted - no mapper data for target (#" .. index .. ").\n")
		else	-- everything is in order, so go to mob.
			local ch_state = current_character_state
			if (ch_state == "3") then
				xcp_index = index
				xg_draw_window()
				xcp_goto_target(index)
			elseif (ch_state == "8") then
				ColourNote("#FF5000", "", "\nNot while you're fighting!")
			elseif (ch_state == "12") then
				ColourNote("#FF5000", "", "\nYou are already running!")
			end
		end
	end

	function xcp_goto_target(index)
		if (xcp_retry_stat == 0) then
			local t = main_target_list[index]
			local ri = current_room
			local action = xcp_action_mode
			gotoArea = -1
			gotoIndex = 1
			gotoList = {}
			if (t ~= nil) and (ri.rmid ~= nil) then
				full_mob_name = t.mob
				short_mob_name = t.kw
				if (t.link_type == "area") then	-- Area cp links - "xcp" goes to target area, then runs Hunt Trick to get target room.
					if (action == "qw") then
						local func = function() qw_exact(t.kw) end
						execute_in_area(t.arid, func)
					elseif (action == "ht") then		-- do hunt trick or quick where after arriving in area.
						local func = function() Execute("ht " .. t.kw) end
						execute_in_area(t.arid, func)
					elseif (action == "off") then	-- do nothing
						ColourNote("#FF5000", "", "Xcp action is off - no additional action\n")
					end
					if (ri.arid ~= t.arid) then	-- if you're not in target area, xrunto target area.
						--Execute("xrt " .. t.arid)
						xrun_to("", "", {destination=t.arid})
					end
				else	-- Room cp:  get target room from mapper, but don't move yet.  "go" takes you to room.
					search_rooms(t.roomName .. "|" .. t.arid, "area", t.mob)
				end
			else
				ColourNote("#FF5000", "", "No item exists, or data is busy")
			end
		else
			xcp_retry_stat = 2
		end
	end

	function xcp_clear_target(bool)
		short_mob_name = -1
		full_mob_name = -1
		xcp_index = 0
		gotoArea = -1
		gotoIndex = 0
		gotoList = {}
		if (bool == true) then
			xg_draw_window()
		end
	end

	function xcp_set_action_mode(name, line, wildcards)
			local opt = wildcards.option or ""
			local options = {
				["ht"] = "ht - do hunt trick",
				["qw"] = "qw - do quick where",
				["off"] = "off - no additional action",
				}
			if (opt == "ht") or (opt == "qw") or (opt == "off") then
				xcp_action_mode = opt
				SetVariable("mcvar_xcp_action_mode", opt)
				ColourNote("#00C040", "", "Set 'xcp' mode to: " .. options[opt] .. ".")
			elseif (opt == "") then
				ColourNote("#FF5000", "", "Current 'xcp' mode: " .. options[xcp_action_mode] .. ".")
				ColourNote("#FF5000", "", "Syntax: 'xcp mode [ht|qw|off]'")
			else
				ColourNote("#FF5000", "", "Invalid 'xcp' mode given.  Syntax: 'xcp mode [ht|qw|off]'")
			end
			print("")
	end

-- [[  Goto area (xrt), goto room (go), goto next (nx), goto previous (nx-) ]]
	local xrun_to_sql_uid =  "SELECT r.uid, r.name as room, r.area " .. "FROM rooms r " .. "WHERE r.area like %s " .. "ORDER BY r.name "
	local xrun_to_sql_name = "SELECT r.uid, r.name as room, r.area " .. "FROM rooms r " .. "INNER JOIN areas a ON a.uid = r.area " .. "WHERE r.area like %s OR a.name like %s " .. "ORDER BY r.name "

	function xrun_to(name, line, wildcards)
		local ri = current_room
		local arid = wildcards.destination
		if (arid == "ft2") then arid = "ftii" end
		local rmid = get_start_room(arid)
		if (rmid == "-1") then		-- area has no start room defined.
			ColourNote("#FF5000", "", "X-runto: No default start room is defined for area: " .. arid .. ".\n")
			SendNoEcho("areas 1 299 keywords " .. arid)
		else
			ColourNote("#FF5000", "", "X-runto: " .. arid .. ", room ID: " .. rmid .. " (" .. start_room_type .. ")\n")
			goto_room_id(rmid, arid)
		end
	end

	function goto_room_id(rmid, arid)	-- go to specific room id (do not confuse with goto_number, see below)
		local ri = current_room
		local rmid = rmid
		local arid = arid or getAreaFromRoomId(rmid)
		if (is_vidblain_area(rmid) == true) then -- if target is in a vidblain area,
			if(is_vidblain_area(ri.rmid) == false) then	-- but if you are not
				vidblain_nav(rmid, arid)
			else
				do_mapper_goto(rmid, "walk")
			end
		else
			do_mapper_goto(rmid)
		end
	end

	function action_on_destination_arrived()
		if is_autocon_enabled() then
			EnableTrigger("consider_end_empty", true)
			consider_destination_room = true
			SendNoEcho("consider")
		else
			SendNoEcho("scan")
		end
	end

	function goto_number(name, line, wildcards)
		local ch_state = current_character_state
		if (ch_state == "3") then
			gotoIndex = tonumber(wildcards.index) or 1
			if gotoList[gotoIndex] then
				if (tonumber(gotoList[gotoIndex]) == nil) then
					xrun_to("", "", {destination=gotoList[gotoIndex]})
					action_on_destination_arrived()
				else
					next_room = gotoList[gotoIndex]
					goto_room_id(gotoList[gotoIndex])
					action_on_destination_arrived()
				end
			else
				ColourNote("#FF5000", "", "Goto room result (go) aborted - No destination yet.")
			end
		elseif (ch_state == "8") then
			ColourNote("#FF5000", "", "\nNot while you're fighting!")
		elseif (ch_state == "12") then
			ColourNote("#FF5000", "", "\nYou are already running!")
		else
			ColourNote("#FF5000", "", "\nGoto room result (go):  Can't do that now - you must be standing and ready.")
		end
	end

	function goto_next(name, line, wildcards)
		local ch_state = current_character_state
		if (ch_state == "3") then
			if (next_room == nil) or (next_room == "") or (not tonumber(next_room)) then
				ColourNote("#FF5000", "", "Goto next (nx) aborted - No data yet.")
			else
				if (tonumber(next_room) == tonumber(gmcp("room.info.num"))) and (gotoIndex < #gotoList) then
					gotoIndex = gotoIndex + 1
				end
				if gotoList[gotoIndex] then
					ColourNote("#00C040", "", "Next room (nx) - " .. gotoIndex .. " of " .. #gotoList)
					next_room = gotoList[gotoIndex]
					do_mapper_goto(next_room)
					action_on_destination_arrived()
				else
					ColourNote("#FF5000", "", "Goto next (nx) aborted - No more rooms.")
				end
			end
		elseif (ch_state == "8") then
			ColourNote("#FF5000", "", "\nNot while you're fighting!")
		elseif (ch_state == "12") then
			ColourNote("#FF5000", "", "\nYou are already running!")
		else
			ColourNote("#FF5000", "", "\nGoto next room (nx):  Can't do that now - you must be standing and ready.")
		end
	end

	function goto_previous(name, line, wildcards)
		local ch_state = current_character_state
		if (ch_state == "3") then
			if (next_room == nil) or (next_room == "") or (not tonumber(next_room)) then
				ColourNote("#FF5000", "", "Goto previous (nx-) aborted - No data yet.")
			else
				if (tonumber(next_room) == tonumber(gmcp("room.info.num"))) and (gotoIndex > 1) then
					gotoIndex = gotoIndex - 1
				end
				if gotoList[gotoIndex] then
					ColourNote("#00C040", "", "Previous room (nx-) - " .. gotoIndex .. " of " .. #gotoList)
					next_room = gotoList[gotoIndex]
					do_mapper_goto(next_room)
					quick_scan()
				else
					ColourNote("#FF5000", "", "Goto previous (nx-) aborted - No more rooms.")
				end
			end
		elseif (ch_state == "8") then
			ColourNote("#FF5000", "", "\nNot while you're fighting!")
		elseif (ch_state == "12") then
			ColourNote("#FF5000", "", "\nYou are already running!")
		else
			ColourNote("#FF5000", "", "\nGoto previous room (nx-):  Can't do that now - you must be standing and ready.")
		end
	end

--	[[ Vidblain navigation ]]
	function vidblain_nav(rmid, arid)
		local ch_state = current_character_state
		vidblain_nav_tbl = { i=0, j=0, rmid=rmid, arid=arid, stat=ch_state }
		EnableTimer("execute_in_area_timer", false)
		EnableTimer("vidblain_nav_timer", true)
		Execute("mapper goto 11910") -- move to vidblain and enter the portal
		Execute("enter hole")
	end

	function vidblain_nav_tick()
		local ri = current_room
		local ch_state = current_character_state
		local vnt = vidblain_nav_tbl
		local eiat = execute_in_area_tbl
		if (ri.arid ~= nil) and (ch_state ~= nil) then
			if (ri.arid ~= "vidblain") then	-- not in vidblain yet
				vnt.i = vnt.i + 1
				if (vnt.i > 200) then
					EnableTimer("vidblain_nav_timer", false)
					xcp_clear_target(true)
					ColourNote("#FF5000", "", "** vidblain nav:  abort timer - took too long to get to destination.")
					vidblain_nav_tbl = { i=0, j=0, rmid="", arid="", stat=1 }
				end
			else  -- arrived in vidblain proper
				if (ch_state == "3") and (ch_state == vnt.stat) then  -- monitor char state for 3 ticks, if stable, start EIA timer and run to target area
					vnt.j = vnt.j + 1
					if (vnt.j > 3) then
						EnableTimer("vidblain_nav_timer", false) -- stop vidblain timer
						do_mapper_goto(vnt.rmid, "walk")
						execute_in_area(vnt.arid, eiat.f)	-- start EIA timer
						vidblain_nav_tbl = { i=0, j=0, rmid="", arid="", stat=1 }
					end
				else
					vnt.stat = ch_state
				end
			end
		end
	end

--	[[ Execute in Area ]]
	function execute_in_area(arid, func)	-- id is the process or function calling this one.
		local ri = current_room
		local ch_state = current_character_state
		local fn
		if (type(func) == "function") then
			fn = func
		else
			fn = function () end
		end
		execute_in_area_tbl = { i=0, j=0, arid=arid, f=fn, stat=ch_state }
		if (ri.arid == arid) then	-- in target area
			func()
			execute_in_area_tbl = { i=0, j=0, arid="", f="", stat=1 }
		elseif (ri.arid == nil) then	--
			print("execute_in_area - nil area name")
			send_gmcp_packet("request room")
		else
			EnableTimer("execute_in_area_timer", true)
		end
	end

	function execute_in_area_tick()
		local ri = current_room
		local ch_state = current_character_state
		local eiat = execute_in_area_tbl
		if (ri.arid ~= nil) and (ch_state ~= nil) then
			if (ri.arid ~= eiat.arid) then
				eiat.i = eiat.i + 1
				if (eiat.i > 200) then
					EnableTimer("execute_in_area_timer", false)
					xcp_clear_target(true)
					ColourNote("#FF5000", "", "** execute-in-area:  abort timer - took too long to get to destination.")
					execute_in_area_tbl = { i=0, j=0, arid="", f="", stat=1 }
				end
			else
				if (ch_state == "3") and (ch_state == eiat.stat) then
					eiat.j = eiat.j + 1
					if (eiat.j > 3) then
						EnableTimer("execute_in_area_timer", false)
						eiat.f()
						--eiat.f()
					end
				else
					eiat.stat = ch_state
					if (ch_state == "8") then
						EnableTimer("execute_in_area_timer", false)	--ColourNote("#FF5000", "", "** execute-in-area:  in combat -> reduce timer rate")
						DoAfterSpecial(1.5, [[ EnableTimer("execute_in_area_timer", true) ]], 12)
					end
				end
			end
		end
	end

	function execute_in_room(rmid, func)

	end

	function execute_in_room_tick()

	end

--	[[ quick where ]]
	function qw_reset(bool)
		EnableTrigger("trg_quick_where_match", false)
		EnableTrigger("trg_quick_where_no_match", false)
		if (bool == true) then
			qw = { index = 1, exact = true }
		else
			qw = { index = 1, exact = false }
		end
	end

	function qw_noarg()
		local ix = qw.index or 1
		local s = short_mob_name or -1
		if (s == -1) then
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'Quick-where' has no target.")
			ColourNote("#FF5000", "", "Use 'xcp', 'qw <mob>, or 'ht <mob>' to get target info.\n")
		else
			if (qw.exact == true) then
				qw_exact()
			else
				do_quick_where(ix, s)
			end
		end
	end

	function qw_arg(name, line, wildcards)
		local t = main_target_list
		local s = wildcards.mob
		local ix = tonumber(wildcards.index) or 1
		short_mob_name = s
		qw.index = ix
		qw.exact = false
		do_quick_where(ix, s)
	end

	function qw_exact()  -- called from code, e.g. xcp function
		local t = main_target_list[xcp_index]
		if (t) then
			local f = t.mob
			local s = t.kw
			full_mob_name = f
			short_mob_name = s
			local ix = qw.index or 1
			local p1 = split(f, "[^ ]+")
			local p2
				for i,v in ipairs (p1) do
					if gmkw_omit[v] then
						-- do nothing
					else
						p2 = (p2 == nil) and v or p2 .. " " .. v
					end
				end
			qw.exact = true
			qw.match = p2
			do_quick_where(ix, s)
		else
			print("\nqw exact: You have no 'xcp' target.")
		end
	end

	function do_quick_where(ix, s)
		EnableTrigger("trg_quick_where_match", true)
		EnableTrigger("trg_quick_where_no_match", true)
		if (ix == 1) then	-- don't use 1.mob
			Send(string.format("where %s", s))
		else
			Send(string.format("where %s.%s", ix, s))
		end
	end

	function qw_match(name, line, wildcards)
		local mob = wildcards.mobname
		local room = wildcards.roomname
		local parts
		local found = false
		qw.index = qw.index or 1
		if (qw.exact == true) then	-- tells this function to look for an exact match for the current xcp target mob name.
			if (Trim(mob) == Trim(string.sub(full_mob_name, 1, 30))) then
				found = true
			end
		else
			parts = split(string.lower(short_mob_name), "[^ ]+")
			for i=1, #parts do
				if (string.find(string.lower(mob), parts[i], 1, true) ~= nil) then
					found = true
					break -- leave loop
				end
			end
		end
		if (found == false) then	-- not our line, keep looking
			qw.index = qw.index + 1
			if (qw.index < 101) then
				SendNoEcho(string.format("where %s.%s", qw.index, short_mob_name))
				return
			else
				print("qw: too many fails")
				found = true
				return
			end
		end
		qw_reset(qw.exact)
		search_rooms(room, 'area', Trim(mob))
	end

	function qw_no_match()	-- responds to "There is no <mob name> around here."
		qw_reset(qw.exact)
	end

--	[[ Hunt trick ]]
	function ht_reset()
		EnableTriggerGroup("HuntTrick", false)
		ht = { index = 1 }
	end

	function ht_noarg()
		local s = short_mob_name or -1
		local ix = ht.index or 1
		if (s == -1) then
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'Hunt trick' has no target.")
			ColourNote("#FF5000", "", "Use 'xcp', ht <mob>', or 'qw <mob>' to pick a target.\n")
			return
		end
		do_hunt_trick(ix, s)
	end

	function ht_arg(name, line, wildcards)
		local s = wildcards.mob
		local ix = tonumber(wildcards.index) or 1
		short_mob_name = s
		do_hunt_trick(ix, s)
	end

	function do_hunt_trick(ix, s)
		ht.index = ix or 1
		EnableTriggerGroup("AutoHunt", false)
		EnableTriggerGroup("HuntTrick", true)
		if (ix == 1) then	-- don't use "1.mob"
			Send(string.format("hunt %s", s))
		else
			Send(string.format("hunt %s.%s", ix, s))
		end
	end

	function ht_continue()
		local s = short_mob_name
		local ix = (ht.index + 1) or 1
		do_hunt_trick(ix, s)
	end

	function ht_complete(name, line, wildcards)
		EnableTriggerGroup("AutoHunt", false)
		local s = short_mob_name
		local ix = ht.index or 1
		qw_arg("", "", {index=ix, mob=s})
		ht_reset()
	end

	function ht_abort(name, line, wildcards)
		EnableTriggerGroup("HuntTrick", false)
		ht = {}
		ColourNote("#FF5000", "", "Search and Destroy:  Hunt trick cancelled.")
	end

-- [[ quick scan, quick kill ("kk") ]]
	function quick_scan()
		if (short_mob_name == nil) or (short_mob_name == "") then
			SendNoEcho("scan")
		else
			SendNoEcho(string.format("scan %s", short_mob_name))
		end
	end

	function quick_kill(name, line, wildcards)
		if (short_mob_name == nil) or (short_mob_name == "") or (short_mob_name == "-1") or (short_mob_name == -1) then
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'Quick-kill' has no target.  Use 'ht', 'qw', or 'xcp' to select a target.\n")
		else
			for command in quick_kill_command:gmatch("[%a%s%p]+[^;]?") do
				Execute(command .. " '" .. short_mob_name .. "'")
			end
			--Execute(quick_kill_command .. " '" .. short_mob_name .. "'")
		end
	end

	function xset_quick_kill_command(name, line, wildcards)		-- user-defined attack to use with qk/kk
		if (wildcards.arg == "") then
			ColourNote("#FF5000", "", "Search and Destroy: Quick-kill command currently set to: '" .. quick_kill_command .. "'")
		else
			quick_kill_command = wildcards.arg
			SetVariable("mcvar_quick_kill_command", quick_kill_command)
			ColourNote("#FF5000", "", "Search and Destroy: Quick-kill command is now set to: '" .. quick_kill_command .. "'")
		end
	end

	function xset_silentMode(name, line, wildcards)
		if (not wildcards[1] or wildcards[1] == "") then
			ColourNote("#FF5000", "", "Search and Destroy: Silent mode currently set to: '" .. silentMode .. "'")
		else
			silentMode = wildcards[1]:lower()
			SetVariable("mcvar_silentMode_command", silentMode)
			ColourNote("#FF5000", "", "Search and Destroy: Silent mode is now set to: '" .. silentMode .. "'")
		end
	end

	function xset_sortBy(name, line, wildcards)
		if (not wildcards[1] or wildcards[1] == "") then
			ColourNote("#FF5000", "", "Search and Destroy: Sort mode currently set to: '" .. sortBy .. "'\nOptions are: all, area, room, none")
		else
			sortBy = wildcards[1]:lower()
			SetVariable("mcvar_sortBy", sortBy)
			ColourNote("#FF5000", "", "Search and Destroy: Sort mode is now set to: '" .. sortBy .. "'")
		end
	end
-- [[ Room search processes ]]
	local search_rooms_sql =
		"SELECT r.uid as uid, r.name as name, info, r.area as area, " ..
		"ifnull(a.name, r.area) as area_name, 1 as DisplayOrder " ..
		"FROM rooms r " ..
		"LEFT OUTER JOIN areas a ON r.area = a.uid " ..
		"WHERE r.name = %s " .. -- room
		"AND (%s = 'all' OR (a.name = %s OR r.area = %s)) " .. -- area_id x3
		"UNION " ..
		"SELECT r.uid, r.name, info, r.area, " ..
		"ifnull(a.name, r.area) as area_name, 0 as DisplayOrder " ..
		"FROM rooms r " ..
		"LEFT OUTER JOIN areas a ON r.area = a.uid " ..
		"WHERE r.name <> %s " ..	-- room
		"AND r.name LIKE %s " .. 	-- like
		"AND (%s = 'all' OR (a.name = %s OR r.area = %s)) " .. -- area_id x3
		"ORDER BY area, DisplayOrder DESC "

	function search_rooms(room_name, searchType, fullMobName)
		if (room_name == nil) or (room_name == "") then
			Note("map_area() error : room name isn't known")
		else
			local ri = current_room
			local parts = split(room_name, "[^|]+") -- pipe delimited:  room|area
			local room = parts[1]
			local arid
			if (#parts == 2) then
				arid = parts[2]
			else
				if (current_room ~= nil) then
					arid = ri.arid
				else
					ColourNote("#FF5000", "", "Area not known, falling back to mapper list")
					Execute("mapper list " .. parts[1])
				end
			end
			if (room == nil) then
				Note("map_area() - Room not known")
				return
			end
			local like = "%"..room.."%"
			-- i forget what this does? Strip out a leading " ?
			--if string.sub(room,1,1) == "\"" and string.sub(room,-1) == "\"" then
			--	like = string.sub(room,2,-2)
			--end
			local select = string.format(search_rooms_sql,	fixsql(room),
															fixsql(arid), fixsql(arid), fixsql(arid),
															fixsql(room),
															fixsql(like),
															fixsql(arid), fixsql(arid), fixsql(arid))
			local db = assert(sqlite3.open(mapper_db_file))
			local results = {}
			local roomid_list = {}
			local has_results = false
			for row in db:nrows(select) do
				has_results = true
				local id = (tonumber(row.uid) or -1) -- sanitize text room ids for "unmappable" (nomap) rooms that are now being mapped
				results[#results + 1] = {
					rmid = id,
					name = row.name,
					info = row.info,
					area = row.area_name,
					arid = row.area } --or row.area_name } -- make safe against bad dbs
				if (id > 0) then	-- make a list of room ids
					roomid_list[#roomid_list + 1] = id
				end

			end   -- finding rooms
			db:close_vm()

			if has_results and fullMobName then
				local SnDdb = assert(sqlite3.open(snd_db_file))
				local count_by_room = {}
				local sum = 0

				select = string.format("SELECT roomid, count FROM mobs WHERE zone = %s AND mob = %s AND roomid in (%s);", fixsql(arid), fixsql(fullMobName), table.concat(roomid_list, ","))

				for row in SnDdb:nrows(select) do
					count_by_room[row.roomid] = row.count
					sum = sum + row.count
				end
				SnDdb:close_vm()

				for i, result in ipairs(results) do
					result.count = count_by_room[result.rmid] or 0
					if sum > 0 then
						result.percentage = (result.count / sum)
					else
						result.percentage = 0
					end
				end

				function sort_by_count(a, b)
					if a.count > b.count then
						return true
					elseif	a.count < b.count then
						return false
					else
						return a.rmid < b.rmid
					end
				end

				table.sort(results, sort_by_count)
			end

			search_rooms_results(results)
		end
	end

	function search_rooms_results(results)	-- Display list of 'go' links from hunt-trick, quick-where, etc.
		gotoArea = -1
		gotoIndex = 1
		gotoList = {}
		mapper_area_index = 0
		local last_area = ""
			ColourNote("#808080", "", "\nIndex    Location     (uid)")
			ColourNote("#808080", "", string.rep("-", 67))
		for i,v in ipairs (results) do
			if (last_area ~= v.arid) then
				if (mapper_area_index == 0) then
					local areaLine = string.format("~~~ %2d   %s", mapper_area_index, v.arid)
					Hyperlink("go " .. mapper_area_index, areaLine, "go to area " .. v.arid, "silver", "", 0)
					gotoList[mapper_area_index] = v.arid
					gotoArea = v.arid
					mapper_area_index = mapper_area_index + 1
				else
					local areaLine = string.format("~~~   %s", v.arid)
					Hyperlink("xrt " .. v.arid, areaLine, "go to area " .. v.arid, "silver", "", 0)
				end
				print("")
				last_area = v.arid
			end
			local line1 = string.format("~~~ %2d   ", mapper_area_index)
			Hyperlink("go " .. mapper_area_index, line1, "go to item " .. mapper_area_index, "lightblue", "", 0)
			local line2 = string.format("%s  (%s) ", padRight(string.gsub(v.name, "@[a-zA-Z]", ""), 40, " "), v.rmid)
			Hyperlink("go " .. mapper_area_index, line2, "go to item " .. mapper_area_index, "lightblue", "", 0)
			Hyperlink("mapper where " .. v.rmid, "   {sw}", "click for speedwalk to this room", "#FF5000", "", 0)
			gotoList[mapper_area_index] = v.rmid
			if v.percentage then
				ColourNote("silver", "", " (",
					mob_room_percentage_color(v.percentage), "", string.format("%.2f%%", v.percentage * 100),
					"silver", "", ")")
			else
				print("")
			end
			mapper_area_index = mapper_area_index + 1
		end
		if (mapper_area_index == 0) then
			ColourNote("#FF5000", "", "No matching rooms found.")
		end
		ColourNote("#808080", "", string.rep("-", 67))
		ColourNote("#808080", "", "Type 'go <index>' or click link to go to that room.\n")
	end

	-- Return a color between #aaaaaa (grey, at 0%) and #44ff00 (green, at 100%)
	function mob_room_percentage_color(percentage)
		local red_from, red_to = 170, 68
		local green_from, green_to = 170, 255
		local blue_from, blue_to = 170, 0

		-- using the straight percentage was resulting in numbers being too grey
		percentage = math.min(1, math.max(0, math.sqrt(percentage)))

		return string.format("#%02x%02x%02x",
			red_from + (red_to - red_from) * percentage,
			green_from + (green_to - green_from) * percentage,
			blue_from + (blue_to - blue_from) * percentage)
	end

	function map_area(name, line, wildcards)
		search_rooms(wildcards.loc, 'area')
	end

	function map_area_all(name, line, wildcards)
		search_rooms(wildcards.loc .. "|all", 'all')
	end

--	[[ "xwhere" command ]]
	function do_xwhere(name, line, wildcards)
		local n1 = tonumber(wildcards.n1) or 12	-- if no number given, default to 12
		local n2 = tonumber(wildcards.n2) or ""
		local mob = wildcards.mob or ""
		if (mob == "") then						-- user entered no numbers, no mobname, or no args at all
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'xwhere' required parameter missing.\n")
			ColourNote("#FF5000", "", "              Syntax: 'xwhere <mobname>'")		-- default to 10
			ColourNote("#FF5000", "", "                      'xwhere <n1> <mobname>'")	-- where 1.mobname to n1.mobname
			ColourNote("#FF5000", "", "                      'xwhere <n1> <n2> <mobname>'")	-- where 1.mobname to n2.mobname
			return
		elseif (n2 == "") then	-- user entered one number (n1) and a mobname, but no second number (n2)
			ColourNote("#00C040", "", "\nSearch and Destroy: 'xwhere" .. " " .. n1 .. " " .. mob .. "'")
			for i = 1, n1, 1 do
				if (i == 1) then
					Send("where " .. mob)
				else
					Send("where " .. i .. "." .. mob)
				end
			end
		elseif (mob ~= "") and (n2 ~= "") then	-- user entered n1, n2, and mobname
			ColourNote("#00C040", "", "Search and Destroy: 'xwhere" .. " " .. n1 .. " " .. n2 .. " " .. mob .. "'")
			for i = n1, n2, 1 do
				if (i == 1) then
					Send("where " .. mob)
				else
					Send("where " .. i .. "." .. mob)
				end
			end
		else
			ColourNote("#FF1000", "", "Search and Destroy: 'xwhere' data entry problem!")
		end
	end

--	[[ Autohunt ]]
	function auto_hunt(name, line, wildcards)
		local s = string.lower(wildcards.arg)
		if (s == "abort") or (s == "cancel") or (s == "0") then
			auto_hunt_abort()
		else
			ht_reset()
			EnableTriggerGroup("AutoHunt", true)				auto_hunt_mob = s
			Send("hunt " .. s)
		end
	end

	function auto_hunt_abort()
		auto_hunt_reset()
		ColourNote("#FF5000", "", "Search and Destroy:  Auto-hunt cancelled.\n")
	end

	function auto_hunt_complete()
		auto_hunt_reset()
		ColourNote("#00C040", "", "Search and Destroy: Auto-hunt complete.\n")
	end

	function auto_hunt_lowskill()
		ColourNote("#FF5000", "", "\nSearch and Destroy:  Autohunt not available - hunt skill is too low.")
		ColourNote("#FF5000", "", "                     If hunt skill is available, practice it to 85% or higher.")
		auto_hunt_reset()
	end

	function auto_hunt_move(direction)
		local ri = current_room
		local dir = dir_map[direction]
		auto_hunt_direction = dir
		if (ri) then	-- don't know our gmcp exits, so just go with it
			if (ri.exits[dir] == nil ) then	-- exit is visible in gmcp
				Send("open " .. dir)
			end
		end
		Send(dir)
	end

	function auto_hunt_next(name, line, wildcards)
		local dir = wildcards.dir
		auto_hunt_move(dir)
		Send("hunt " .. auto_hunt_mob)
	end

	function auto_hunt_door()
		EnableTrigger("trg_autohunt_next_1", false)
		EnableTrigger("trg_autohunt_next_2", false)
		Send("open " .. auto_hunt_direction)
	end

	function auto_hunt_door_open()
		EnableTrigger("trg_autohunt_next_1", true)
		EnableTrigger("trg_autohunt_next_2", true)
		Send(auto_hunt_direction)
		Send("hunt " .. auto_hunt_mob)
	end

	function auto_hunt_portal()
		ColourNote("#00C040", "", "\nSearch and Destroy: Auto-hunt through portals not working yet.  Enter portal manually and then autohunt again.")
		auto_hunt_reset()
	end

	function auto_hunt_reset()
		EnableTriggerGroup("AutoHunt", false)
		auto_hunt_mob = ""
		auto_hunt_direction = ""
		autoHuntData = { count = 0, north = 0, south = 0, east = 0, west = 0, up = 0, down = 0 }
	end

--	[[ Automatic noexp ]]
	function xset_noexp_tnl(name, line, wildcards)		-- called by alias: "xset noexp" when argument given
		local set_tnl = wildcards.arg or "-1"
		if (anex_automatic_onoff == "on") then
			if (wildcards.arg == "-1") or (wildcards.arg == "") or (wildcards.arg == nil) then
				if (anex_tnl_cutoff == 0) then
					ColourNote("#FF5000", "", "Search and Destroy: Auto 'noexp' is currently OFF.")
				else
					ColourNote("#FF5000", "", "Search and Destroy: Auto 'noexp' is ON and set to " .. anex_tnl_cutoff .. " TNL.\n")
				end
			elseif (wildcards.arg == "off") or (wildcards.arg == "0") then	-- "xset noexp off" and "xset noexp 0" turn auto-noexp off.
				EnableTrigger("trg_anex_mobdeath_xp1", false)
				anex_tnl_cutoff = 0
				SetVariable("mcvar_anex_tnl_cutoff", anex_tnl_cutoff)
				ColourNote("#FF5000", "", "\nSearch and Destroy: Auto 'noexp' is now OFF.\n")
			else											-- xset with any other (positive) number turns auto-noexp on.
				EnableTrigger("trg_anex_mobdeath_xp1", true)
				anex_tnl_cutoff = tonumber(set_tnl)
				SetVariable("mcvar_anex_tnl_cutoff", anex_tnl_cutoff)
				ColourNote("#FF5000", "", "\nSearch and Destroy: Auto 'noexp' now set to " .. anex_tnl_cutoff .. " TNL.\n")
			end
		else
			ColourNote("#FF5000", "", "\nSearch and Destroy: 'noexp' is *manually* OFF." ..
									"\nType 'noexp' again to turn it back on.")
		end
		xg_draw_window()
	end

	function anex_set_noexp(x)
		if (anex_automatic_onoff) == "on" then
			if (x == "on") or (x == "off") then
				noexp_onoff = x
				send_gmcp_packet("config noexp " .. x)
				print("noexp: " .. noexp_onoff)
			end
		else
			noexp_onoff = "off"
		end
		xg_draw_window()
	end

	function anex_can_get_new_cp()		-- called by line 'You may take campaign this level.' in 'cp check'
		if (anex_automatic_onoff == "on") then
			if (anex_tnl_cutoff > 0) then	-- if anex_tnl_cutoff > 0 then auto-noexp is on.
				local level = tonumber(gmcp("char.status.level"))
				if (level < 200) then
					local tnl = tonumber(gmcp("char.status.tnl"))
					if (tnl < anex_tnl_cutoff) and (noexp_onoff == "off") then		-- tnl less than set point and noexp is off --> turn that shit on
						anex_set_noexp("on")
						ColourNote("#FF5000", "", "\nSearch and Destroy: Turning 'noexp' ON (Your TNL is less than " .. anex_tnl_cutoff .. ")")
					elseif (tnl > anex_tnl_cutoff) and (noexp_onoff == "on") then	-- if over min TNL and noexp is on --> turn noexp off regardless
						anex_set_noexp("off")
						ColourNote("#FF5000", "", "\nSearch and Destroy: Turning 'noexp' OFF (your TNL is greater than " .. anex_tnl_cutoff .. ")")
					end
				else
					if (noexp_onoff == "on") then
						anex_set_noexp("off")
						ColourNote("#FF5000", "#000000", "\nSearch and Destroy: Turning noexp OFF (you have reached level ".. plevel ..")")
					end
				end
			else 	-- feature is turned off, just show reminder
				anex_tnl_cutoff = 0	-- set to 0 if somehow negative
				ColourNote("#FF5000", "", "Automatic 'noexp' is currently turned OFF.\n")
			end
		end
	end

	function anex_must_level_new_cp()	-- called by trigger:  You must level to get a new campaign
		if anex_automatic_onoff == "on" then
			if (anex_tnl_cutoff > 0) then
				local level = tonumber(gmcp("char.status.level"))
				if (level < 200) then
					if (noexp_onoff == "on") and (player_on_cp == "yes") then
						ColourNote("#FF5000", "", "Search and Destroy: Turning noexp OFF (must level to get new cp)")
						anex_set_noexp("off")
					end
				else
					if (noexp_onoff == "on") then
						anex_set_noexp("off")
						ColourNote("#FF5000", "", "Search and Destroy: Turning noexp OFF (you have reached level ".. level ..")")
					end
				end
			end
		end
	end

	function anex_mobdeath_xp1(name, line, wildcards)	-- called when mob kill awards xp
		if (anex_automatic_onoff == "on") then
			local level = tonumber(gmcp("char.status.level"))
			if (anex_tnl_cutoff > 0) then
				if (level < 200) then
					DoAfterSpecial(0.1, [[ anex_mobdeath_xp2() ]], 12)
				else
					if (noexp_onoff == "on") then
						anex_set_noexp("off")
						ColourNote("#FF5000", "", "Search and Destroy: Turning noexp OFF (you have reached level ".. level ..")")
						ColourNote("#FF5000", "", "                    Use 'xset noexp off' to override.")
					end
				end
			end
		end
	end

	function anex_mobdeath_xp2()	-- called via timer set by function anex_mobdeath_xp1
		if (anex_automatic_onoff == "on") then
		local tnl = tonumber(gmcp("char.status.tnl"))
		if (can_get_new_cp == "yes") then
			if (tnl < anex_tnl_cutoff) then
				if (noexp_onoff == "off") then
					anex_set_noexp("on")
					ColourNote("#FF5000", "", "\nSearch and Destroy: Turning 'noexp' ON (your TNL is less than " .. anex_tnl_cutoff .. ")")
				end
			else
				if (noexp_onoff == "on") then
					anex_set_noexp("off")
					ColourNote("#FF5000", "", "\nSearch and Destroy: Turning 'noexp' OFF (your TNL is greater than " .. anex_tnl_cutoff .. ")")
				end
			end
		else
			if (noexp_onoff == "on") then
				anex_set_noexp("off")
				ColourNote("#FF5000", "", "\nSearch and Destroy: Turning 'noexp' OFF (you must level before taking a new campaign)")
			end
		end
		end
	end

	function anex_check_tnl_silent()	-- used by the window's clickable TNL cutoff changer
		local tnl = tonumber(gmcp("char.status.tnl"))
		if (can_get_new_cp == "yes") then
			if (tnl < anex_tnl_cutoff) then
				if (noexp_onoff == "off") then
					anex_set_noexp("on")
				end
			else
				if (noexp_onoff == "on") then
					anex_set_noexp("off")
				end
			end
		else
			if (noexp_onoff == "on") then
				anex_set_noexp("off")
			end
		end
	end

	function anex_automatic_on()	-- Noexp will toggle automatically according to the TNL setting.
		anex_automatic_onoff = "on"
		noexp_onoff = "off"
		SetVariable("mcvar_anex_automatic_onoff", "on")
		xg_draw_window()
	end

	function anex_automatic_off()	-- Manually turns off experience and disables automatic toggling.  Typing noexp again turns the automatics back on.
		anex_automatic_onoff = "off"
		noexp_onoff = "on"
		SetVariable("mcvar_anex_automatic_onoff", "off")
		xg_draw_window()
	end

--	[[ ****** WHERE TRICK FUNCTIONS ***** ]]
	--[[local wt = { index = 1, name = "", match = "" }
		function wt_continue(name, line, wildcards)
			wt.index = wt.index + 1
			Send("wt " .. wt.index .. "." .. wt.name)
		end
		function wt_fail(name, line, wildcards)
			EnableTriggerGroup("wt", false)
			Note("Search and Destroy: Aborting where trick...")
		end	]]


	function xset_to_mark(name, line, wildcards)
		local ri = current_room
		area_start_rooms[ri.arid] = {}
		area_start_rooms[ri.arid].roomid = ri.rmid
		tprint(area_start_rooms)
		local serial = serialize.save_simple(area_start_rooms)
		SetVariable("mcvar_areaStartRooms", serial)
		ColourNote("#FF5000", "", "\nxset mark: Room ",
				"#00C040", "", ri.rmid,
				"#FF5000", "", " set as start of area ",
				"#00C040", "", ri.arid,
				"#FF5000", "", ".\n")
	end

	function get_start_room(area_id)
		local arid = string.lower(area_id)
		start_room_type = "xset mark"					-- If 'xset mark' was set, xrunto will go there.
		if (area_start_rooms[arid] ~= nil) then 			-- Function exits as soon as any 'return' statement is encountered.
			return area_start_rooms[arid].roomid			-- Exact match on area id
		end
		for k,v in pairs (area_start_rooms) do
			if (string.match(string.lower(k), arid) ~= nil) then
				return v.roomid	-- string match on key
			end
		end
		start_room_type = "default"						-- If 'xset mark' isn't set, look up start room from the table areaDefaultStartRooms.
		if (areaDefaultStartRooms[arid] ~= nil) then 	-- Note, Upper/Lower Planes have the same default room.  More development needed here.
			return areaDefaultStartRooms[arid].start		-- exact match on area id
		end
		for k,v in pairs (areaDefaultStartRooms) do
			if (string.match(string.lower(k), arid) ~= nil) then
				return v.start	-- string match on key
			end
		end
		return "-1"
	end

--	[[ "xset vidblain" ]]
	function xset_vidblain(name, line, wildcards)
		local x = xset_vidblain_onoff
		x = (x == "on") and "off" or "on"
		xset_vidblain_onoff = x
		SetVariable("mcvar_xset_vidblain_onoff", x)
		ColourTell ("#FF5000", "", "\nVidblain navigation is now ",
					"#00C040", "", string.upper(x) .. "\n")
	end

	function xset_vidblain_setlevel(name, line, wildcards)
		local x = tonumber(wildcards.level) or "check"
		if (x == "check") then
			ColourTell ("#FF5000", "", "\n'xset vidblain' portal level is ",
						"#00C040", "", xset_vidblain_level .. "\n")
		else
			xset_vidblain_level = x
			SetVariable("mcvar_xset_vidblain_level", x)
			ColourTell ("#FF5000", "", "\n'xset vidblain' portal level set to ",
						"#00C040", "", x .. "\n")
		end
	end

	local is_vidblain_area_sql = "SELECT area " .. "FROM rooms " .. "WHERE uid = %s "

	function is_vidblain_area(roomid)
		local level = tier_level()--tonumber(gmcp("char.status.level")) + 10 * tonumber(gmcp("char.base.tier"))
		if (xset_vidblain_onoff == "on") and (level < xset_vidblain_level) then
			--local worldPath = GetInfo(66) .. Trim(sanitize_filename(WorldName()))
			--local db = assert(sqlite3.open(worldPath .. ".db"))
			local db = assert(sqlite3.open(mapper_db_file))
			local select = string.format (is_vidblain_area_sql, fixsql(roomid))
			local ar
			for row in db:nrows(select) do
				ar = row.area
			end
			db:close_vm()
			if (vidblain_area_list[ar]) then
				return true
			else
				return false
			end
		else
			return false
		end
	end

--	[[ Simulate cp ]]
	local cp_simulate_toggle = "0"
	function simulate_cp(name, line, wildcards)
		if (wildcards.type == "") then
			area_room_type = "area"
			current_activity = "cp"
		else
			area_room_type = wildcards.type
			current_activity = "cp"
		end
		local time_check = os.clock()					-- prevent double cp checks from different plugins
		if ((time_check - last_cp_check) < 1.0) then
			return
		end
		last_cp_check = time_check
		cp_check_list = {}
		EnableTrigger("trg_cp_check_line", true)
		Simulate("\n")
		if (cp_simulate_toggle == "0") then
			Simulate("You still have to kill * A test mob (A Cold Path)\n")	--dead
			Simulate("You still have to kill * the head necromancer's assistant (Necromancers' Guild)\n")
			Simulate("You still have to kill * Isscheburqua (Insanitaria)\n")
			Simulate("You still have to kill * a rook citizen (Avian Kingdom - Dead)\n")
			Simulate("You still have to kill * Lea, the farmer's daughter (Farmyard)\n")
			Simulate("You still have to kill * a rook citizen (Nesting Home)\n")
			Simulate("You still have to kill * a demon school student (The School of Horror)\n")
			Simulate("You still have to kill * a hookle fish (Black Lagoon)\n")
			Simulate("You still have to kill * Harry (Unknown Tower)\n")		--dead
			Simulate("You still have to kill * a former court jester (The Labyrinth)\n")
			Simulate("You still have to kill * Parent (A Cold Path - Dead)\n")
			Simulate("You still have to kill * a wealth redistribution specialist (Empyrean, Streets of Downfall)\n")
			Simulate("You still have to kill * the reaching thorns (Eternal Autumn)\n")
			Simulate("You still have to kill * Redtooth (Mossflower Wood - Dead)\n")	--dead
			Simulate("You still have to kill * Castle Guard (Rebellion of the Nix)\n")
			Simulate("You still have to kill * Jules (The Amazon Nation)\n")
			Simulate("You still have to kill * an earth fiend (The Broken Halls of Horath)\n")
			Simulate("You still have to kill * the spirit of Bakarne (The Empire of Aiighialla)\n")
			Simulate("You still have to kill * Elfgar Sous-Fled (Some Place)\n")
			Simulate("You still have to kill * the heart of a sandstorm (Living Mines of Dak'Tai)\n")
			cp_simulate_toggle = "1"
		else
			Simulate("You still have to kill * a former court jester (The Labyrinth)\n")
			Simulate("You still have to kill * the heart of a sandstorm (Buried in the Great Desert's unrelenting dunes)\n")
			Simulate("You still have to kill * Parent (The Kitchen)\n")
			Simulate("You still have to kill * a rhino seraph (A Corridor of Cinnamon and Silver)\n")
			Simulate("You still have to kill * A sprite prisoner (A cell)\n")
			cp_simulate_toggle = "0"
		end
		Simulate("Note: Dead means that the target is dead, not that you have killed it.\n")
		Simulate("\n")
		Simulate("You have 6 days, 23 hours and 56 minutes left to finish this campaign.\n")
		Simulate("\n")

	end

-- [[ Room notes ]]
	function room_note_area(name, line, wildcards)
		if (wildcards.arid == "") then
			--get_notes(current_room.arid, nil)
			get_notes(gmcp("room.info.zone"), nil)
		else
			get_notes(wildcards.arid, nil)
		end
	end

	function room_note(name, line, wildcards)
		--get_notes(nil, current_room.rmid)
		get_notes(nil, gmcp("room.info.num"))
	end

	function get_notes(arid, roomid, text_only)
		--local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		--local db = assert(sqlite3.open(worldPath .. ".db"))
		local db = assert(sqlite3.open(mapper_db_file))
		local sql =  " SELECT b.uid, b.notes "
		sql = sql .. " FROM bookmarks b "
		if (arid ~= nil) then
			sql = sql .. " INNER JOIN rooms r ON b.uid = r.uid "
			sql = sql .. " WHERE r.area = " .. fixsql(arid)
		else
			sql = sql .. " WHERE b.uid = " .. fixsql(roomid)
		end
		sql = sql .. " ORDER BY b.uid "
		local index = 0
		if (arid ~= nil) then
			Simulate("\nNotes for " .. getAreaNameFromId(arid) .. "\n")
		end
		for row in db:nrows(sql) do
			index = index + 1
			if (text_only == true) then
				local line = string.format("    note:'%s'", row.notes)
				Hyperlink("xmapper move " .. row.uid, line, "go to room " .. row.uid, "lightblue", "black", 0)
			else
				local line = string.format("    (%s) %s", row.uid, row.notes)
				Hyperlink("xmapper move " .. row.uid, line, "go to room " .. row.uid, "lightblue", "black", 0)
				print("")
			end
		end
		db:close_vm()
		if (arid ~= nil and index == 0 and text_only ~= true) then
			Simulate("\tNo notes.\n")
		end
	end

	function getAreaIdFromName(name)
		local db = assert(sqlite3.open(mapper_db_file))
		local sql =  "SELECT uid FROM areas WHERE name = %s"
		for row in db:nrows(string.format (sql, fixsql(name))) do
			db:close_vm()
			return row.uid
		end
		db:close_vm()
		return name
	end

	function getAreaNameFromId(arid)
		local db = assert(sqlite3.open(mapper_db_file))
		local sql =  "SELECT name FROM areas WHERE uid = %s"
		for row in db:nrows(string.format (sql, fixsql(arid))) do
			db:close_vm()
			return row.name
		end
		db:close_vm()
		return arid
	end

	function getAreaFromRoomId(room_id)
		local db = assert(sqlite3.open(mapper_db_file))
		local sql =  "SELECT area FROM rooms WHERE uid = %s"
		for row in db:nrows(string.format(sql, fixsql(room_id))) do
			db:close_vm()
			return row.area
		end
		db:close_vm()
		return room_id
	end

	function getAreaUid(name)
		local db = assert(sqlite3.open(mapper_db_file))
		local sql =  "SELECT uid FROM areas WHERE name = %s order by uid "
		local areas = {}
		local index = 0
		for row in db:nrows(string.format (sql, fixsql(name))) do
			index = index + 1
			areas[index] = {uid = row.uid, name = name}
		end
		db:close_vm()
		return areas
	end

--	[[ SQL execution ]]
	function RunSql(name, line, wildcards)
		local worldPath = GetInfo(66) .. "/worlds/plugins/"
		local db = assert(sqlite3.open(worldPath .. "sddb.db"))
		local index = 0
		local sql = wildcards.sql
		ColourNote("#00C040", "", "\nrunning sql: " .. sql)
		for row in db:nrows(sql) do
			index = index + 1
			print("----------- record " .. index .. " -----------" )
			--tprint(row)
	--		print (serialize.save ("row", row))
		end
		db:close_vm()
	end

	function ExecSql (name, line, wildcards)
		local db = assert(sqlite3.open(mapper_db_file))
		Note("executing " .. wildcards.sql)
	--	dbcheck (db:execute (fixsql(wildcards.sql)))
		db:execute(fixsql(wildcards.sql))
		db:close_vm()
		Note("ok")
	end


--	[[ page size functions ]]
	local page_size = 0
	local page_size_suspended = false

	function capture_page_size(name, line, wildcards)
		EnableTrigger("trg_capture_page_size", false)
		local size = tonumber(wildcards[1])
		page_size = size or 0
		SendNoEcho("pagesize 0")
	end

	function suspend_page_size(name, line, wildcards)
		if (page_size_suspended == false) then
			page_size_suspended = true
			ColourNote("#FF3030", "", "\nSearch and Destroy: Temporarily disabling pagesize (area index process)\n")
			EnableTrigger("trg_capture_page_size", true)
			EnableTrigger("trg_pagesize_gag_1", true)
			SendNoEcho("pagesize")
		end
	end

	function resume_page_size(name, line, wildcards)
		ColourNote("#FF3030", "", "\nSearch and Destroy: Area index complete. Pagesize re-enabled (if >0)\n")
		EnableTrigger("trg_capture_page_size", false)
		if (page_size ~= 0) then
			SendNoEcho("pagesize " .. page_size)
		end
		page_size_suspended = false
	end

	function xmapper_move(name, line, wildcards)
		local r = wildcards.roomid
		local s = wildcards.speed
		if (r == "-1") then
			ColourNote("#FF5000", "", "\nSearch and Destroy:  Can't go to room id -1 (nomap room)\n")
		elseif (r ~= "") then
			do_mapper_goto(r, s)
		end
	end

	function do_mapper_goto(r, s)
		if (s == nil or s == "") then
			s = speed
		end
		if (s == "walk") then
			--Note("walking to " .. r)
			Execute("mapper walkto " .. r)
		else
			Execute("mapper goto " .. r)
		end
	end

--	[[ Former plugin - S&D GUI ]]
	local window_fonts = {
		["title"]	= { f="Consolas",				 s=10, 				b=false, 	i=false, 	u=false },
		["bt1"]	 	= { f="Segoe",					 s=10, 				b=true, 	i=false, 	u=false },
		["bt2"] 	= { f="Segoe",					 s=10, 				b=true, 	i=false, 	u=false },
		["circ1"] 	= { f="Consolas",				 s=11, 				b=false, 	i=false, 	u=false },
		["circ2"]	= { f="Consolas",				 s= 9, 				b=false, 	i=false, 	u=false },
		["cplevel"] = { f="Consolas",				 s=11, 				b=false, 	i=false, 	u=false },
		["noexp"]	= { f="Consolas",				 s=11, 				b=false, 	i=false, 	u=false }, --noexp tnl
		["noexp2"]	= { f="Consolas",				 s= 9, 				b=false, 	i=false, 	u=false },
		["cplist_area"] = { f="Lucida Sans Unicode", s=win_font_size, 	b=false, 	i=false, 	u=false },
		["cplist_room"] = { f="Segoe", 				 s=win_font_size, 	b=false, 	i=false, 	u=false } }

	function xg_create_window()
		if (win_init == false) then
			win_init = true
			local width = win_width
			local height = win_height
			WindowCreate(win, windowinfo.window_left, windowinfo.window_top, width, height, windowinfo.window_mode, windowinfo.window_flags, win_bgcolor)  -- create window
			for k,v in pairs (window_fonts) do
				WindowFont(win, k, v.f, v.s, v.b, v.i, v.u, false)
			end
			WindowShow(win, true)  -- show it
			if (win_state == "min") then
				mouseup_drag(0, "hsMinimize")
			end
			if (IsPluginInstalled(plugin_id_z_order) and GetPluginInfo(plugin_id_z_order, 17)) then
				CallPlugin(plugin_id_z_order, "registerMiniwindow", win)
			end
			xg_draw_window()
		end
	end

	function xg_draw_window()
		WindowRectOp (win, miniwin.rect_fill, 0, 0, 0, 0, win_bgcolor)			-- Clear the window, which is the first step in updating it
		WindowRectOp (win, 2, 0, 0, 0, 17, 0x000000)						 	-- Draw title bar background and set color (almost black, "17" is height)
		WindowRectOp (win, 4, 0, 0, 0, 17, 0xE0E0E0, 0x909090)					-- Draw title bar border (left/top = light grey, right/bottom = darker grey, "17" is height)
		WindowRectOp (win, 1, 0, 0, 0, 0, 0xC0C0C0, 15)							-- Draw window border.
		WindowRectOp (win, 1, 1, 17, -1, -1, 0x000000, 15)						-- Draw colored perimeter line.
		WindowText (win, "title", 		-- draw the window title text and set its color
					current_sd_version,			-- window title text
					5, 0, 255, 15,				-- left (x1), top (y1), right (x2), bottom (y2) values for window title text
					0xA0FFFF, 					-- colour (light yellow)
					false)						-- not unicode
		if (win_hotspots["hsDrag1"] == nil) then	-- make the title bar draggable
			win_hotspots["hsDrag1"] = WindowAddHotspot(win, "hsDrag1", 0, 0, win_width-1, 16, -- hotspot id, rectangle (left, top, right, bottom)
						"", "", "mousedown_drag", "", "mouseup_drag",
						"Left click = Drag title bar to move\nRight click = Send window to front/back", miniwin.cursor_arrow, 0)
			WindowDragHandler(win, "hsDrag1", "dragmove", "dragrelease", 0)
		end

		draw_b1_action_buttons(47, 20)	-- draw xcp, go, etc. buttons
		draw_circle_readout(5, 20)		-- add circle text/level readout
		draw_noexp_readout(206, 22)	-- add noexp on/off and TNL indicator
		draw_resize_tag()
		xg_show_target_links()
		Redraw()
	end

	local button_1_list = {
--[[ 1 ]]	["hsXCP"] = { L=  0, text="xcp", tdx=3, tdy=3, exec1=     "xcp", exec2=   "xcp 0", tooltip="Left click = get target\nRight click = clear target" },
--[[ 2 ]]	["hsGO"]  = { L= 31, text= "go", tdx=7, tdy=3, exec1=      "go", exec2=    "go 0", tooltip="Left click = Go to room 1\nRight click = Go to area start" },
--[[ 3 ]]	["hsKK"]  = { L= 62, text= "kk", tdx=8, tdy=3, exec1=      "kk", exec2=      "kk", tooltip="Left click = 'kill' target mob\nRight click = kill with special" },
--[[ 4 ]]	["hsNX"]  = { L= 93, text= "nx", tdx=7, tdy=3, exec1=      "nx", exec2=     "nx-", tooltip="Left click = goto next\nRight click = goto prev" },
--[[ 5 ]]	["hsQS"]  = { L=124, text= "qs", tdx=8, tdy=3, exec1=      "qs", exec2=      "qs", tooltip="Quick-scan for current target (cp, quest, ht, qw)" },
--[[ 6 ]]	["hsQW"]  = { L=219, text= "qw", tdx=5, tdy=3, exec1=      "qw", exec2=     "qwx", tooltip="Left click = Quick-where\nRight click = Quick-where exact" },
--[[ 7 ]]	["hsHT"]  = { L=248, text= "ht", tdx=9, tdy=3, exec1=      "ht", exec2=     "hta", tooltip="Left click = Do hunt trick\nRight click = Cancel hunt trick" },
--[[ 8 ]]	["hsREF"] = { L=277, text="ref", tdx=6, tdy=3, exec1="xgui ref", exec2="xgui rel", tooltip="Left click = Refresh target list - cp (gq) check\nRight click = Reload target data - cp (gq) info" } }

	function draw_b1_action_buttons(left, top)
		local b1 = button_1_list
		for hs,b in pairs (b1) do
			draw_button_1_A(left+b.L, top, b.text, hs, b.tooltip, b.tdx, b.tdy)
		end
	end

	function draw_button_1_A(L, T, text, hsName, tooltip, tdx, tdy)
		local x,y,w,z = L, T, L+30, T+25
		local tx,ty = (x+tdx), (y+tdy)	-- x and y values for text location
		local bgcolor = 0x000000
		local color_1 = 0xE0E0E0
		local color_2 = 0x808080
		WindowRectOp(win,2, x,y,w,z, bgcolor)													-- Draw background and set color (black)
		WindowRectOp(win,4, x,y,w,z, color_1, color_2)											-- Draw button border (left/top = light grey, right/bottom = darker grey)
		WindowText(win, "bt1", text, tx,ty,w-1,z-1, color_1, false)								-- Draw button text ("button" font, light grey)
		if (win_hotspots[hsName] == nil) then																-- Make button clickable by defining a hotspot
			win_hotspots[hsName] = WindowAddHotspot(win, hsName, x, y, w, z,							-- Hotspot name and location info
				"", "", "mousedown_b1", "cancelmousedown_b1", "mouseup_b1",				-- Mouse actions
				"" .. (tooltip or text), miniwin.cursor_arrow, 0)											-- Tooltip text, cursor shape (hand)
		end
	end

	function draw_button_1_B(L, T, text, hsName, tooltip, tdx, tdy)
		local x,y,w,z = L, T, L+30, T+25											-- x and y values for button boundaries
		local tx,ty = (x+tdx), (y+tdy)	-- x and y values for text location
		local bgcolor = 0x000060	-- red
		local color_1 = 0x80E0E0	-- yellow
		local color_2 = 0x80E0E0	-- yellow
		WindowRectOp (win,2, x,y,w,z, bgcolor)												-- Draw background and set color (black)
		WindowRectOp (win,4, x,y,w,z, color_1, color_2)										-- Draw button border (left/top = light grey, right/bottom = darker grey)
		WindowText(win, "bt1", text, tx,ty,w-1,z-1, color_1, false)								-- Draw button text ("button" font, light grey)
			---win_hotspots[hsName] = WindowAddHotspot(win, hsName, x,y,w,z,					-- Hotspot name and location info
				--"", "", "", "", "",	-- "mouseover", "cancelmouseover", "mousedown", "cancelmousedown", "mouseup"
			--	"" .. (tooltip or text), miniwin.cursor_arrow, 0)	-- Tooltip text, cursor shape (hand)
	end




	local win_circle_readout_vars = {
			["cp"] 	 = { cc, cc1="r", cc2y="", tc1="", tc2="", tdx="", tdy="", text="" },
			["gq"] 	 = { cc1n="", cc2n="", cc1y="", cc2y="", tc1="", tc2="", tdx="", tdy="", text="" },
			["init"] = { cc1n="", cc2n="", cc1y="", cc2y="", tc1="", tc2="", tdx="", tdy="", text="" },
			["none"] = { cc1n="", cc2n="", cc1y="", cc2y="", tc1="", tc2="", tdx="", tdy="", text="" }, }


	--local win_circle_readout_colors = { g1=0x30C000, g2=0x004000, r1=0x0040F0, r2=0x000080, u1=0xC08800, u2=0x403000, v1=0xC000C0, v2=0x400040 }
	local win_circle_border_colors = { g={0x30C000,0x004000}, r={0x0040F0,0x000080}, u={0xC08800,0x403000}, v={0xC000C0,0x400040} }
	local win_circle_text_colors

	function draw_circle_readout(left, top)
		local level, ar_rm, get_new = cp_info_level, area_room_type, can_get_new_cp
		local activity = current_activity
		local width, height = 36, 36
		local cx1,cy1 = left+1, top+1; local cx2,cy2 = (cx1+width), (cy1+height)
		local g1,g2, r1,r2, u1,u2, v1,v2 = 0x30C000,0x004000, 0x0040F0,0x000080, 0xC08800,0x403000, 0xC000C0,0x400040	-- green, red, blue, violet
		local tdx, tdy = 6, 8
		local circle_color_1, circle_color_2, text_color, text
		local font = "circ1"
		if(activity == "cp") then
			circle_color_1 = (get_new == "yes") and g1 or r1; circle_color_2 = (get_new == "yes") and g2 or r2
			text_color_1 = 0xA0FFFF; text_color_2 = 0x0C1830
			text = tostring(level)
			local llen = string.len(text)
			--if (llen == 3) then tdx = 6
			if (llen == 2) then tdx = 10
			elseif (llen == 1) then tdx = 14
			end
		elseif (activity == "none") then
			circle_color_1 = (get_new == "yes") and g1 or r1; circle_color_2 = (get_new == "yes") and g2 or r2
			text_color_1 = (get_new == "yes") and 0x0050FF or 0x0070FF; text_color_2 = 0x000040
			text = "off"
		elseif (activity == "gq") then
			circle_color_1 = v1; circle_color_2 = v2
			text_color_1 = 0xA0FFFF; text_color_2 = 0x0C1830
			text = "gq"
			tdx = 10; tdy = 6
		elseif (activity == "init") then
			circle_color_1 = u1; circle_color_2 = u2
			text_color_1 = 0xB0B0B0; text_color_2 = 0x080808
			text = "init"
			font = "circ2"
			tdx = 4; tdy = 10
		end

		--if (ar_rm == "none") then	-- player not on cp
		--	circle_color_1 = (get_new == "yes") and g1 or r1
		--	circle_color_2 = (get_new == "yes") and g2 or r2
		--	text_color_1 = (get_new == "yes") and 0x0050FF or 0x0070FF
		--	text_color_2 = 0x000040
		--	tdx = 6
		--	tdy = 8
		--	text = "off"
		--elseif (ar_rm == "init") then		-- plugin is loading, no info yet
		--	circle_color_1 = u1
		--	circle_color_2 = u2
		--	text_color_1 = 0xB0B0B0
		--	text_color_2 = 0x080808
		--	tdx = 4
		--	tdy = 10
		--	text = "init"
		--	font = "circ2"				-- show "init" in circle while plugin installs
	--	else							-- player is on cp or gq
	--		if (current_activity == "gq") then
	--			circle_color_1 = v1
	--			circle_color_2 = v2
	--			text_color_1 = 0xA0FFFF
	--			text_color_2 = 0x0C1830
	--			text = "gq"
	--			tdx = 10
	--			tdy = 6
	--		elseif (current_activity == "cp") then
	--			circle_color_1 = (get_new == "yes") and g1 or r1
	--			circle_color_2 = (get_new == "yes") and g2 or r2
	--			text_color_1 = 0xA0FFFF
	--			text_color_2 = 0x0C1830
	--			text = tostring(level)
	--			local llen = string.len(text)
	--			if (llen == 3) then tdx = 6
	--			elseif (llen == 2) then tdx = 10
	--			elseif (llen == 1) then tdx = 14
	--			else
	--				tdx = 6
	--				text = "err"
	--			end
	--		end
	--	end
		WindowCircleOp(win, 1, cx1+1, cy1+1, cx2-1, cy2-1, circle_color_2, 0, 2, win_bgcolor, 1)	-- inner circle (dark)
		WindowCircleOp(win, 1, cx1-1, cy1-1, cx2+1, cy2+1, circle_color_2, 0, 2, win_bgcolor, 1)	-- outer circle (dark)
		WindowCircleOp(win, 1, cx1, cy1, cx2, cy2, circle_color_1, 0, 2, win_bgcolor, 1)			-- main circle (bright)
		local tx1,tx2, ty1,ty2 = (cx1+tdx),(cx2), (cy1+tdy),(cy2)
		WindowText(win, font, string.format("%s", text), tx1+1, ty1, tx2+1, ty2, text_color_2, false)		-- text shadow effect
		WindowText(win, font, string.format("%s", text), tx1+2, ty1+1, tx2+2, ty2+1, text_color_2, false)	-- text shadow effect
		WindowText(win, font, string.format("%s", text), tx1, ty1, tx2, ty2, text_color_1, false)			-- actual text and color
	end

	function draw_noexp_readout(left, top)
		WindowDeleteHotspot(win, "hs_noexp")
		local symbol = {
			{ x1= 0, y1= 0, x2=12, y2= 0, c0=0x30FF00, c1=0x0030FF, th=2 },		-- top bar
			{ x1= 0, y1= 3, x2=12, y2= 3, c0=0x000000, c1=0x0030FF, th=2 },		-- second bar
			{ x1= 7, y1= 6, x2= 7, y2=21, c0=0x303030, c1=0x00073F, th=1 },		-- shadow vertical
			{ x1= 6, y1= 6, x2= 6, y2=21, c0=0xC0C0C0, c1=0x0060FF, th=2 },		-- vertical
			{ x1= 0, y1=10, x2= 5, y2= 5, c0=0xC0C0C0, c1=0x0060FF, th=2 }, 	-- left diagonal
			{ x1=11, y1=10, x2= 6, y2= 5, c0=0xC0C0C0, c1=0x0060FF, th=2 } }	-- right diagonal
		local text_color_1 = 0xA0FFFF
		local text_color_2 = 0x0C1830
		local tooltip = "Left click: +100 \nRight click: -100"
		for i,v in ipairs (symbol) do
				local color = (noexp_onoff == "on") and v.c1 or v.c0
				WindowLine(win, left+v.x1,top+v.y1,left+v.x2,top+v.y2, color, 256, v.th)
		end
		if (anex_automatic_onoff == "on") then
			WindowText(win, "noexp", string.format("%s", anex_tnl_cutoff), left+18, top+4, left+62, top+21, text_color_2, false)
			WindowText(win, "noexp", string.format("%s", anex_tnl_cutoff), left+17, top+4, left+61, top+20, text_color_2, false)
			WindowText(win, "noexp", string.format("%s", anex_tnl_cutoff), left+16, top+3, left+60, top+20, text_color_1, false)
			--if (win_hotspots["hs_noexp"] == nil) then																-- Make button clickable by defining a hotspot
				win_hotspots["hs_noexp"] = WindowAddHotspot(win, "hs_noexp", left, top, left+55, top+25,							-- Hotspot name and location info
					"", "", "", "", "mouseup_noexp",				-- Mouse actions
					"" .. (tooltip), miniwin.cursor_arrow, 0)											-- Tooltip text, cursor shape (hand)
			--end
		else
			WindowText(win, "noexp2", string.format("%s", "manual"), left+17, top+4, left+61, top+21, text_color_2, false)
			WindowText(win, "noexp2", string.format("%s", "manual"), left+16, top+4, left+60, top+20, text_color_2, false)
			WindowText(win, "noexp2", string.format("%s", "manual"), left+15, top+3, left+59, top+20, text_color_1, false)
			--if (win_hotspots["hs_noexp"] == nil) then																-- Make button clickable by defining a hotspot
				win_hotspots["hs_noexp"] = WindowAddHotspot(win, "hs_noexp", left, top, left+55, top+25,							-- Hotspot name and location info
					"", "", "", "", "mouseup_noexp",				-- Mouse actions
					"" .. ("Noexp is manually off, type 'noexp' again to turn on"), miniwin.cursor_arrow, 0)
			--end
		end
	end

	function draw_resize_tag()
		local w = win_width
		local h = win_height
		local rts = 13
		local c1,c2 = 0x707070, 0xF0F0F0
		local x,y = w-4, h-4		-- bottom of resize widget tag
		for i=0,9,3 do
			WindowLine(win, x-(i+2), y, x+1, y-(i+3), c2, 0, 1)	-- dark lines
			WindowLine(win, x-i, y, x+1, y-(i+1), c1, 0, 1)	-- bright lines
		end
		WindowSetPixel (win, x, y, 0xF0F0F0)
		if (WindowHotspotInfo(win, "hsResize", 1) == nil) then
			WindowAddHotspot(win, "hsResize", w-rts, h-rts, win_width, h, "", "", "mousedown_resize_window", "", "", "", 6, 0)
			WindowDragHandler(win, "hsResize", "ResizeMoveCallback", "ResizeReleaseCallback", 0)
		else
			WindowMoveHotspot(win, "hsResize", w-rts, h-rts, 0, 0)
		end
	end



	function xg_show_target_links()
		for i,v in ipairs (win_target_hotspots) do
			WindowDeleteHotspot(win, v)
		end
		win_target_hotspots = {}
		if (win_state == "min") then return	end
		local list = main_target_list
		local font = "cplist_" .. area_room_type
		local index = 0
		local resize_tag = 13
		local targ_list_top = 59
		local targ_list_bottom = win_height - 5
		for i,v in ipairs (list) do
			index = i
			if (((index-1) * win_line_space + targ_list_top) > targ_list_bottom) then break end		-- Abort loop if printed item would not be visible.
			local mob = v.mob .. ((v.is_dead == "yes") and " [Dead]" or "")
			local ar = v.arid
			local ct = v.link_type
			local location
			local eventHandler = "win_mouseup_target_link"
			if (ct == "area") then
				location = string.format("%s", ar)
			elseif (ct == "room") then
				location = string.format("'%s' (%s)", v.roomName, ar)
			elseif (ct == "unknown") then
				location = string.format("'%s' (unknown)", v.location)
				eventHandler = ""
			end
			local qty = ((player_on_gq == "yes") and v.qty .. "* " or "")
			local link = string.format("%s)  %s%s - %s", index, qty, mob, location)
			local color = ((index == xcp_index) and "0x0040FF" or convert_color_format(v.color))

			local font_height = WindowFontInfo (win, font, 1) -- WindowFontInfo (win, font, 4)
			local hs_left = (index < 10) and 13 or 6
			local hs_top = (targ_list_top + ((index-1) * win_line_space))
			local hs_right = (hs_left + WindowTextWidth(win, font, link))
			local hs_bottom = (hs_top + font_height + 1) --(hs_top + win_line_space )

			if (hs_right > win_width - 5) then hs_right = (win_width - 5) end
			WindowText(win, font, link, hs_left, hs_top, 0, 0, color, false)
			if (hs_bottom > win_height - resize_tag) then		-- Prevent list item's hotspot from overlapping with the resize tag
				if (hs_right > win_width - resize_tag - 5) then
					hs_right = win_width - resize_tag - 5
				end
			end
			win_target_hotspots[#win_target_hotspots+1] = index
			--WindowRectOp (win, 1,
			--				hs_left-1, hs_top+2, hs_right+2, hs_bottom, 0x000080, 15)
			WindowAddHotspot(win, index,
							hs_left-1, hs_top+2, hs_right+2, hs_bottom,		-- hotspot boundary rectangle
							"", "", "", "",								-- "mouseover", "cancelmouseover", "mousedown", "cancelmousedown"
							eventHandler, "", miniwin.cursor_arrow, 0)	-- "mouseup", tooltip, cursor type
		end
	end

-- [[ GUI window mouse click functions (buttons, links, etc.) ]]
	function mouseup_b1(flags, hotspot_id)	-- when mouse button is released, redraw the buttons to normal appearance.
		local b = button_1_list[hotspot_id]
		local click = ((bit.band(flags, 0x20) == 0) and "L" or "R")
		local left = WindowHotspotInfo(win, hotspot_id, 1)
		local top = WindowHotspotInfo(win, hotspot_id, 2)
		draw_button_1_A(left, top, b.text, hotspot_id, b.tooltip, b.tdx, b.tdy)
		Redraw()
		Execute(((click == "L") and b.exec1 or b.exec2))
	end

	function mousedown_b1(flags, hotspot_id)	-- when mouse button is pressed:
		local b = button_1_list[hotspot_id]
		local click = ((bit.band(flags, 0x20) == 0) and "L" or "R")
		local left = WindowHotspotInfo(win, hotspot_id, 1)
		local top = WindowHotspotInfo(win, hotspot_id, 2)
		draw_button_1_B(left, top, b.text, hotspot_id.."2", "", b.tdx, b.tdy)
		Redraw()
	end

	function cancelmousedown_b1(flags, hotspot_id)
		local b = button_1_list[hotspot_id]
		local click = ((bit.band(flags, 0x20) == 0) and "L" or "R")
		local left = WindowHotspotInfo(win, hotspot_id, 1)
		local top = WindowHotspotInfo(win, hotspot_id, 2)
		draw_button_1_A(left, top, b.text, hotspot_id, b.tooltip, b.tdx, b.tdy)
		Redraw()
	end

	function mousedown_resize_window(flags, hotspot_id)
	if (hotspot_id == "hsResize") then
		startx, starty = WindowInfo (win, 17), WindowInfo (win, 18)
	end
	end

	function mouseup_noexp(flags)
		local f = flags
		local hs = "hs_noexp"
		local click = ((bit.band(f, 0x20) == 0) and "L" or "R")
		if (anex_automatic_onoff == "on") then
			if (click == "L") then
				anex_tnl_cutoff = anex_tnl_cutoff + 100
				if (anex_tnl_cutoff > 9900) then anex_tnl_cutoff = 9900 end
			elseif (click == "R") then
				anex_tnl_cutoff = anex_tnl_cutoff - 100
				if (anex_tnl_cutoff < 0 ) then anex_tnl_cutoff = 0 end
			else
				-- do nothing
			end
			SetVariable("mcvar_anex_tnl_cutoff", anex_tnl_cutoff)
			anex_check_tnl_silent()
			xg_draw_window()
		end
	end

	function mousedown_drag(flags, hotspot_id)
		win_dragmove_start_x = WindowInfo(win, 14)
		win_dragmove_start_y = WindowInfo (win, 15)
	end

	function mouseup_drag(flags, hotspot_id)
		local f = flags
		local click = ((bit.band(f, 0x20) == 0) and "L" or "R")
		if (hotspot_id == "hsDrag1") then
			if (click == "R") then
				right_click_menu()
			end
		end
	end

	function win_mouseup_target_link(flags, hotspot_id)
		if (tonumber(hotspot_id) ~= nil) then
			xcp_arg("", "", {index=hotspot_id})
		end
	end

--	[[ Window dragging / moving ]]
	function dragmove(flags, hotspot_id)
		if (bit.band(flags, 0x20) == 0) then
			win_pos_x = WindowInfo(win, 17) -- - 50
			win_pos_y = WindowInfo(win, 18) -- - 7
			local delta_x = win_pos_x - win_dragmove_start_x
			local delta_y = win_pos_y - win_dragmove_start_y
			local max_x = GetInfo(281) - 100
			local max_y = GetInfo(280) - 60
			if (delta_x <= 1) then 			-- Prevents window from leaving the screen.  The bug that got me started on all this.
				delta_x = 1
			elseif (delta_x >= max_x) then
				delta_x = max_x
			end
			if (delta_y <= 1) then
				delta_y = 1
			elseif (delta_y >= max_y) then
				delta_y = max_y
			end
			WindowPosition(win, delta_x, delta_y, miniwin.pos_stretch_to_view, miniwin.create_absolute_location) -- move window to new location
		else
			return
		end
	end

	function dragrelease(flags, hotspot_id)
	--  print ("mouse drag release for " .. hotspot_id)
	--  print ("released at position", WindowInfo (win, 17), WindowInfo (win, 18))
	end

--	[[ Window resize functions ]]

	local lastRefresh = 0

	function ResizeMoveCallback()
		local screen_width = GetInfo(281) - 100
		local screen_height = GetInfo(280) - 60
		if (GetPluginVariable("c293f9e7f04dde889f65cb90", "lock_down_miniwindows") == "1") then
			return
		end
		local x, y = WindowInfo (win, 17), WindowInfo (win, 18)
		win_width = win_width + x - startx
		startx = x
		if (win_width < win_width_min) then
			win_width = win_width_min
			startx = windowinfo.window_left+win_width
		elseif (win_width > screen_width) then
			win_width = screen_width
			startx = windowinfo.window_left+win_width
		end
		win_height = win_height + y - starty
		starty = y
		if (win_height < win_height_min) then
			win_height = win_height_min
			starty = windowinfo.window_top+win_height
		elseif (win_height > screen_height) then
			win_height = screen_height
			starty = windowinfo.window_top+win_height
		end
		WindowResize(win, win_width, win_height, win_bgcolor)
		local freq = 90
		local t = utils.timer()
		if ((t - lastRefresh) > (1/freq)) then	-- redraw rate while resizing (per second)
			xg_draw_window()
			lastRefresh = t
		end
	end

	function ResizeReleaseCallback()
		win_state = "max"
		w = win_width
		h = win_height
		WindowDeleteHotspot(win, "hsDrag1")
		win_hotspots["hsDrag1"] = WindowAddHotspot(win, "hsDrag1", 0, 0, w-1, 16, -- hotspot id, rectangle (left, top, right, bottom)
					"", "", "mousedown_drag", "", "mouseup_drag", --mouseover, cancelmouseover, mousedown_drag, cancelmousedown, mouseup_drag
					"Left click = Drag title bar to move\nRight click = Send window to front/back", miniwin.cursor_arrow, 0)
		WindowDragHandler(win, "hsDrag1", "dragmove", "dragrelease", 0)
		xg_draw_window()
	end

--	[[ Window right click menu]]
	function right_click_menu()
		menustring = ("Bring To Front|Send To Back|Collapse Window|Expand Window")
		result = WindowMenu (win,
			WindowInfo (win, 14),		-- x position
			WindowInfo (win, 15),		-- y position
			menustring)					-- content
		if (result == "Bring To Front") then
			CallPlugin(plugin_id_z_order,"boostMe", win)
		elseif (result == "Send To Back") then
			CallPlugin(plugin_id_z_order,"dropMe", win)
		elseif (result == "Collapse Window") then
			win_state = "min"
			win_height = win_height_min
			WindowResize(win, win_width, win_height, ColourNameToRGB("black"))
			xg_draw_window()
			Redraw()
		elseif (result == "Expand Window") then
			win_state = "max"
			win_height = win_height_max
			WindowResize(win, win_width, win_height, ColourNameToRGB("black"))
			xg_draw_window()
		end
	end

	function xgui_RefreshLinks()
		if current_activity == "gq" then
			do_gq_check()
		else
			do_cp_check()
		end
		mouseup_drag(0, "hsMaximize")
	end

	function xgui_ReloadLinks()
		if current_activity == "gq" then
			do_gq_info()
		else
			do_cp_info()
		end
		mouseup_drag(0, "hsMaximize")
	end

	function xset_ToggleWindowDisplay(name, line, wildcards)
		local arg = wildcards.onoff
		if (arg == "on") or (arg == "show") or (arg == "1") then
			WindowShow(win, true)
			SetVariable("mcvar_xgui_window_onoff", "on")
		elseif (arg == "off") or (arg == "hide") or (arg == "0") then
			WindowShow(win, false)
			SetVariable("mcvar_xgui_window_onoff", "off")
		end
	end

	function xset_font_size(name, line, wildcards)
		if (wildcards.size == "") then
			print("Cp list font size = " .. win_font_size .. "\n")
		else
			win_font_size = tonumber(wildcards.size)
			WindowFont(win, "cplist_area", "Lucida Sans Unicode", win_font_size, false, false, false, false)		-- cp list font, area cp's
			WindowFont(win, "cplist_room", "Segoe", win_font_size, false, false, false, false)					-- cp list font, room cp's
			print("Cp list font size set to " .. win_font_size .. ".\n")
			SetVariable("mcvar_window_font_size", win_font_size)
			xg_draw_window()
		end
	end

	function xset_line_space(name, line, wildcards)
		local x = tonumber(wildcards.space)
		local line_space = win_line_space
		if (wildcards.space == "") then
			print("Cp list line spacing = " .. line_space .. "\n")
		else

			print("Cp list line spacing set to " .. x .. ".\n")
			win_line_space = x
			SetVariable("mcvar_window_line_space", x)
			xg_draw_window()
		end
	end

	function OnPluginSaveState()
		movewindow.save_state(win)	-- save window location
		if WindowInfo(win, 3) and WindowInfo(win, 4) then
			win_width = WindowInfo(win, 3)
			win_height = WindowInfo(win, 4)
		end
		SetVariable("mcvar_window_pos_x", win_pos_x)
		SetVariable("mcvar_window_pos_y", win_pos_y)
		SetVariable("mcvar_window_state", win_state)
		SetVariable("mcvar_window_width", win_width)
		SetVariable("mcvar_window_height", win_height)
		SetVariable("mcvar_window_width_max", win_width_max)
		SetVariable("mcvar_window_height_max", win_height_max)
	end

	function OnPluginClose()
		OnPluginSaveState()
		WindowShow(win, false) 			-- hide window, refresh screen
	end

	function set_speed(name, line, wildcards)
		if (wildcards.speed ~= "") then
			speed = wildcards.speed
		else
			if (speed == "walk") then
				speed = "run"
			else
				speed = "walk"
			end
		end
		ColourNote("#FF5000", "", "Move speed:" .. speed)
	end

-- Internal Utilities
	function convert_color_format(s)	-- convert color format from #FF8800 (used by colournote, etc.) to 0x0088FF (used for window text)
		local con = "0x"
		for i=1,3,1 do
			con = con .. string.sub(s, 8-(2*i), 9-(2*i))
		end
		return con
	end

	--function copytable(t)
	--	local new_t = {}
	--	table.foreachi(t,
	--		function (k, v)
	--			table.insert (new_t, v)
	--		end)
	--	return new_t
	--end

	function cprint(c1, txt)		-- colournote abbreviation
		ColourNote(c1, "", txt)
	end

	function dbcheck(code, query)
		if (code ~= sqlite3.OK) and    -- no error
		(code ~= sqlite3.ROW) and   -- completed OK with another row of data
		(code ~= sqlite3.DONE) then -- completed OK, no more rows
			local err = db:errmsg ()  -- the rollback will change the error message
			err = err.."\n\nCODE: "..code.."\nQUERY: "..query.."\n"
			db:exec("ROLLBACK")      -- rollback any transaction to unlock the database
			error (err, 2)            -- show error in caller's context
		end
	end

	function fixbool(b)
		if b then
			return 1
		else
			return 0
		end
	end

	function fixsql(s)
		if s then
			return "'" .. (string.gsub (s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
		else
			return "NULL"
		end
	end

	function gmcp(s)
	local ret, datastring = CallPlugin(plugin_id_gmcp_handler, "gmcpdata_as_string", s)
	pcall(loadstring("data = "..datastring))
	return data
	end

	function send_gmcp_packet(s)
	CallPlugin(plugin_id_gmcp_handler, "GMCP_send", s)
	end

	function int(n)
		if not tonumber(n) then
			return
		else
			return math.floor(n)
		end
	end

	function md5(s)
		local hash = utils.tohex(utils.md5(tostring(s)))
		return hash
	end

	function padRight(text, length, padChar)
		local padding = length - string.len(text)
		text = text .. string.rep(padChar, padding)
		return text
	end

	function quote(text)
		return "\""..text.."\""
	end

	function round_banker(x)		-- round normally, but when number ends in exactly .5 round to nearest even value.
	if (x == 0) then return 0 end	-- prevent returning -0
	if (x + 0.5) % 2 == 0 then
		return math.floor(x + 0.5)
	else
		return math.ceil(x - 0.5)
	end
	end

	function rtrim(s)
		local n = #s
		while n > 0 and s:find("^%s", n) do n = n - 1 end
		return s:sub(1, n)
	end

	function sanitize_filename(str)
		str = string.gsub(str, "[^%w%s()_-]", "")
		return str
	end

	function spairs(t, f)
		local tbl = {}
		for n in pairs(t) do
			table.insert(tbl, n)
		end
		table.sort(tbl, f)
		local i = 0      -- iterator variable
		local iter = function ()   -- iterator function
			i = i + 1
			if (tbl[i] == nil) then
				return nil
			else
				return tbl[i], t[tbl[i]]
			end
		end
		return iter
	end

	function split(line, delim)
		local result = {}
		local index = 1
		for token in string.gmatch(line, delim) do
			result[index] = token
			index = index + 1
		end
		return result
	end

	function trim(s)
		return s:match'^()%s*$' and '' or s:match'^%s*(.*%S)'
	end

	function tier_level()
		local l = tonumber(gmcp("char.status.level"))
		local t = tonumber(gmcp("char.base.tier"))
		return (l + 10*t)
	end


-- [[ Random stuff that doesn't fit anywhere else (?) ]]
	function xtest_roomhist()
		ColourNote("#00FFFF", "", "\ni: 0    r: " .. string.format("%-5s", room_history[0].rmid) .. "  a: " .. room_history[0].arid)
		for i,v in ipairs (room_history) do
			print("i: " .. string.format("%-3s", i) .. "  r: " .. string.format("%-5s", v.rmid) .. "  a: " .. string.format("%-10s", v.arid))
		end
		print("")
	end

	function xtest_areadata()
		local db = assert(sqlite3.open(mapper_db_file))
		local sql = "SELECT uid, name FROM areas"
		local ar = { }
		local dasr = areaDefaultStartRooms	-- default start rooms
		local xasr = area_start_rooms	-- xset marked start rooms
		local alr = area_range_index	-- area level range table
		--local worldPath = GetInfo(66) .. "/worlds/plugins/"
		--local db = assert(sqlite3.open(worldPath .. "sddb.db"))
		local index = 0
		ColourNote("#00C040", "", "\nrunning sql: " .. sql)
		for row in db:nrows(sql) do
			index = index + 1
			local a = row.uid
			local an = row.name
			local q = (dasr[a].noquest == true) and "0" or "1"
			local d = dasr[a].start
			local c = (xasr[a] ~= nil) and ((xasr[a].roomid ~= d) and xasr[a].roomid or "-1") or "-1"
			ar[index] = { arid=a, area_name=an, def_startroom=d, cur_startroom=c, questable=q, minlvl="-1", maxlvl="-1", lock="-1" }
		end
		db:close_vm()
		for i,v in ipairs (ar) do
			local a = v.arid
			local an = v.area_name
			if (alr[an] ~= nil) then
				v.minlvl = alr[an].min
				v.maxlvl = alr[an].max
			end
		end
		--	if (dasr[v.arid].noquest == true) then
		--		v.questable = "0"
		--	else
		--		v.questable = "1"
		--	end
		--end
		--tprint(ar)
		--tprint(area_start_rooms)
		--tprint(alr)
	end

	function xtest_mcvars()
		local t = GetVariableList()
		tprint(t)
	end

	function xmap_rooms_linking_here(name, line, wildcards)
		local room_id = tonumber(wildcards.room_id) or tonumber(current_room.rmid) or -1
		local r1 = {}
		local list = {}
		local Q1 = string.format("SELECT uid, name, area FROM rooms WHERE uid = %s ", fixsql(room_id))
		local Q2 = string.format("SELECT exits.dir as edir, exits.fromuid as efrom, exits.touid as eto, rooms.name as name, rooms.area as arid FROM exits,rooms WHERE exits.touid = %s AND rooms.uid = exits.fromuid ORDER BY efrom ASC ", fixsql(room_id), fixsql(room_id))
		local db = assert(sqlite3.open(mapper_db_file))
		for row in db:nrows(Q1) do
			r1 = { rmid = row.uid, arid = row.area, roomname = row.name }
		end
		for row in db:nrows(Q2) do
			local ru = string.format("%5s", row.efrom)
			list[ru] = {
				roomname = row.name,
				arid = row.arid,
				exit_dir = row.edir, }
		end
		db:close_vm()
		print("\n" .. "Rooms linking to " .. r1.rmid .. ": " .. r1.roomname .. " (" .. r1.arid .. ")" .. "\n")
		for k,v in spairs (list) do
			print(k .. ": " .. v.roomname .. " (" .. v.arid .. ") - " .. v.exit_dir)
		end
		print("")
	end

	function xtest_loadroom(name, line, wildcards)
		local ri = current_room
		local room_id = tonumber(wildcards.room_id) or tonumber(ri.rmid) or -1
		local roomdata = {}
		local sql_roomdata = "SELECT uid, name, area, info, noportal, norecall, ignore_exits_mismatch " .. "FROM rooms " .. "WHERE uid = %s "
		local sql_exitrow = "SELECT dir, fromuid, touid, level " .. "FROM exits " .. "WHERE fromuid = %s "
		local sel_roomdata = string.format(sql_roomdata, fixsql(room_id))
		local sel_exits = string.format(sql_exitrow, fixsql(room_id))
		local db_results_found = false
		local db = assert(sqlite3.open(mapper_db_file))
		for row in db:nrows(sel_roomdata) do
			roomdata = {
				roomid = row.uid,
				roomname = row.name or "-no room name-",
				arid = row.area or "-no area-",
				--building = row.building,
				--terrain = row.terrain,
				info = row.info or "-no info-",
				--notes = row.notes,
				--x = row.x or 0,
				--y = row.y or 0,
				--z = row.z or 0,
				noportal = row.noportal or 0,
				norecall = row.norecall or 0,
				exits = {},
				exit_locks = {},
				ig_ex_mis = (row.ignore_exits_mismatch == 1)
				}
			for exitrow in db:nrows(sel_exits) do
				roomdata.exits[exitrow.dir] = tostring(exitrow.touid)
				roomdata.exit_locks[exitrow.dir] = tostring(exitrow.level)
			end -- for each ex
		end
		db:close_vm()

		if not (roomdata.roomid) then
			roomdata = {
				roomid = tostring(room_id),
				roomname = "-1",
				arid = "-1",
				info = "none",
				noportal = 0,
				norecall = 0,
				exits = {},
				exit_locks = {},
				ig_ex_mis = false
				}
		end
		table.insert(xtest_loadroom_table, roomdata)
		tprint(xtest_loadroom_table)
		print("")
	end

	function xtest_popmsg(name, line, wildcards)

	end

	function xtest_debug(name, line, wildcards)
		if debug_mode == "on" then
			ColourNote("gold", "", "Debug mode ", "tomato", "", "disabled\n")
			debug_mode = "off"
		else
			ColourNote("gold", "", "Debug mode ", "lime", "", "enabled\n")
			debug_mode = "on"
		end
		SetVariable("debug_mode", debug_mode)
	end

	function DebugNote(text)
		if debug_mode == "on" then
			ColourNote("gold", "", "DEBUG: ", "lightskyblue", "", text)
		end
	end

-- [[ New code ]]

	function update_plugin()
		raw = "https://raw.githubusercontent.com/AardCrowley/Search-and-Destroy/master/Search_and_Destroy.xml"

		async_ok, async = pcall (require, "async")

		if async_ok then
			plugin_page = async.doAsyncRemoteRequest(raw, raw_get, "HTTPS")
		else
			ColourNote("white", "blue", "Error on plugin update!")
		end
	end

	function raw_get(retval, page, status, headers, full_status, request_url)
		if status == 200 then
			raw_version = tonumber(string.match(page, '<plugin version="([0-9%.]+)"'))
		end

		if raw_version == PLUGIN_VERSION then
			ColourNote("white", "blue", PLUGIN_NAME .. " is up-to-date.")
		elseif raw_version > PLUGIN_VERSION then
			ColourNote("white", "blue", "Updating from version " .. PLUGIN_VERSION .. " to " .. raw_version .. ". Do not touch anything!")
			local file = io.open(GetPluginInfo(GetPluginID(), 6), "w")
			file:write(page)
			file:close()

			if "" == GetAlphaOption("script_prefix") then
				SetAlphaOption("script_prefix", "\\\\\\")
			end

			Execute(GetAlphaOption("script_prefix") .. "DoAfterSpecial(1, \"ReloadPlugin('" .. GetPluginID() .. "')\", sendto.script)")
			ColourNote("white", "blue", "Update complete!")
		end

		raw_version = nil
	end -- end Update code

	function helpWrap (str, limit, indent, indent1)
		indent = indent or ""
		indent1 = indent1 or indent
		limit = limit or 76
		local here = 1-#indent1
		local lastColor = ''
		return indent1 .. str:gsub("(%s+)()(%S+)()",
							function(sp, st, word, fi)
								local delta = 0
								here = here + delta
								if fi-here > limit then
									here = st - #indent + delta
									return "\n" .. word
								end
							end)
	end

	function onHelp(name, line, wildcards)
		local str = wildcards[1]
		local helpFiles = {"win", "fontsize", "linespace", "speed", "vidblain", "mark", "index areas", "silent", "sort", "xm", "xmap", "roomnote", "qw", "ht", "ah", "ak|kk|qk", "qs", "xq", "noexp", "kw|keyword", "nx", "go", "autocon", "sound", "xrt|xrun", "cp|gq", "xcp", "xcp mode", "ms|msearch", "mgo|mgoto", "snd migrate|mergePwar", "snd update", "snd reload", "summary"}

		local headers = {"cyan", "", string.rep("-", 76) .. "\n", "darkcyan", "", "Help keywords", "antiquewhite", "", " : " .. str .. "\n", "cyan", "", string.rep("-", 76) .. "\n"}

		ColourNote(unpack(headers))

		if str == "" or "" == nil or str == "xhelp" then
			ColourNote("darkcyan", "", "Plugin name    ", "antiquewhite", "", " : Search & Destroy")
			ColourNote("darkcyan", "", "Maintained by  ", "antiquewhite", "", " : Crowley")
			ColourNote("darkcyan", "", "Original Author", "antiquewhite", "", " : WinkleWinkle")
			ColourNote("darkcyan", "", "Credit to      ", "antiquewhite", "", " : Nokfah and Starling")
			Note()
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xhelp <command> (to view helpfiles below)")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Search & Destroy is a quality-of-life tool. It utilizes the mapper plugin in order to get to your quest mobs faster, your campaign targets faster, and yes, even global quest mobs. It makes every attempt to load up the keyword into an alias so all you have to do is type the alias and enter. It presents a window that displays your campaign or global targets (and eventually will show quest targets, perhaps tabbed). It uses its own runto feature in order to run to your personally chosen 'start' room of the area. To clarify, there are no 'start' rooms to any area. It's why the mapper plugin cannot just run you to an area because you tell it to.")}))
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("In short, it can speed up your quests/campaigns/global quests. It is NOT, however, a bot as some may claim.")}))
			Note()
			ColourNote("antiquewhite", "", "To get started, view the help files below:")
			Note()
			ColourNote("limegreen", "", unpack({helpWrap(table.concat(helpFiles, ", "))}))

		elseif str == "win" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset win <on|off|show|hide>")
			ColourNote("antiquewhite", "", "        xset winreset")
			Note()
			ColourNote("limegreen", "", "xset win:")
			ColourNote("antiquewhite", "", unpack({helpWrap("This command toggles the Search & Destroy miniwindow. Use 'on' or 'show' to show the window, and use 'off' or 'hide' to close the window.")}))
			Note()
			ColourNote("limegreen", "", "xset winreset:")
			ColourNote("antiquewhite", "", unpack({helpWrap("If, for any reason, the window goes missing and the previous command does not restore it, this command will reset the window to a default location on top of your windows.")}))

		elseif str == "fontsize" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset fontsize <#>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Without an argument, it will display the current font size the miniwindow is using. With an argument, it will change the font size to the parameter.")}))

		elseif str == "linespace" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset linespace <#>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Without an argument, it will display the current line spacing size the miniwindow is using. With an argument, it will change the line spacing size to the parameter.")}))

		elseif str == "speed" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset speed <walk|run>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Without an argument, it will display the current movement speed the mapper is using. With an argument, it will change the map speed to walk (without using portals) or run (using portals).")}))

		elseif str == "vidblain" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset vidblain")
			ColourNote("antiquewhite", "", "        xset vidblain level <#>")
			Note()
			ColourNote("limegreen", "", "xset vidblain:")
			ColourNote("antiquewhite", "", unpack({helpWrap("This will toggle a fix that allows you to run to areas within Vidblain. This was necessary because of the random drop locations when you runto Vidblain without a portal. See the next command if you have a portal to an area within Vidblain.")}))
			Note()
			ColourNote("limegreen", "", "xset vidblain level <#>:")
			ColourNote("antiquewhite", "", unpack({helpWrap("This command is used to display or set the lowest level portal you have to an area in Vidblain. For example, if you have a level 1 portal to Sendhia, you would simply type 'xset vidblain level 1'. ")}))

		elseif str == "mark" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset mark")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("This command will set your current room as the designated 'start' room of the area.")}))

		elseif str == "index areas" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset index areas")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Occasionally, SnD does not realize you've mapped an area for whatever reason. This becomes apparent when you see a lot of red links on your campaign or global quest check list. When this happen, this command SHOULD fix it, but again, only if you've mapped the areas linked in red. If it does not, something else is amiss, and you should probably note Crowley about it.")}))

		elseif str == "silent" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset silent <on|off>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("This command will turn the display of campaign or global quest targets in the main window on or off. Soneone once mentioned it was redudant to have it in both the miniwindow and the main window, so for the sake of spamreduce, this was included.")}))

		elseif str == "sort" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset sort <all|area|room|none>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Sorts out campaign lists by rooms, by areas, both, or default sort. May or may not be bugged.")}))

		elseif str == "rlh" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xm <room name>")
			ColourNote("antiquewhite", "", "        xmall <room name>")
			ColourNote("antiquewhite", "", "        xm rlh <#>")
			Note()
			ColourNote("limegreen", "", "xm <room name>:")
			ColourNote("antiquewhite", "", unpack({helpWrap("Searches for the supplied room name within the area. It can match partial room names. To get a list of all rooms in the current area, use '%' as the room name.")}))
			Note()
			ColourNote("limegreen", "", "xmall <room name>:")
			ColourNote("antiquewhite", "", unpack({helpWrap("As with above, searches for the supplied room name, but across all zones. It can match partial room names. Would not suggest using '%' here as it will display every room you have mapped in Aardwolf.")}))
			Note()
			ColourNote("limegreen", "", "xm rlh <#>:")
			ColourNote("antiquewhite", "", unpack({helpWrap("Without an argument, displays rooms that link to the current room. With an argument, displays rooms that link to your chosen room ID. This will display room ID, room name, and room zone name that links to the room.")}))

		elseif str == "xmap" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xmap move <roomID> <walk|run>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Moves between rooms at default speed (see 'help xset speed') without argument, or, with argument, walks (without portals) or runs (with portals) to the supplied room ID.")}))

		elseif str == "roomnote" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": roomnote <area|area areakey>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Displays roomnotes for the current room, current area, or for the supplied area keyword.")}))

		elseif str == "qw" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": qw<x> <mobname>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Uses the 'where' command on the stored mobname based on quest, campaign, or global quest target. If an argument is supplied, it will 'where' the argument. Use 'x' if you want an exact match on mob name.")}))

		elseif str == "ht" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": ht <mob|stop>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Executes the 'hunt trick' for the current campaign target or supplied argument. Use 'stop' to stop the hunt trick, which will work in most cases but may fail if a mob has a keyword of 'stop'.")}))

		elseif str == "ah" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": ah<a> <mobname>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Automatically sends the 'hunt' command and executes the direction hunt leads you. Append 'a' in order to abort autohunting. This is useful for tracking quest mobs through mazes, or if you really want to, hunting players. However, you must have hunt practiced for it to work.")}))

		elseif str == "ak" or str == "kk" or str == "qk" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": <xset> <ak|kk|qk> <commands>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("With the 'xset' argument, sets the interchangable command of 'ak', 'kk', and 'qk' to the command supplied. Without the 'xset' argument, executes the 'quick kill' command. If you wish to stack multiple commands, you must separate each command with a double semicolon (or a single semicolon if you start the line with a semicolon). For example, 'xset kick;;bash;;slap' (or ';xset kick;bash;slap')  will kick the target, then bash the target, then slap the target.")}))

		elseif str == "qs" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": qs")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Executes a scan for the current quest, campaign, or global quest target.")}))

		elseif str == "xq" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xq")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Reloads and displays your current quest information.")}))

		elseif str == "nx" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": nx<->")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Moves to the next room in the list, or with '-', the previous room.")}))

		elseif str == "go" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": go <index #>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Moves to the first room in the index, or with a supplied argument to the index number supplied.")}))

		elseif str == "xrt" or str == "xrun" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": <xrt|xrun> <area keyword>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Executes a run to the supplied area keyword. If a room has been marked (help 'xset mark') as the start room of the area, it will run there instead.")}))

		elseif str == "noexp" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset noexp <off|#>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Without an argument, it will display the current setting. With an argument, it will turn off monitoring for noexp or set a threshhold for turning on noexp. This feature is to keep you from accidentally leveling while you're campaign leveling.")}))

		elseif str == "cp" or str == "gq" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": <cp|gq> <i|info|c|check>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Displays information/check for campaigns and global quests. With the 'i' or 'info' argument, it will load the list of mobs in the miniwindow.")}))

		elseif str == "xcp" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xcp <index>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Without an argument, this command will search for the first mob listed in the miniwindow. Otherwise, it will search for the mob based on the supplied index number.")}))

		elseif str == "xcp mode" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xcp mode <ht|qw|off>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Without an argument, displays your current default action to take when searching for a mob using 'xcp' (see 'help xcp'). With an argument, sets your default action to 'ht' (hunt trick, 'help ht'), 'qw' (quick where, 'help qw'), or 'off' (no action taken).")}))

		elseif str == "snd update" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": snd update")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Whenever Crowley announces a new version, this command will make it easy to update the Search & Destroy plugin.")}))

		elseif str == "ms" or str == "msearch" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": <ms|msearch> <here|area> <mob name>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("This command will search the mob database for the mob name supplied based on the area supplied (here, [area key], defaults to 'all' with no argument), returning the rooms the mob has been found, the area, and the times it has been found in that room.")}))

		elseif str == "mgo" or str == "mgoto" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": mgo<to> <idx>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("This command is used after searching for a mob and will go to the room provided by the index number.")}))

		elseif str == "snd reload" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": snd reload")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("If, for any reason, Search & Destroy stops functioning correctly, this theoretically should fix it. In some cases, it may be necessary to open up your plugins (Ctrl+Shift+P) and reinstall Search & Destroy.")}))

		elseif str == "snd migrate" or str == "mergePwar" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": snd migrate")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("This command is for previous users of Pwar's Search & Destroy. In an effort to not lose a previously built mob database, this command will migrate all data to this version of SnD.")}))
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("This will only work if the file name has not been altered from 'WinkleGold_Database.db' and that the file is located in the default plugin directory. If you have moved it or renamed it, please make sure it is located in the 'plugins' folder with the name 'WinkleGold_Database.db' and run this command again. Thank you.")}))

		elseif str == "kw" or str == 'keyword' then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset kw <mob keyword>")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("This command will change a mob's keyword so that it is properly targeted. For example, say you have a campaign target of 'a yummy beef pot pie.' By default, S&D might target 'yummy pie' which doesn't actually match. Instead, you'll want it to target 'beef pie.'")}))
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("To do so, you can use 'xset kw beef pie' while it is a campaign, quest, or gquest target. Alternatively, you can use 'xset kw' with no arguments and follow the dialogs that appear.")}))

		elseif str == "autocon" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset autocon")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Toggle auto consider. When enabled, it will automatically perform a consider upon arrival at a room reached with 'nx' or 'go.' All mobs found will be added to the mobs database. If the target mob is not here it will then perform a scan.")}))
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("If disabled, it will perform a scan upon arrival and add the mobs found in this room to the mobs database. Unlike consider, scan will have no delay, but it will miss any mobs that are flagged noscan.")}))

		elseif str == "sound" then
			ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset sound")
			Note()
			ColourNote("antiquewhite", "", unpack({helpWrap("Toggles sounds. Currently this is only used to signify that a target is in a nearby room as determined by scan, or that one of the targets on your campaign/gquest, but not your current target, is in the same room as you. For full functionality, the soundpack plugin is expected to be enabled.")}))

		elseif str == "summary" then
		ColourNote("yellow", "", "Commands:")
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset win <on|off>: Shows your hides the window.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset winreset: Resets the window.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset fontsize <#>: Displays current font size or changes it to argument.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset linespace <#>: Displays line spacing size or changes it to argument.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset speed <walk|run>: Displays current move speed, or changes it to argument.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset vidblain:  Fixes Vidblain's 'random drop' so you can still run to areas within Vidblain.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset mark:  Sets current room as 'start' for the current area.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset index areas:  Indexes areas. Use this if you get a lot of 'red' links but you've mapped the area.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset silent <on|off>:  Toggles displaying target list in main MUD window.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset sort <all|area|room|none>: Toggles sorting by area name in area cps/gqs, room cps/gqs, none, or both.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xm rlh <roomID>:  Displays rooms linking to <roomID> or current room.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xmall <room name>:  Displays rooms across the MUD matching the argument.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xm <room name>:  Displays rooms in zone matching the argument.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xmap move <roomID> <run|walk>:  Move to the room id at default speed, or walks (without portals) or runs (with portals) based on argument.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("roomnote <area|area areakey>:  Displays roomnotes for current room, current area, or area argument.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("qw<x> <mobname>:  Where's the current stored target or argument. Use 'x' to where exact mob name.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("ht <mob|stop>:  Executes the 'hunt trick' for current target or argument. Use 'stop' to abort.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("ah<a> <targ>:  Autohunts target. Append 'a' with no target to abort.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset <ak|kk|qk>:  Sets the 'quick kill' command. All options are interchangeable.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("<ak|kk|qk>:  Executes the 'quick kill' command. All options are interchangeable.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("qs:  Executes a 'quick scan' for the stored target.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xq:  Reloads the quest info.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset noexp <off|#>:  Displays current setting with no argument. With argument, toggles noexp off or sets it to turn on at # exp remaining.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset kw <mob keyword>:  Set the keyword(s) that will be used to target a particular mob.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("nx<->:  Moves to the next room on the list, or the previous room with -.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("go <index>:  Runs to the first room in the index, or to the index number with argument.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset autocon:  Toggle automatically considering the room you reach via 'nx' or 'go,' and then adding the mobs found to the mobs database.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xset sound:  Toggles sounds.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("<xrt|xrun> <area>:  Runs to the area matching the argument.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("<cp|gq> i|info:  Displays campaign/gquest info.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("<cp|gq> ch|check:  Displays campaign/gquest check.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xcp <index>:  Without argument, goes to top result in cp/gq check. Otherwise heads to the index chosen.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("xcp mode <ht|qw|off>:  Sets whether you use hunt trick or quick where upon entering an area on cp/gq. Use 'off' to turn off this feature.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("snd update:  Automatically updates Search & Destroy.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("ms<earch> <area|here|all> <mob>: Searches for mobs in the mob database.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("mgo<to> <idx>: After searching for mobs, goes to the index chosen.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("snd reload: Reloads the plugin if it errors out.")}))
		Note()
		ColourNote("antiquewhite", "", unpack({helpWrap("snd migrate: If you used Pwar's plugin and have a database, this will migrate it over to this version so you do not lose your hard earned data.")}))

		else
			ColourNote("antiquewhite", "", "No help files found with your query. Please see the help files below:")
			Note()
			ColourNote("limegreen", "", unpack({helpWrap(table.concat(helpFiles, ", "))}))
		end
		ColourNote("cyan", "", string.rep("-", 76))
	end

	function sndReload()
		Execute(GetAlphaOption("script_prefix") .. "DoAfterSpecial(1, \"ReloadPlugin('" .. GetPluginID() .. "')\", sendto.script)")
	end

	function copyPwarWarn()
		ColourNote("cyan", "", "Are you sure you want to do this? It will wipe out your existing mob and keyword data. Type ",
			"lime", "", "snd migrate confirm",
			"cyan", "", " to migrate data from your pwar database.")
	end

	function copyPwarDB()
		local success, err = pcall(rawCopyPwarDB)

		if success then
			ColourNote("cyan", "", "Finished migrating! You can now resume play!")
		else
			ColourNote("tomato", "", err)
		end
	end

	function rawCopyPwarDB()
		local f = io.open(GetInfo(60) .. "WinkleGold_Database.db", "r")

		if not f then
			error("To start migration process, please locate the file 'WinkleGold_Database.db' and move it to the plugins folder. Then try again.")
		else
			ColourNote("cyan", "", "Now rebuilding the database with data from Pwar's Search & Destroy.")

			os.remove(snd_db_file)
			migrate_database()

			f:close()

			local PwarDb = assert(sqlite3.open(GetInfo(60) .. "/WinkleGold_Database.db"))
			local mapperDb = assert(sqlite3.open(GetInfo(66) .. "Aardwolf.db"))
			local SnDdb = assert(sqlite3.open(GetInfo(66) .. "/SnDdb.db"))
			local roomsById = {}
			local roomsToLookup = {}
			local migrateTable = {}
			local insertStatements = {}
			local batch_size = 10000
			local err

			local mobQuery = "SELECT roomid, mobname, sum(freq) as count FROM mobs GROUP BY roomid, mobname"

			for row in PwarDb:nrows(mobQuery) do
				table.insert(roomsToLookup, row.roomid)
				table.insert(migrateTable, {roomid =  row.roomid,  mob = row.mobname, count = row.count})
			end

			roomQuery = string.format("SELECT uid, area, name FROM rooms WHERE uid IN (%s)", table.concat(roomsToLookup, ","))

			for row in mapperDb:nrows(roomQuery) do
				roomsById[tostring(row.uid)] = {area = row.area, name = row.name}
			end
			mapperDb:close()

			for i, mob in ipairs(migrateTable) do
				room = roomsById[tostring(mob.roomid)]
				if room then
					table.insert(insertStatements, string.format("INSERT INTO mobs (mob,room,roomid,zone,count) VALUES (%s,%s,%s,%s,%i);", fixsql(mob.mob), fixsql(room.name), mob.roomid, fixsql(room.area), mob.count))

					if #insertStatements > batch_size then
						execute_in_transaction(SnDdb, insertStatements)
						if SnDdb:errcode() > 0 then
							err = SnDdb:error_message()
							SnDdb:close()
							PwarDb:close()
							error("Encountered an error during migration: " .. err)
						end
						insertStatements = {}
					end
				end
			end

			local keyQuery = "SELECT mobname, areaid, subname FROM mobsubs"

			for row in PwarDb:nrows(keyQuery) do
				table.insert(insertStatements, string.format("INSERT OR REPLACE INTO mob_keyword_exceptions (area_name,mob_name,keyword) VALUES (%s,%s,%s);", fixsql(row.areaid), fixsql(row.mobname), fixsql(row.subname)))
				if #insertStatements > batch_size then
					execute_in_transaction(SnDdb, insertStatements)
					if SnDdb:errcode() > 0 then
						err = SnDdb:error_message()
						SnDdb:close()
						PwarDb:close()
						error("Encountered an error during migration: " .. err)
					end

					insertStatements = {}
				end
			end

			PwarDb:close()

			execute_in_transaction(SnDdb, insertStatements)
			if SnDdb:errcode() > 0 then
				err = SnDdb:error_message()
				SnDdb:close()
				error("Encountered an error during migration: " .. err)
			end

			SnDdb:close()
		end
	end

	function mobLookup (name, location, level, exact)
		SnDdb = sqlite3.open(snd_db_file)

		if exact ~= "" or exact ~= nil then exact = false end

		local locFound, locQuery, searchQuery, lvlQuery, searchMsg = false, "SELECT * FROM area WHERE key LIKE '%s'", "", " AND area.minlvl <= %s AND area.maxlvl >= %s", "Search for " .. name .. " in  " .. location

		if location ~= "" or location ~= nil then
			if location:upper() == "HERE" then
				location = gmcp("room.info.zone")
			elseif location:upper() == "ALL" then
				location = "%"
			end

			locQuery = locQuery:format(fixSQL(location))

			for a in SnDdb:rows(locQuery) do
				if a[1] then
					locFound = true
				end
			end
		end

		if locFound then
			if exact then
				searchQuery = "SELECT * FROM mobs, area WHERE zone LIKE '" .. fixSQL(location)  .. "' AND mob LIKE '" .. fixSQL(name) .. "'"
			else
				searchQuery = "SELECT * FROM mobs, area WHERE zone LIKE '" .. fixSQL(location) .. "' AND mob LIKE '%" .. fixSQL(name) .. "%'"
			end
		else
			if exact then
				searchQuery = "SELECT * FROM mobs, area WHERE mobs.mob LIKE '" .. fixSQL(name) .. "' AND mobs.room LIKE '" .. fixSQL(location) .. "' AND area.key = mobs.zone"
			else
				searchQuery = "SELECT * FROM mobs, area WHERE mobs.mob LIKE '%" .. fixSQL(name) .. "%' AND mobs.room LIKE '%" .. fixSQL(location) .. "%' AND area.key = mobs.zone"
			end
		end

		if tonumber(level) then
			searchQuery = searchQuery .. lvlQuery:format(level, level)
		end

		searchQuery = searchQuery .. " and area.noquest LIKE 'false' and mobs.zone = area.key ORDER BY mobs.zone, mobs.Count DESC"

		SnDdb:close()

		showResults(searchQuery, searchMsg)
	end

	function showResults(query, msg)

		SnDdb = sqlite3.open(snd_db_file)
		mshow = {}
		local searchMsg, failure = msg, "No matches found!"

		local dividers = "+" .. string.rep("-", 30) .. "+" .. string.rep("-", 25) .. "+" .. string.rep("-", 13) .. "+" .. string.rep("-", 12) .. "+" .. string.rep("-", 7) .. "+"

		ColourNote("orange", "", searchMsg .. " ...")
		ColourNote("dimgray", "", dividers)
		ColourNote("dimgray", "", "| ", "white", "", "Mob name" .. string.rep(" ", 28-#"Mob name"), "dimgray", "", " | ", "green", "", "Room name" .. string.rep(" ", 23-#"Room name"), "dimgray", "", " | ", "cyan", "", "ID" .. string.rep(" ", 11-#"ID"), "dimgray", "", " | ", "yellow", "", "Zone" .. string.rep(" ", 10-#"Zone"), "dimgray", "", " | ", "white", "", "Count ", "dimgray", "", "|"  )

		ColourNote("dimgray", "", dividers)

		local count = 0

		for a in SnDdb:rows(query) do
			count = count + 1
			if #a > 0 then
				mName, rName, rID, zName, mobCount = count .. ". " .. a[1], a[2], tostring(a[3]), a[4], a[5]
				if #mName > 28 then
					mName = string.sub(mName, 1, 28)
				end

				if #rName > 23 then
					rName = string.sub(rName, 1, 23)
				end

				ridStr = count .. ". " .. rID

				bgColor = "black"

				if count%2 == 0 then
					bgColor = "midnightblue"
				end

				table.insert(mshow, {a[1], zName, rID})

				ColourTell("dimgray", "", "|", "white", bgColor, " " .. string.format("%-29s",mName), "dimgray", "", "|", "limegreen", bgColor, " " .. string.format("%-24s", rName), "dimgray", "", "|", "cyan", bgColor, " " .. count .. ". ")
				Hyperlink("mapper goto " .. rID, rID, "goto id", "cyan", bgColor, 0)
				ColourTell("", bgColor,  string.rep(" ", 12-#ridStr),"dimgray", "", "|", "yellow", bgColor, " " .. string.format("%-11s", zName), "dimgray", "", "|", "white", bgColor, " " .. string.format("%-5d", mobCount), "dimgray", bgColor, " |\n")

			end
		end

		if count == 0 then
			ColourNote("dimgray", "", "| ", "tomato", "", string.format("%-89s", failure), "dimgray", "", " |")
		end

		ColourNote("dimgray", "", dividers)

		if count > 0 and count < 2 then
			ColourNote("orange", "", count .. " match found")
		elseif count > 1 then
			ColourNote("orange", "", count .. " matches found")
		end

		SnDdb:close()
		SnDdb = nil
	end

	function mobShow(name, line, args)
		if #mshow ~= 0 then
			mob, zone, room, rid = mshow[tonumber(args[1])][1], mshow[tonumber(args[1])][2], mshow[tonumber(args[1])][3], mshow[tonumber(args[1])][4]
			Execute(args[2] .. " " .. string.format(showStr, mob, zone, room, rid))
		else
			ColourNote("orange", "", "No results loaded. Try searching for your mob first.")
		end
	end

	function mobGo(name, line, args)
		if #mshow ~= 0 then
			Execute("mapper goto " .. mshow[tonumber(args[1])][3])
		else
			ColourNote("orange", "", "No results loaded. Try searching for your mob first.")
		end
	end

	function fixSQL (str)
		return str:gsub("'", "''")
	end

	function onSearch(name, line, wildcards)
		local param1, param2, param3 = wildcards[1], wildcards[2], (tonumber(wildcards[3]) and tonumber(wildcards[3])) or nil

		if string.upper(param1) == "HELP" then
			onHelp()
		else
			local zone, name, sendit = param1, param2, false

			if #name < 1 then
				name = zone
				zone = "all"
				sendit = true
			 elseif #name >= 1 and #name < 2 then
				ColourNote("#802800", "", "*** You need at least 2 characters of the mob name!")
			else
				sendit = true
			end

			if sendit then
				if param3 then
					mobLookup(name, zone, param3)
				else
					mobLookup(name, zone)
				end
			else
				ColourNote("#802800", "", "*** Syntax error! Use: ", "green", "", "msearch <areakey|here|all> <mob>")
			end
		end
	end

	function strip_colours (s)
		s = s:gsub("@@", "\0")  -- change @@ to 0x00
		s = s:gsub("@%-", "~")    -- fix tildes (historical)
		s = s:gsub("@x%d?%d?%d?", "") -- strip valid and invalid xterm color codes
		s = s:gsub("@.([^@]*)", "%1") -- strip normal color codes and hidden garbage
		return (s:gsub("%z", "@")) -- put @ back (has parentheses on purpose)
	end

	function xset_autocon()
		if xset_autocon_onoff == "on" then
			xset_autocon_onoff = "off"
		else
			xset_autocon_onoff = "on"
		end
		SetVariable("mcvar_xset_autocon_onoff", xset_autocon_onoff)

		ColourNote("#FF5000", "", "\nAutocon is now ",
			"#00C040", "", string.upper(xset_autocon_onoff))
	end

	function is_autocon_enabled()
		return xset_autocon_onoff == "on"
	end

	function consider_trigger(name, line, wildcards, style)
		local con_details = {
			a = { level_range="-20 and below", 		colour="cornflowerblue", },
			b = { level_range="-10 to -19", 		colour="deepskyblue", },
			c = { level_range="-5 to -9", 			colour="turquoise", },
			d = { level_range="-2 to -4", 			colour="mediumspringgreen", },
			e = { level_range="-1 to +1", 			colour="lime", },
			f = { level_range="+2 to +4", 			colour="lawngreen", },
			g = { level_range="+5 to +9", 			colour="limegreen", },
			h = { level_range="+10 to +15", 		colour="greenyellow", },
			i = { level_range="+16 to +20", 		colour="#EFF22D", },
			j = { level_range="+21 to +30", 		colour="gold", },
			k = { level_range="+31 to +40", 		colour="darkorange", },
			l = { level_range="+41 to +50", 		colour="orangered", },
			m = { level_range="+51 and above", 		colour="red", },
		}

		local details = con_details[name]
		local on_target_list = false
		local mob_name = wildcards.mob_name
		local lower_mob_name = mob_name:lower()
		local tags = mob_activity_tags(mob_name, true)

		EnableTrigger("consider_end", true)
		table.insert(mobs_here, lower_mob_name)

		for i, tag in ipairs(tags) do
			ColourTell(tag.colour, "", tag.text)
		end

		for i, s in ipairs(style) do
			if string.match(s.text, "^%s*%(.+%)%s*$") then
				ColourTell(RGBColourToName(s.textcolour), RGBColourToName(s.backcolour), s.text)
			else
				break
			end
		end

		ColourNote("silver", "", mob_name, details.colour, "", string.format(" (%s)", details.level_range))
	end

	function consider_shopkeeper()
		EnableTrigger("consider_end", true)
	end

	function consider_end()
		EnableTriggerGroup("consider_end", false)

		if #mobs_here > 0 then
			write_current_room_mob_list()
		else
			DebugNote("No mobs found to update the mobs database")
		end

		-- Don't play sound when a quest target is here, assume soundpack will already play a sound
		if not quest_target_here then
			if activity_target_found_here then
				-- The current target is found in the room, play a sound
				play_target_found_sound()
			else
				-- A non-active target on the campaign/gquest list is found in the current room, play a sound
				if other_target_found_here then
					play_other_target_here_sound()
				end

				if consider_destination_room then
					scan_after_con = true
					SendNoEcho("scan")
				end
			end
		end

		activity_target_found_here = false
		quest_target_found_here = false
		other_target_found_here = false
	end

	function play_target_found_sound()
		DebugNote("Play target found here sound")
		if is_sound_enabled() and IsPluginInstalled(plugin_id_soundpack) and GetPluginInfo(plugin_id_soundpack, 17) then
			CallPlugin(plugin_id_soundpack, "TriggerEvent", "quest_target_found")
		end
	end

	function play_target_nearby_sound()
		DebugNote("Play target found nearby sound")
		if is_sound_enabled() then
			PlaySound(0, GetInfo(74) .. target_nearby_sound, false, 100, 0)
		end
	end

	function play_other_target_here_sound()
		DebugNote("Play other target here sound")
		if is_sound_enabled() then
			PlaySound(0, GetInfo(74) .. other_target_here_sound, false, 100, 0)
		end
	end

	function scan_start()
		EnableTriggerGroup("scan", true)
	end

	function scan_end()
		EnableTriggerGroup("scan", false)
		write_current_room_mob_list()
		if activity_target_found_here then
			play_target_found_sound()
		else
			if target_found_nearby then
				play_target_nearby_sound()
			end

			-- A non-active target on the campaign/gquest list is found in the current room, play a sound
			-- but only if we didn't already see this mob with con
			if other_target_found_here and not scan_after_con then
				play_other_target_here_sound()
			end
		end
		scanning_current_room = false
		scan_after_con = false
		activity_target_found_here = false
		quest_target_found_here = false
		target_found_nearby = false
		other_target_found_here = false
	end

	function scan_location_current_room()
		scanning_current_room = true
		mobs_here = {}
	end

	function scan_location_nearby_room()
		scanning_current_room = false
	end

	function scan_mob(name, line, wildcards, style)
		local padding = 5
		if not string.find(wildcards.flags, "(Player)") then
			local mob_name = wildcards.mob_name
			local tags = mob_activity_tags(mob_name, scanning_current_room)

			if scanning_current_room and not scan_after_con then
				table.insert(mobs_here, mob_name:lower())
			end

			for i, tag in ipairs(tags) do
				ColourTell(tag.colour, "", tag.text)
				padding = padding - #tag.text
			end
		end

		for i, s in ipairs(style) do
			if i == 1 then
				local text = string.gsub(s.text, "^     ", string.rep(" ", padding))
				ColourTell(RGBColourToName(s.textcolour), RGBColourToName(s.backcolour), text)
			else
				ColourTell(RGBColourToName(s.textcolour), RGBColourToName(s.backcolour), s.text)
			end
		end
	end

	function mob_activity_tags(mob_name, checking_current_room)
		local on_target_list = false
		local lower_mob_name = mob_name:lower()
		local result = {}

		for i, target in ipairs(main_target_list) do
			if current_room.arid == target.arid and target.mob:lower() == lower_mob_name then
				on_target_list = true
				break
			end
		end

		if on_target_list then
			if checking_current_room then
				if type(full_mob_name) == 'string' and full_mob_name:lower() == lower_mob_name then
					activity_target_found_here = true
				else
					other_target_found_here = true
				end
			else
				target_found_nearby = true
			end
			table.insert(result, { text = "[", colour = "gold" })
			table.insert(result, { text = current_activity:upper(), colour = "magenta" })
			table.insert(result, { text = "] ", colour = "gold" })
		end

		if quest_target.mob and quest_target.mob:lower() == lower_mob_name and quest_target.arid == current_room.arid then
			if checking_current_room then
				quest_target_found_here = true
			else
				target_found_nearby = true
			end
			table.insert(result, { text = "[", colour = "gold" })
			table.insert(result, { text = "Q", colour = "magenta" })
			table.insert(result, { text = "] ", colour = "gold" })
		end

		return result
	end

	function write_current_room_mob_list()
		if #mobs_here < 1 then
			DebugNote("No mobs to be written to the database")
			return
		end

		local rname = strip_colours(gmcp("room.info.name"))
		local zname = gmcp("room.info.zone")
		local writes = {}
		local sql_mobs = {}
		for i, mob in ipairs(mobs_here) do
			table.insert(sql_mobs, fixsql(mob))
			table.insert(writes, string.format("INSERT OR IGNORE INTO mobs (mob,room,roomid,zone) VALUES (%s,%s,%i,%s);",
				fixsql(mob), fixsql(rname), tonumber(current_room.rmid), fixsql(zname)))
			table.insert(writes, string.format("UPDATE mobs SET Count = Count + 1 WHERE mob = %s AND roomid = %i;", fixsql(mob), tonumber(current_room.rmid)))
		end

		local db = assert(sqlite3.open(snd_db_file))

		execute_in_transaction(db, writes)

		if debug_mode then
			if db:errcode() > 0 then
				ColourNote("tomato", "", "Db error: " .. db:error_message())
			else
				DebugNote(string.format("Successfully inserted or updated %i in the mobs database", #mobs_here))
			end
		end
		db:close_vm()
		mobs_here = {}
	end

	function xset_sound()
		if xset_sound_onoff == "on" then
			xset_sound_onoff = "off"
		else
			move_sounds()
			local f1 = io.open(GetInfo(74) .. target_nearby_sound)
			local f2 = io.open(GetInfo(74) .. other_target_here_sound)
			local sounds_found = f1 and f2
			f1:close()
			f2:close()

			if not sounds_found then
				ColourNote("tomato", "", "Sound files could not be found. Extract them from Search&Destroy's zip file to the plugins folder and try again.")
				return
			end
			xset_sound_onoff = "on"
		end
		SetVariable("mcvar_xset_sound_onoff", xset_sound_onoff)

		ColourNote ("#FF5000", "", "\nSearch&Destroy Sounds are now ",
			"#00C040", "", string.upper(xset_sound_onoff))
	end

	function is_sound_enabled()
		return xset_sound_onoff == "on"
	end
]]>
</script>
<triggers>
<!-- Gquest operations -->
	<!-- group: trg_gq -->
	<trigger match="^Quest Name\.\.\.\.\.\.\.\.\.: \[ Global quest # (?<gq_id>\d{1,4}) \]$"
		script="gq_info_quest_name"
		name="trg_gq_info_quest_name" 		group="trg_gq"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_gq_info_quest_name", false) </send> </trigger>

	<trigger match="^Quest Status\.\.\.\.\.\.\.: \[ (?<status>\w+) \]$"
		script="gq_info_quest_status"
		name="trg_gq_info_quest_status" 	group="trg_gq"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_gq_info_quest_status", false) </send> </trigger>

	<trigger match="^Level range\.\.\.\.\.\.\.\.: \[\s+(?<minlvl>\d{1,3}) \] - \[\s+(?<maxlvl>\d{1,3}) \]$"
		script="gq_info_level_range"
		name="trg_gq_info_level_range" 		group="trg_gq"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_gq_info_level_range", false)
					EnableTrigger("trg_gq_info_target_header", true) </send> </trigger>

	<trigger match="^To complete this quest, you must:$"
		name="trg_gq_info_target_header" 	group="trg_gq"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_gq_info_target_header", false)
					EnableTrigger("trg_gq_info_line", true)
					EnableTrigger("trg_gq_info_end", true)
					EnableTriggerGroup("trg_gqmsg_2", true) </send> </trigger>

	<trigger match="^Kill at least (?<qty>[1-3]) \* (?<mob>\w[^(]+) \((?<loc>\S.+)\)\.$"
		script="gq_info_line"
		name="trg_gq_info_line" 			group="trg_gq"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^(?!Kill at least [1-3] \* \w[^(]+ \(\S.+\)\.)$"
		script="gq_info_end"
		name="trg_gq_info_end" 				group="trg_gq"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_gq_info_line", false)
					EnableTrigger("trg_gq_info_end", false) </send> </trigger>

	<trigger match="^You still have to kill (?<qty>[1-3]) \* (?<mob>\w[^(]+) \((?<loc>\S.+?)(?<isdead> - Dead)?\)$"
		script="gq_check_line"
		name="trg_gq_check_line" 			group="trg_gq"
		enabled="n"	regexp="y" sequence="500" keep_evaluating="y" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_gq_check_end", true) </send> </trigger>

	<trigger match="^(?!You still have to kill [1-3] \* \w[^(]+ \(\S.+?(?: - Dead)?\))$"
		script="gq_check_end"
		name="trg_gq_check_end" 			group="trg_gq"
		enabled="n"	regexp="y" sequence="500" keep_evaluating="y" omit_from_output="n" send_to="12" >
			<send>	EnableTrigger("trg_gq_check_line", false)
					EnableTrigger("trg_gq_check_end", false) </send> </trigger>

	<!-- group: trg_gqmsg_1 -->
	<trigger match="^Global Quest: Global quest # (?<gq_id>\d{1,4}) has been declared for levels (?<min_lvl>\d{1,3}) to (?<max_lvl>\d{1,3}) (?:- (?:200|10) or fewer wins only)?\.$"
		script="gqmsg_declared"
		name="trg_gqmsg_declared" 			group="trg_gqmsg_1"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^You have now joined Global Quest # (?<gq_id>\d{1,4})\. See 'help gquest' for available commands\.$"
		script="gqmsg_joined"
		name="trg_gqmsg_joined" 			group="trg_gqmsg_1"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest: Global quest # (?<gq_id>\d{1,4}) for levels (?<min_lvl>\d{1,3}) to (?<max_lvl>\d{1,3})(?: - (?:200|10) or fewer wins only)? has now started\.$"
		script="gqmsg_started"
		name="trg_gqmsg_started" 			group="trg_gqmsg_1"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<!-- group: trg_gqmsg_2 -->
	<trigger match="^You have finished this global quest\.$"
		script="player_not_on_gq"
		name="trg_gq_finished_extended" 	group="trg_gqmsg_2"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest: Global Quest # (?<gq_id>\d{1,4}) has been won by (?<winner>[A-Z][A-Za-z]+) - \d*(?:1st|2nd|3rd|\dth) win\.$"
		script="gqmsg_winner"
		name="trg_gqmsg_winner" 			group="trg_gqmsg_2"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest: Global Quest # (?<gq_id>\d{1,4}) will go into extended time for 5 more minutes\.$"
		script="gqmsg_extended_time"
		name="trg_gqmsg_extended_time" 		group="trg_gqmsg_ext"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest: Global quest # (?<gq_id>\d{1,4}) \(extended\) is now over\.$"
		script="player_not_on_gq"
		name="trg_gqmsg_extended_end" 		group="trg_gqmsg_2"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^You are no longer part of Global Quest # (?<gq_id>\d{1,4}) and will be unable to rejoin\.$"
		script="player_not_on_gq"
		name="trg_gqmsg_quit" 				group="trg_gqmsg_2"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Congratulations, that was one of the GLOBAL QUEST mobs\!$"
		script="gq_mob_killed"
		name="trg_gq_mob_killed" 			group="trg_gq_status"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^You are not in a global quest\.$"
		script="player_not_on_gq"
		name="trg_player_not_on_gq" 		group="trg_gq_status"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^There are no global quests running\.$"
		script="player_not_on_gq"
		name="trg_no_gqs_running" 			group="trg_gq_status"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest # (?<gq_id>\d{1,4}) has not yet started\.$"
		script="gq_check_not_yet_started"
		name="trg_gq_check_not_yet_started" group="trg_gq_status"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

<!-- CAMPAIGN OPERATIONS -->
	<trigger match="^Level Taken\.{8}: \[\s+(?<level>[1-2]?\d{1,2}) \]$"
		script="cp_info_level_taken"
		name="trg_cp_info_level_taken" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_info_level_taken", false) </send> </trigger>

	<trigger match="^The targets for this campaign are:$"
		script=""
		name="trg_cp_info_targets" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_info_targets", false)
					EnableTrigger("trg_cp_info_line", true)
					EnableTrigger("trg_cp_info_end", true) </send> </trigger>

	<trigger match="^Find and kill 1 \* (?<mob>\w[^(]+) \((?<loc>\S.+)\)$"
		script="cp_info_line"
		name="trg_cp_info_line" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^(?!Find and kill 1 \* \w[^(]+ \(\S.+\))$"
		script="cp_info_end"
		name="trg_cp_info_end" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_info_line", false)
					EnableTrigger("trg_cp_info_end", false) </send> </trigger>

	<trigger match="^You still have to kill \* (?<mob>\w[^(]+) \((?<loc>\S.+?)(?<isdead> - Dead)?\)$"
		script="cp_check_line"
		name="trg_cp_check_line" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_check_end", true)</send> </trigger>


	<trigger match="^(?!You still have to kill \* \w[^(]+ \(\S.+?(?: - Dead)?\))$"
		script="cp_check_end"
		name="trg_cp_check_end" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_check_gag_dead", true)
					EnableTrigger("trg_cp_check_line", false)
					EnableTrigger("trg_cp_check_end", false) </send> </trigger>

	<trigger match="^Note: Dead means that the target is dead, not that you have killed it\.$"
		name="trg_cp_check_gag_dead" group="trg_campaign"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_check_gag_dead", false) </send> </trigger>

<!-- CAMPAIGN STATUS TRACKING -->
	<trigger match="^Congratulations, that was one of your CAMPAIGN mobs\!$"
		script="cp_mob_killed"
		name="trg_cp_mob_killed" 	group="trg_cp_2"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^CONGRATULATIONS\! You have completed your campaign\.$"
		script="do_cp_complete"
		name="trg_cp_complete" 		group="trg_cp_2"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y"> </trigger>

	<trigger match="^Campaign cleared\.$"
		script="player_not_on_cp"
		name="trg_cp_quit" 			group="trg_cp_2"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^\w.+ tells you 'Good luck in your campaign\!'$"
		script="player_start_new_cp"
		name="trg_cp_request" 		group="trg_cp_2"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^You are not currently on a campaign\.$"
		script="player_not_on_cp"
		name="trg_player_not_on_cp" group="trg_cp_2"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^(?:(?:## )?You may now take another campaign\.|You may take (?:a campaign at this level|another campaign)\.)$"
		script="cp_check_can_get_new_cp"
		name="trg_can_get_new_cp" group="trg_cp_2"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^You (?:will have to level before you can go on another campaign|cannot take another campaign for (?:(?:\d+ hours?, )?\d+ minutes? and )?\d+ seconds?)\.$"
		name="trg_cannot_get_new_cp" group="trg_cp_2"
		script="cp_check_cannot_get_new_cp"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^You use a daily blessing campaign reset token to reset your campaign\.$"
		name="trg_cp_reset_token" group="trg_cp_2"
		script=""
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" omit_from_output="n" send_to="12" > </trigger>

<!-- Xcp next -->
	<trigger match="^Congratulations, that was one of your CAMPAIGN mobs\!$"
		name="trg_xcp_next_cp_mob_killed" group="trg_auto"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_xcp_next_cp", true) </send> </trigger>

	<trigger match="^Congratulations, that was one of the GLOBAL QUEST mobs\!$"
		name="trg_xcp_next_gq_mob_killed" group="trg_auto"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_xcp_next_gq", true) </send> </trigger>

<!-- QUICK WHERE -->
	<trigger match="^(?<mobname>\w.{29}) (?<roomname>[^ (0-9].*)$"
		script="qw_match"
		name="trg_quick_where_match" group="QuickWhere"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^There is no \w.+ around here\.$"
		script="qw_no_match"
		name="trg_quick_where_no_match" group="QuickWhere"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

<!-- HUNT TRICK -->
	<trigger match="^You are (?:almost )?certain that \w.+ is (?:north|south|east|west|up|down) from here\.|You are confident that \w.+ passed through here, heading (?:north|south|east|west|up|down)\.|The trail of \w.+ is confusing, but you're reasonably sure \w.+ headed (?:north|south|east|west|up|down)\.|There are traces of \w.+ having been here. Perhaps they lead (?:north|south|east|west|up|down)\?|You have no idea what you\'re doing\, but maybe \w.+ is (?:north|south|east|west|up|down)\?|You couldn\'t find a path to \w.+ from here\.|\w.+ is here\!$"
		script="ht_continue"
		name="trg_hunt_trick_continue_dir" group="HuntTrick"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You are (?:almost )?certain that \w.+ is through .+\.|You are confident that \w.+ passed through here, heading through .+\.|The trail of \w.+ is confusing, but you're reasonably sure \w.+ headed through .+\.|There are traces of \w.+ having been here\. Perhaps they lead through \w.+\?|You have no idea which way \w.+ went\.$"
		script="ht_continue"
		name="trg_hunt_trick_continue_portal" group="HuntTrick"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You seem unable to hunt that target for some reason\.$"
		script="ht_complete"
		name="trg_hunt_trick_complete" group="HuntTrick"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^\w.+ is here\!$"
		name="trg_hunt_trick_continue_2" group="HuntTrick"
		script="ht_continue"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^No one in this area by the name '\w.+'\.|Not while you are fighting\!|You can't hunt while (?:resting|sitting)\.|You dream about going on a nice hunting trip, with pony rides, and campfires too\.$"
		name="trg_hunt_trick_abort" group="HuntTrick"
		script="ht_abort"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

<!--  AUTO HUNT -->
	<trigger match="^You are (?:almost )?certain that (?<mob>\w.+) is (?<dir>north|south|east|west|up|down) from here\.$"
		script="auto_hunt_next"
		name="trg_autohunt_next_1" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You are confident that (?<mob>.+) passed through here\, heading (?<dir>north|south|east|west|up|down)\.$"
		script="auto_hunt_next"
		name="trg_autohunt_next_2" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^The trail of \w.+ is confusing, but you\'re reasonably sure .+ headed (?:north|south|east|west|up|down)\.|There are traces of \w.+ having been here\. Perhaps they lead (?:north|south|east|west|up|down)\?|You have no idea what you\'re doing, but maybe \w.+ is (?:north|south|east|west|up|down)\?$"
		script="auto_hunt_lowskill"
		name="trg_autohunt_lowskill" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You are (?:almost )?certain that \w.+ is through .+\.|You are confident that \w.+ passed through here, heading through .+\.|The trail of \w.+ is confusing, but you're reasonably sure \w.+ headed through .+\.|There are traces of \w.+ having been here\. Perhaps they lead through .+\?|You have no idea what you\'re doing\, but maybe \w.+ is through .+\?$"
		script="auto_hunt_portal"
		name="trg_autohunt_portal" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^No one in this area by the name '\w.+'\.|You couldn\'t find a path to \w.+ from here\.|No one in this area by that name\.|Not while you are fighting\!|You can't hunt while (?:resting|sitting)\.|You dream about going on a nice hunting trip, with pony rides, and campfires too\.$"
		script="auto_hunt_abort"
		name="trg_autohunt_abort" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^You seem unable to hunt that target for some reason\.$"
		script="auto_hunt_abort"
		name="trg_hunt_trick" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^\w.+ is here\!$"
		script="auto_hunt_complete"
		name="trg_autohunt_complete" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^Magical wards around \w.+ bounce you back\.$"
		name="trg_autohunt_nopass" group="AutoHunt"
		script="auto_hunt_door"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^The \w.+ is closed\.$"
		name="trg_autohunt_door" group="AutoHunt"
		script="auto_hunt_door"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You do not have a key for \w.+\.$"
		name="trg_autohunt_no_key" group="AutoHunt"
		script="auto_hunt_abort"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You open \w.+\.$"
		name="trg_autohunt_door_open" group="AutoHunt"
		script="auto_hunt_door_open"
		enabled="n" regexp="y" sequence="100" > </trigger>

	auto_hunt_door_open
<!-- AUTO SET NOEXP -->
	<trigger match="^You will no longer receive experience\. Happy questing\!$"
		script="anex_automatic_off"
		name="trg_anex_automatic_off"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^You will now receive experience\. Happy leveling\!$"
		script="anex_automatic_on"
		name="trg_anex_automatic_on"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^You (?:don't )?receive (\d+)(?:\+\d+)? experience points?\.$"
		script="anex_mobdeath_xp1"
		name="trg_anex_mobdeath_xp1"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^You raise a level\! You are now level \d+\.$"
		script="player_level_up"
		name="trg_player_level_up"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y"> </trigger>

<!-- AREA INDEX PROCESS -->
	<trigger match="^              \[ Listing all areas in range 1 to 300 \]$"
		script="area_index_start"
		name="trg_area_index_start" group="AreaIndex"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_gag_headers", true)
					EnableTrigger("trg_area_index_gag_header_lines", true)
					EnableTrigger("trg_area_index_line", true)
					EnableTrigger("trg_area_index_gag_lock_means", true)
					EnableTrigger("trg_area_index_end", true) </send> </trigger>

	<trigger match="^From To   Lock  Keyword          Area Name                      $"
		name="trg_area_index_gag_headers" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_gag_headers", false) </send> </trigger>

	<trigger match="^---- ---- ----  ---------------  ------------------------------$"
		name="trg_area_index_gag_header_lines" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_gag_header_lines", false) </send> </trigger>

	<trigger match="^\s+(?<min>\d+)\s+(?<max>\d+)\s+(?<lock>\d+)?\s+?(?<arid>[0-9a-z]+?)\s+(?<areaName>[A-Z].+?)$"
		script="area_index_line"
		name="trg_area_index_line" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^'Lock' means you cannot enter until you are that level or higher\.$"
		name="trg_area_index_gag_lock_means" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_gag_lock_means", false) </send> </trigger>

	<trigger match="^---------------------------------------------------------------$"
		script="area_index_end"
		name="trg_area_index_end" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_line", false)
					EnableTrigger("trg_area_index_end", false) </send> </trigger>

<!-- Consider -->
	<trigger match="^(?<flags>\(.*\) )?You would stomp (?<mob_name>.+?) into the ground\.$"
		script="consider_trigger"
		name="a"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?(?<mob_name>.+?) would be easy, but is it even worth the work out\?$"
		script="consider_trigger"
		name="b"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?No Problem! (?<mob_name>.+?) is weak compared to you\.$"
		script="consider_trigger"
		name="c"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?(?<mob_name>.+?) looks a little worried about the idea\.$"
		script="consider_trigger"
		name="d"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?(?<mob_name>.+?) should be a fair fight!$"
		script="consider_trigger"
		name="e"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?(?<mob_name>.+?) snickers nervously\.$"
		script="consider_trigger"
		name="f"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?(?<mob_name>.+?) chuckles at the thought of you fighting \S+\.$"
		script="consider_trigger"
		name="g"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?Best run away from (?<mob_name>.+?) while you can!$"
		script="consider_trigger"
		name="h"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?Challenging (?<mob_name>.+?) would be either very brave or very stupid\.$"
		script="consider_trigger"
		name="i"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?(?<mob_name>.+?) would crush you like a bug!$"
		script="consider_trigger"
		name="j"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?(?<mob_name>.+?) would dance on your grave!$"
		script="consider_trigger"
		name="k"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?(?<mob_name>.+?) says 'BEGONE FROM MY SIGHT unworthy\!'$"
		script="consider_trigger"
		name="l"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(?<flags>\(.*\) )?You would be completely annihilated by (?<mob_name>.+?)!$"
		script="consider_trigger"
		name="m"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^If you killed .+, who would serve .+ customers\?$"
		script="consider_shopkeeper"
		enabled="y" regexp="y" sequence="100" omit_from_output="n" send_to="12" > </trigger>

	<trigger match="^$"
		name="consider_end"
		group="consider_end"
		script="consider_end"
		enabled="n" regexp="y" sequence="100" omit_from_output="n" send_to="12" > </trigger>

	<trigger match="^(?:You see no one here but yourself!|Strange forces prevent violence here\.)$"
		name="consider_end_empty"
		group="consider_end"
		script="consider_end"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

<!-- Scan -->
	<trigger match="^Tag option scan turned ON$"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="{scan}"
		script="scan_start"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="{/scan}"
		script="scan_end"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^Right here you see:$"
		script="scan_location_current_room"
		group="scan"
		enabled="n" regexp="y" sequence="100" omit_from_output="n" send_to="12" > </trigger>

	<trigger match="^(\d )?(North|East|South|West) from here you see:$"
		script="scan_location_nearby_room"
		group="scan"
		enabled="n" regexp="y" sequence="100" omit_from_output="n" send_to="12" > </trigger>

	<trigger match="^ {5}-(?<flags> [\[\(].+[\]\)])? (?<mob_name>.+)$"
		script="scan_mob"
		group="scan"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

<!-- PAGE SIZE -->
	<trigger match="^You currently display ([0-9]+) lines per page\.|You do not page long messages\.$"
		script="capture_page_size"
		name="trg_capture_page_size"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" omit_from_output = "y" > </trigger>

	<trigger match="^Use 'pagesize \<lines\>' to change, or 'pagesize 0' to disable paging\.$"
		script=""
		name="trg_pagesize_gag_1"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" omit_from_output = "y" send_to="12" >
			<send>	EnableTrigger("trg_pagesize_gag_1", false) </send> </trigger>

<!-- Misc. gag triggers -->
	<trigger match="^Players found: \[\d+\], Max this reboot: \[\d+\], Connections this reboot: \[\d+\]$"
		name="trg_gag_who_footer_1"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" > </trigger>

	<trigger match="^Players invis: \[\d+\], Max on ever: \[\d+\]$"
		name="trg_gag_who_footer_2"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" > </trigger>

	<trigger match="^[\s\S]*$"
		name="trg_gag_everything"
		enabled="n" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="y" > </trigger>
</triggers>

<aliases>
<!-- Plugin Update automatic -->
	<alias enabled="y" match="snd update" script="update_plugin" sequence="100">
	</alias>
	<alias enabled="y" match="^xhelp(?:\s(.*))?$" regexp="y" script="onHelp" sequence="100">
	</alias>

	<alias enabled="y" match="^xset silent(?: (on|off))?" regexp="y" script="xset_silentMode" sequence="100">
	</alias>

	<alias enabled="y" match="xset sort(?: (all|room|area|none))?" regexp="y" script="xset_sortBy" sequence="100">
	</alias>
<!-- Auto-hunt commands-->
	<alias	match="^ah (?<arg>\w.+)$"
			script="auto_hunt"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:aha|ah0)$"
			script="auto_hunt_abort"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- campaign data input: cp info, check -->
	<alias	match="^cp (?:i|info)$"
			script="do_cp_info"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^cp (?:ch|check)$"
			script="do_cp_check"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- gquest data input: gq info, check -->
	<alias	match="^gq (?:i|info)$"
			script="do_gq_info"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" >
				<send>	EnableTriggerGroup("trg_gq", false) </send>	</alias>

	<alias	match="^(?:gq (?:c|ch|check)|gg|qq)$"
			script="do_gq_check"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- xcp commands  -->
	<alias	match="^xcp$"
			script="xcp_noarg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xcp (?<index>[0-9]+)$"
			script="xcp_arg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xcp mode(?: (?<option>ht|qw|off))?$"
			script="xcp_set_action_mode"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- movement: xrunto, go, nx, etc.  -->
	<alias	match="^(?:xrt|xrun|xrunto) (?<destination>.+)$"
			script="xrun_to"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:go|goto)( (?<index>[0-9]+))?$"
			script="goto_number"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" keep_evaluating="y" > </alias>

	<alias	match="^nx$"
			script="goto_next"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^nx-$"
			script="goto_previous"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Automatic noexp -->
	<alias	match="^xset noexp( (?<arg>off|[0-9]+))?$"
			script="xset_noexp_tnl"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Quest commands -->
	<alias	match="^(?:xq|xq1)$"
			script="xq_command"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Quick scan -->
	<alias	match="^qs$"
			script="quick_scan"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Quick-kill commands: qk, ak, kk, xset attack -->
	<alias	match="^(?:quick kill|ak|kk|qk)$"
			script="quick_kill"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset (?:kk|ak|qk|qkill)( (?<arg>.+))?$"
			script="xset_quick_kill_command"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Hunt trick -->
	<alias	match="^ht$"
			script="ht_noarg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^ht (?:(?<index>\d+)\.)?(?<mob>.+)?$"
			script="ht_arg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^ht(?:a|0| abort| stop)$"
			script="ht_abort"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Quick where -->
	<alias	match="^qw$"
			script="qw_noarg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^qw (?:(?<index>\d+)\.)?(?<mob>.+)?$"
			script="qw_arg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^qwx$"
			script="qw_exact"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- roomnotes -->
	<alias	match="^(?:roomnote|rn)$"
			script="room_note"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:roomnote|rn) a(?:rea)?(?: (?<arid>.+))?$"
			script="room_note_area"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Sql Execution -->
	<alias	match="^runsql (?<sql>.+)$"
			script="RunSql"
			enabled="y" regexp="y" sequence="1" ignore_case="y" send_to="12" > </alias>

	<alias	match="^execsql (?<sql>.+)$"
			script="ExecSql"
			enabled="y" regexp="y" sequence="1" ignore_case="y" send_to="12" > </alias>

<!-- xmapper  -->
	<alias	match="^(?:xmap|xmapper) move (?<roomid>\d+|-1)(?: (?<speed>run|walk))?$"
			script="xmapper_move"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xm(?:\ {(?<mob>[^\}]+)\})? (?<loc>.+)$"
			script="map_area"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xmall(?:\ {(?<mob>[^\}]+)\})? (?<loc>.+)$"
			script="map_area_all"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:xm|xmap|xmapper) rlh(?: (?<room_id>\d+))?$"
			script="xmap_rooms_linking_here"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- xset commands -->
	<alias  match="^xset (?:index areas|area index)$"
			script="area_index_process"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset (?:mark|start)$"
			script="xset_to_mark"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias  match="^xset vidblain$"
			script="xset_vidblain"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias  match="^xset vidblain level(?: (?<level>\d{1,3}))?$"
			script="xset_vidblain_setlevel"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias  match="^xset speed ?(?<speed>run|walk)?$"
			script="set_speed"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset sendecho$"
			script=""
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset kw$"
		script="set_mob_keyword"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset kw (?<keyword>.+)$"
		script="set_current_mob_keyword"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset autocon$"
		script="xset_autocon"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset sound$"
		script="xset_sound"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- xset window commands -->
	<alias	match="^xset fontsize( (?<size>[0-9]+))?$"
			script="xset_font_size"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset linespace( (?<space>[0-9]+))?$"
			script="xset_line_space"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset winreset$"
			script="xg_create_window"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" >
				<send>	win_init = false	</send> </alias>

	<alias	match="^xset (?:window|win) (?<onoff>on|off|show|hide|0|1|true|false)$"
			script="xset_ToggleWindowDisplay"
			enabled="y" regexp="y" sequence="100" > </alias>

	<alias	match="^(?:xw|xwh|xwhere)( (?<n1>\d+))?( (?<n2>\d+))?( (?<mob>.+))?$"
			script="do_xwhere"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:xg|xgui) (?:ref|refresh)$"
			script="xgui_RefreshLinks"
			enabled="y" regexp="y" sequence="100" > </alias>

	<alias	match="^(?:xg|xgui) (?:rel|reload)$"
			script="xgui_ReloadLinks"
			enabled="y" regexp="y" sequence="100" > </alias>

<!-- xset page size (area index process) -->
	<alias	match="^xset suspend page size$"
			script="suspend_page_size"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset resume page size$"
			script="resume_page_size"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- xtest commands -->
	<alias  match="^xtest areadata$"
			script="xtest_areadata"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest mcvars$"
			script="xtest_mcvars"
			enabled="y" regexp="y" sequence="100" > </alias>

	<alias	match="^xtest roomhist$"
			script="xtest_roomhist"
			enabled="y" regexp="y" sequence="100" > </alias>

	<alias	match="^xtest simulate cp(?: (?<type>ar?e?a?|ro?o?m?))?$"
			script="simulate_cp"
			enabled="y" regexp="y" sequence="1" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest loadroom(?: (?<room_id>\d+))?$"
			script="xtest_loadroom"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest popmsg$"
			script="xtest_popmsg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest debug$"
			script="xtest_debug"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias  match="^snd reload$"
			script="sndReload"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- New commands -->
  <alias
   match="^m(?:ob)?s(?:earch)? ([\p{P}\w]+)(?:\s([^0-9]+))?(?:\s+(\d+))?$"
   enabled="y"
   group="Mob_Database"
   regexp="y"
   script="onSearch"
   sequence="100"
  >
  </alias>

  <alias
   match="^mgo(?:to)? (\d+)$"
   enabled="y"
   regexp="y"
   script="mobGo"
   sequence="100"
  >
  </alias>

  <alias
	match="^(snd migrate|mergePwar)$"
	enabled="y"
	regexp="y"
	script="copyPwarWarn"
	sequence="100"
  >
	</alias>

  <alias
	match="^(snd migrate|mergePwar) confirm$"
	enabled="y"
	regexp="y"
	script="copyPwarDB"
	sequence="100"
  >
	</alias>
</aliases>
</muclient>

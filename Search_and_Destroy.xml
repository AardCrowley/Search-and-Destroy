<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE muclient>
<!-- Saved on Saturday, July 05, 2008, 4:46 PM -->
<muclient>
<plugin version="5.99" name="Search_and_Destroy" id="30000000537461726C696E67" date_written="2018-12-31 23:00:00" author="Crowley" language="Lua" purpose="Safe, legal Search and Destroy" save_state="y" requires="4.90" >
<description trim="n"> </description> </plugin>

<!-- Isolinear intermatrix (utility module) -->
<include name="constants.lua"/>
<variables><variable name="example"></variable></variables>

<timers>
	<timer name="tim_init_plugin"
		second="0.5" active_closed="y"
		script="init_plugin"
		enabled="y" send_to="12" > </timer>

	<timer name="execute_in_area_timer"
		second="0.1"
		script=""
		enabled="n" send_to="12">
			<send>	execute_in_area_tick() </send> </timer>

	<timer name="vidblain_nav_timer"
		second="0.1"
		script=""
		enabled="n" send_to="12">
			<send>	vidblain_nav_tick() </send> </timer>

	<timer name="update_check_tick"
		script="check_for_updates"
		second="10"
		enabled="y" send_to="12"> </timer>

	<timer name="quest_timer"
		script="quest_timer_tick"
		second="1"
		enabled="y" send_to="12"> </timer>

	<timer name="state_change_timer"
		script="check_state_changed"
		second="1"
		enabled="y" send_to="12"> </timer>
</timers>

<script>
<![CDATA[
dofile(GetInfo(60) .. "aardwolf_colors.lua")
require "movewindow"
require "serialize"
require "tprint"
require "wait"

json = require "json"

async_ok, async = pcall(require, "async")

function ifc(condition, ctrue, cfalse)
    if condition then
        return ctrue
    else
        return cfalse
    end
end

function mapFind(query)
    return CallPlugin("b6eae87ccedd84f510b74714", "map_find_query", query)
end

sound_not_played = true

mshow = {}
showStr = "@W%s @wis found in @Y%s @win/around @G%s @w(@Cmapper goto %s@w)"

PLUGIN_VERSION = GetPluginInfo(GetPluginID(), 19)
PLUGIN_NAME = GetPluginInfo(GetPluginID(), 1)
SCHEMA_VERSION = 4

UPDATE_CHECK_INTERVAL = 60 * 60 -- Check once per hour
local last_update_check = -1
local automatic_update_checks = GetVariable("mcvar_automatic_update_checks") or "on"

local current_sd_version = "Search & Destroy v" .. PLUGIN_VERSION .. ".4"
local plugin_id_gmcp_handler = "3e7dedbe37e44942dd46d264" -- easier to remember the var names than the plugin id's
local plugin_id_gmcp_mapper = "b6eae87ccedd84f510b74714"
local plugin_id_z_order = "462b665ecb569efbf261422f"
local plugin_id_soundpack = "23832d1089f727f5f34abad8"

local plugins_folder = GetPluginInfo(GetPluginID(), 20)
local db_file_1
local db_file_2
local mapper_db_file = GetInfo(66) .. WorldName() .. ".db" -- typically aardwolf.db, normally found in main Mushclient folder
local snd_db_file = GetInfo(66) .. "/SnDdb.db"

local state_changed = false

-- [[ Current, previous room data GMCP_room_info ]]
local current_room = {rmid = "-1", arid = "-1", maze = "no", exits = {}}
local previous_room = {rmid = "-2", arid = "-2", maze = "no", exits = {}}
local room_history = {}

-- [[ player status ]]
local current_character_state = "0"
local silentMode = GetVariable("mcvar_silentMode_command") or "off"

-- [[ Execute in area, room ]]
local execute_in_area_tbl = {i = 0, j = 0, arid = "", f = "", stat = 1}
local execute_in_room_tbl = {i = 0, j = 0, rmid = "", f = "", stat = 1}
local vidblain_nav_tbl = {i = 0, j = 0, rmid = "", f = "", stat = 1}

-- [[ main target data / current activity type ]]
local main_target_list = {}
local room_targets_ignored = {}
local area_room_type = "init"
local current_activity = "init" -- valid: cp, gq, init, none = "init"
local xcp_retry_stat
local xcp_index_attempt
local last_kill_index

local last_mob_damaged = nil
local last_mob_killed = nil

-- [[ campaign data (cpmd) ]]
local cp_info_level = tonumber(GetVariable("mcvar_cp_level_taken")) or 0
local cp_info_list = {}
local cp_check_list = {}
local last_cp_check = os.clock()

-- [[cp status, etc. ]]
local can_get_new_cp = "no"
local player_on_cp = "no"

-- [[ gquest data ]]
local gqid_joined = GetVariable("mcvar_gqid_joined") or "-1"
local gqid_started = GetVariable("mcvar_gqid_started") or "-1"
local gqid_extended = GetVariable("mcvar_gqid_extended") or "-1"
local potential_gq = {}
local player_on_gq = "no"
local gq_info_list = {}
local gq_check_list = {}
local last_gq_check = os.clock()
local gq_info_efflvl = tonumber(GetVariable("mcvar_gq_info_efflvl")) or 0

-- [[ gquest test state ]]
local mock_gquests = {}
local mock_gqid_joined
local debug_gq_mode = false

-- [[ current target data - cp, gq, quest ]]
local quest_target = {} -- {qmob = "", area = "", room = "", keyword="", status="0"}

-- [[ current target data]]
-- If there is no current target then it is nil.
-- If there is a current target then we'll have a table with some of these
-- filled in, depending on where the target is derived from
-- current_target = {
-- 		keyword = "sinister vandal",
-- 		name = "a sinister vandal",  -- nil for ad-hoc targets
-- 		room_name = "In The Courtyard", -- Only in room-based cp/gq or quests
-- 		area = "diatz",
-- 		index = 4, -- nil if not a cp/gq target (like when you do "qw <name>", or for quest targets)
-- 		activity = "cp", -- cp, gq, quest, or nil
-- }
local current_target = nil
--local current_target = {keyword = false, name = false, room_name = false, area = false, index = false, activity = false}

-- [[ time of next quest or when the current one expires ]]
local next_quest_time
local next_quest_text

-- [[ xcp action mode ]]
local xcp_action_mode = GetVariable("mcvar_xcp_action_mode") or "qw"
local xcp_targets_quest_onoff = GetVariable("mcvar_xcp_targets_quest_onoff") or "off"

-- [[ goto/nx data ]]
local gotoArea = -1
local gotoIndex = 0
local gotoList = {}
local next_room = -1

local going_to_room

-- [[ auto-hunt ]]
local auto_hunt_dir = ""
local auto_hunt_mob = ""
local autoHuntData = {}

-- [[ hunt trick ]]
local ht = {index = 1, first_target = true}

-- [[ quick where ]]
local qw = {index = 1}

-- [[ quick kill ]]
local quick_kill_command = GetVariable("mcvar_quick_kill_command") or "k"

-- [[ automatic noexp ]]
local anex_tnl_cutoff = tonumber(GetVariable("mcvar_anex_tnl_cutoff")) or 0
local noexp_onoff = "off"
local anex_automatic_onoff = GetVariable("mcvar_anex_automatic_onoff") or "on"

-- [[ Vidblain navigation ]]
local xset_vidblain_level = tonumber(GetVariable("mcvar_xset_vidblain_level")) or 300
local xset_vidblain_onoff = GetVariable("mcvar_xset_vidblain_onoff") or "off"

-- [[ Extra GQ aliases ]]
local xset_gq_check_extra_aliases = GetVariable("mcvar_xset_gq_check_extra_aliases") or "on"

-- [[ Variables from old Mapper Extender ]]
local area_range_index = {}
local area_start_rooms = {}
local last_area = ""
local speed = "run"
local start_room_type

-- [[ Variables from old Search and Destroy ]]
local dir_map = {north = "n", south = "s", east = "e", west = "w", up = "u", down = "d"}

-- [[ game time data ]]
local gCycle
local gYear
local gYearName
local gSeason
local gDay
local gHour

-- [[ Log players ]]
local logplayer_table = {}
local logplayer_levels
local logplayer_hours
local logplayer_stats
local logplayer_qp
local logplayer_timestamp
local logplayer_datestamp

-- [[ S&D window data ]]
local win = "sd_window_" .. GetPluginID()
local windowinfo
local win_pos_x = tonumber(GetVariable("mcvar_window_pos_x")) or 0 -- window position x,y coordinates
local win_pos_y = tonumber(GetVariable("mcvar_window_pos_y")) or 0
local win_width = tonumber(GetVariable("mcvar_window_width")) or 325
local win_width_min = 325
local win_width_max = tonumber(GetVariable("mcvar_window_width_max")) or win_width_min
local win_height = tonumber(GetVariable("mcvar_window_height")) or 280
local win_height_min = 60
local win_height_max = tonumber(GetVariable("mcvar_window_height_max")) or 280
local win_dragmove_start_x
local win_dragmove_start_y
local win_state = GetVariable("mcvar_window_state") or "max"
local win_init = false
local win_font = GetVariable("mcvar_window_font") or "Lucida Sans Unicode"
local win_font_size = tonumber(GetVariable("mcvar_window_font_size")) or 8
local win_font_bold = tonumber(GetVariable("mcvar_window_font_bold")) or 0
local win_font_italic = tonumber(GetVariable("mcvar_window_font_italic")) or 0
local win_font_underline = tonumber(GetVariable("mcvar_window_font_underline")) or 0
local win_hotspots = {}
local win_target_hotspots = {}
local win_hide_settings_button = GetVariable("mcvar_window_hide_settings_button") or "off"
local last_installed_version = GetVariable("last_installed_version")

-- [[ S&D window color data]]
local win_bgcolor = 0x000000

NOTE_COLORS = {
    INFO = "#FF5000",
    INFO_HIGHLIGHT = "#00B4E0",
    IMPORTANT = "#FFFFFF",
    IMPORTANT_HIGHLIGHT = "#00FF00",
    IMPORTANT_BACKGROUND = "#000080",
    ERROR = "#FFFFFF",
    ERROR_HIGHLIGHT = "#FFE32E",
    ERROR_BACKGROUND = "#650101",
    DEBUG = "#87CEFA",
    DEBUG_HIGHLIGHT = "#FFD700"
}

TEXT_COLOR_DETAILS = {
    {
        key = "normal",
        default = "#E0E0E0",
        menu_name = "Normal mobs",
        desc = "normal mobs"
    },
    {
        key = "targeted",
        default = "#FF4000",
        menu_name = "Targeted mob",
        desc = "the currently targeted mob"
    },
    {
        key = "dead",
        default = "#484848",
        menu_name = "Dead mobs",
        desc = "a dead mobs"
    },
    {
        key = "unknown",
        default = "#FF0000",
        menu_name = "Unknown mobs",
        desc = "mobs in an unknown area"
    },
    {
        key = "unknown_dead",
        default = "#900000",
        menu_name = "Unknown dead mobs",
        desc = "deads mob in an unknown areas"
    },
    {
        key = "unlikely",
        default = "#484848",
        menu_name = "Unlikely mobs",
        desc = "mobs that are not likely to be the target in a room-based campaign or global quest"
    },
    {
        key = "unlikely_tag",
        default = "#0000CD",
        menu_name = "Unlikely tag",
        desc = "the tag beside unlikely mobs"
    },
    {
        key = "quest_available",
        default = "#1E90FF",
        menu_name = "Quest available",
        desc = "the text informing you that you have a quest available"
    },
    {
        key = "quest_complete",
        default = "#7CFC00",
        menu_name = "Quest complete",
        desc = "the text informing you that you have a quest to turn in"
    },
    {
        key = "quest_waiting",
        default = "#FF7A7A",
        menu_name = "Next quest time",
        desc = "the next quest timer when you are waiting for your next quest"
    },
    {
        key = "alternating_row",
        default = "#000040",
        menu_name = "Alternating Row Backgrounds",
        desc = "the background color on alternating rows of the targets list in the mud window. Set it to black to disable"
    }
}

local text_colors = {}

for i, details in ipairs(TEXT_COLOR_DETAILS) do
    text_colors[details.key] = GetVariable("color_" .. details.key) or details.default
end

-- [[ Con and scan stuff ]]
local xset_nx_action =
    GetVariable("mcvar_xset_nx_action") or (GetVariable("mcvar_xset_autocon_onoff") == "on" and "smartscan") or "qs"
if xset_nx_action == "conscan" then
    xset_nx_action = "smartscan"
end

local xset_overwrite_con = GetVariable("mcvar_xset_overwrite_con") or "on"

local scanned_mobs_here = {}
local considered_mobs_here = {}
local scan_full_display = {}
local mobs_in_scanned_room = {}
local doors_in_scanned_room = {}
local activity_target_found_here = false
local quest_target_found_here = false
local target_found_nearby = false
local other_target_found_here = false
local scanning_current_room = false
local running_smart_scan = false
local con_after_scan = false

local mob_count_here = 0

-- [[ Sound settings ]]
-- Defaults on if soundpack is enabled, off otherwise
local xset_sound_onoff =
    GetVariable("mcvar_xset_sound_onoff") or
    (IsPluginInstalled(plugin_id_soundpack) and GetPluginInfo(plugin_id_soundpack, 17) and "on") or
    "off"

local target_nearby_sound = "target_nearby.wav"
local other_target_here_sound = "other_target_here.wav"

-- [[ Image state ]]
local images_loaded = false

-- [[ Table settings ]]
local table_notes = GetVariable("mcvar_xset_table_notes") or "off"
local table_width = tonumber(GetVariable("mcvar_xset_table_width")) or 80

-- [[ S&D dev stuff ]]
local debug_mode = GetVariable("debug_mode") or "off"

versionURL = "https://raw.githubusercontent.com/AardCrowley/Search-and-Destroy/master/VERSION"
pluginURL = "https://raw.githubusercontent.com/AardCrowley/Search-and-Destroy/%s/Search_and_Destroy.xml"
changelogURL = "https://raw.githubusercontent.com/AardCrowley/Search-and-Destroy/v%s/changelog"
soundsURL = "https://raw.githubusercontent.com/AardCrowley/Search-and-Destroy/v5.9/%s"

--	[[ Plugin broadcast/receive process ]]
function OnPluginBroadcast(msg, id, name, text)
    if (id == plugin_id_gmcp_handler) then
        if (text == "char.status") then -- character status
            current_character_state = gmcp("char.status.state")
	    if tonumber(gmcp("char.status.level")) < 200 then
		if anex_automatic_onoff == "on" then
			anex_check_tnl_silent()
		end
	    end
        elseif (text == "room.info") then -- current/previous room info
            sound_not_played = true
            local ri = gmcp("room.info")
            ri.maze = (string.match(ri.details, "maze") == "maze") and 1 or 0
            previous_room = current_room or {rmid = "-2", arid = "-2"}
            current_room = {rmid = ri.num, arid = ri.zone, exits = ri.exits, maze = ri.maze, name = ri.name} or {}
            if (current_room.rmid == previous_room.rmid) then
                -- do nothing
            else
                if going_to_room == current_room.rmid then
                    action_on_destination_arrived()
                    going_to_room = nil
                end

                if (#room_history == 300) then
                    room_history[300] = nil
                end
                table.insert(room_history, 1, room_history[0])
                room_history[0] = {rmid = current_room.rmid, arid = current_room.arid}
            end
        elseif (text == "comm.quest") then -- quest info
            local q = gmcp("comm.quest")
            quest_status_gmcp(q)
        elseif (text == "config") then -- config data, needed for automatic noexp
            noexp_onoff = (gmcp("config.noexp") == "YES") and "on" or "off"
        end
    end
end

-- [[ Plugin installation ]]
function OnPluginInstall()
    ColourNote("#808080", "", "\n+=================================================================+")
    ColourNote("#FF3000", "", "    " .. current_sd_version .. " installed at " .. os.date())
    print("")
    ColourNote("#FF3000", "", "    " .. "For support, contact Crowley")
    ColourNote(
        "#FF3000",
        "",
        "    " .. "Note: It's beneficial to run 'xset index areas' if you have never run it before."
    )
    ColourNote("#808080", "", "+=================================================================+\n")
    windowinfo =
        movewindow.install(
        win,
        miniwin.pos_center,
        miniwin.create_absolute_location,
        false,
        nil,
        {mouseup = MouseUp, mousedown = LeftClickOnly, dragmove = LeftClickOnly, dragrelease = LeftClickOnly},
        {x = win_pos_x, y = win_pos_y}
    )
    xg_create_window()

    migrate_database()
    if not GetVariable("index_already_checked") then
        area_index_process()
        set_variable("index_already_checked", "done")
    end
    download_sounds(
        function()
        end
    )
    --show_changelog(false)
    get_changelog(false)
end

function OnPluginEnable()
    InfoNote("Enabled ", "Search and Destroy")
    win_init = false
    xg_create_window()
end

function OnPluginDisable()
    InfoNote("Disabled ", "Search and Destroy")
    WindowDelete(win)
end

function migrate_database()
    local db = sqlite3.open(GetInfo(66) .. "/SnDdb.db")
    local current_version

    create_initial_tables(db)
    write_marks_to_db(db)

    for row in db:nrows("PRAGMA user_version") do
        current_version = row.user_version
    end

    if current_version >= SCHEMA_VERSION then
        return
    end

    InfoNote("Migrating database")

    -- Inidividual migrations go here
    if current_version == 0 then
        Note("Indexing areas")
        area_index_process()
    end

    if current_version < 2 then
        create_mob_keywords_table(db)
        strip_mobs_table(db)
    end

    if current_version < 3 then
        add_kills_column(db)
    end

    if current_version < 4 then
        remove_bad_mobs(db)
    end

    InfoNote("Migration complete!")
    db:execute(string.format("PRAGMA user_version = %i;", SCHEMA_VERSION))

    db:close_vm()
end

function create_initial_tables(db)
    local db_tables = {}
    local query = "SELECT name FROM sqlite_master WHERE type='table'"
    local create_tables = {}

    for row in db:nrows(query) do
        db_tables[row.name] = true
    end

    if not db_tables["mobs"] then
        DebugNote("Creating table 'mobs'")
        table.insert(
            create_tables,
            [[
				CREATE TABLE mobs (
					mob 		TEXT NOT NULL,
					room 		TEXT NOT NULL,
					roomid 		INTEGER NOT NULL,
					zone 		TEXT NOT NULL,
					count 		INTEGER NOT NULL,
					keyword 	TEXT NOT NULL);
			]]
        )
    end

    if not db_tables["area"] then
        DebugNote("Creating table 'area'")
        table.insert(
            create_tables,
            [[
				CREATE TABLE 	area (
					name		TEXT NOT NULL,
					key			TEXT NOT NULL,
					minlvl		INTEGER NOT NULL,
					maxlvl		INTEGER NOT NULL,
					lock		INTEGER NOT NULL,
					startRoom	INTEGER,
					noquest		TEXT,
					vidblain	TEXT,
					userKey		TEXT);
			]]
        )
    end

    if #create_tables > 0 then
        db:execute(table.concat(create_tables, ""))
    end
end

function create_mob_keywords_table(db)
    DebugNote("Creating mob aliases database table")
    db:execute(
        [[
			CREATE TABLE IF NOT EXISTS mob_keyword_exceptions (
				area_name	TEXT NOT NULL,
				mob_name	TEXT NOT NULL,
				keyword		TEXT NOT NULL,
				UNIQUE(area_name, mob_name)
			);
		]]
    )
    populate_mob_keyword_table(db)
end

function strip_mobs_table(db)
    DebugNote("Updating mobs table")
    db:execute(
        [[
			BEGIN TRANSACTION;
			ALTER TABLE mobs RENAME TO old_mobs;
			CREATE TABLE mobs (
				mob 		TEXT NOT NULL COLLATE NOCASE,
				room 		TEXT NOT NULL COLLATE NOCASE,
				roomid 		INTEGER NOT NULL,
				zone 		TEXT NOT NULL,
				count 		INTEGER NOT NULL DEFAULT 0,
				UNIQUE(mob, roomid));
			INSERT INTO mobs
				SELECT mob COLLATE NOCASE, room COLLATE NOCASE, roomid, zone, SUM(count) as count
				FROM old_mobs GROUP BY mob COLLATE NOCASE, roomid;
			DROP TABLE old_mobs;
			COMMIT;
		]]
    )
end

function add_kills_column(db)
    DebugNote("Adding kills to mobs table")
    db:execute(
        [[
			BEGIN TRANSACTION;
			ALTER TABLE mobs RENAME TO old_mobs;
			CREATE TABLE mobs (
				mob 		TEXT NOT NULL COLLATE NOCASE,
				room 		TEXT NOT NULL COLLATE NOCASE,
				roomid 		INTEGER NOT NULL,
				zone 		TEXT NOT NULL,
				seen_count 	INTEGER NOT NULL DEFAULT 0,
				kill_count 	INTEGER NOT NULL DEFAULT 0,
				UNIQUE(mob, roomid));
			INSERT INTO mobs
				SELECT mob, room, roomid, zone, count as seen_count, 0 as kill_count
				FROM old_mobs;
			DROP TABLE old_mobs;
			COMMIT;
		]]
    )
end

function remove_bad_mobs(db)
    DebugNote("removing wounded and aimed mobs from the db")
    db:execute([[
			DELETE FROM mobs WHERE mob LIKE "%(wounded)%" OR mob LIKE "%(aimed)%";
		]])
end

function write_marks_to_db(db)
    DebugNote("writing start rooms to db")
    load_area_start_rooms()
    operations = {}
    for arid, details in pairs(area_start_rooms) do
        table.insert(
            operations,
            string.format(
                [[
				UPDATE area SET startRoom = %s
				WHERE key = %s;
			]],
                fixsql(details.roomid),
                fixsql(arid)
            )
        )
    end
    execute_in_transaction(db, operations)
end

function get_changelog(all_changes)
    show_all_changes = all_changes or false
    DebugNote("Attempting to download changelog")
    download_file(string.format(changelogURL, PLUGIN_VERSION), show_changelog)
end

function show_changelog(retval, page, status, headers, full_status, request_url)
    if status ~= 200 then
        DebugNote("show_changelog got status ", status)
        ErrorNote("Error while fetching changelog")
        return
    end

    local CHANGELOG = json.decode(page)

    local changes_to_show = {}

    if show_all_changes then
        changes_to_show = CHANGELOG
    elseif last_installed_version then
        last_installed_version = tonumber(last_installed_version)
        DebugNote("Last installed version ", last_installed_version)

        for version, notes in pairs(CHANGELOG) do
            if tonumber(version) > tonumber(last_installed_version) then
                changes_to_show[version] = notes
            end
        end
    else
        -- show only the latest changes
        local latest_change_num = -1
        for version, notes in pairs(CHANGELOG) do
            version = tonumber(version)
            if version > latest_change_num then
                latest_change_num = version
            end
        end
        changes_to_show[latest_change_num] = CHANGELOG[latest_change_num]
    end
    display_changes(changes_to_show)

    last_installed_version = PLUGIN_VERSION
    set_variable("last_installed_version", tostring(PLUGIN_VERSION))
end

function display_changes(changes_to_show)
    local line_width = 80
    local versions = {}
    for version, notes in pairs(changes_to_show) do
        table.insert(versions, version)
    end
    if #versions == 0 then
        DebugNote("No updates to show in changelog")
        return
    end
    table.sort(versions)

    local function write_notes(lines)
        for i, line in ipairs(lines) do
            local indent_length = line:match("^>") and 8 or 4
            line = line:gsub("^>", "")
            local indent = string.rep(" ", indent_length)
            local indent1 = string.rep(" ", indent_length - 4) .. "  * "

            line = helpWrap(line, 76, indent, indent1):gsub("\n", "\n" .. indent)
            ColourNote(NOTE_COLORS.INFO, "", line)
        end
    end

    InfoNote(string.rep("=", 25), " Search and Destroy Changelog ", string.rep("=", 25), "\n")
    for i, version in ipairs(versions) do
        local head = string.format(" Version %s ", tostring(version))
        ColourTell(NOTE_COLORS.INFO, "", "===")
        ColourTell(NOTE_COLORS.INFO_HIGHLIGHT, "", head)
        ColourNote(NOTE_COLORS.INFO, "", string.rep("=", line_width - #head - 3))
        local notes = changes_to_show[version]

        if notes.features then
            ColourNote(NOTE_COLORS.INFO_HIGHLIGHT, "", "FEATURES:")
            write_notes(notes.features)
            print("")
        end

        if notes.changes then
            ColourNote(NOTE_COLORS.INFO_HIGHLIGHT, "", "CHANGES:")
            write_notes(notes.changes)
            print("")
        end

        if notes.fixes then
            ColourNote(NOTE_COLORS.INFO_HIGHLIGHT, "", "FIXES:")
            write_notes(notes.fixes)
            print("")
        end
        print("")
    end

    if changes_to_show ~= CHANGELOG then
        InfoNote(
            "To see changes from all versions select ",
            "Changelog",
            " from the settings menu in the S&D window.\n"
        )
    end
end

local init_called = 0
function init_plugin()
    if not IsConnected() then
        return
    end
    local ch_state = current_character_state
    if ((ch_state ~= "3") and (ch_state ~= "8") and (ch_state ~= "9") and (ch_state ~= "11")) then
        send_gmcp_packet("request char")
        return
    end
    SendNoEcho("tags scan on")
    SendNoEcho("tags roomchars on")

    send_gmcp_packet("request room")
    init_called = init_called + 1
    if (init_called == 2) then
        setup_scan_con_triggers()
        EnableTimer("tim_init_plugin", false)
        load_saved_table_data()
        send_gmcp_packet("config noexp")
        send_gmcp_packet("request quest")
        toggle_con_overwrite_triggers()
        check_for_updates()
        apply_xset_gqalias()
    end
end

-- Expecting an array of operations
function execute_in_transaction(db, operations)
    query = "BEGIN TRANSACTION;" .. table.concat(operations, "") .. "COMMIT;"
    db:exec(query)
end

-- [[ Lookup table:  Area start room, noquest true/false, vidblain areas ]]
local areaDefaultStartRooms = {
    ["abend"] = {start = "24909", ct = "3"}, -- Continents
    ["alagh"] = {start = "3224", ct = "4"},
    ["gelidus"] = {start = "18780", ct = "2"},
    ["mesolar"] = {start = "12664", ct = "0"},
    ["southern"] = {start = "5192", ct = "1"},
    ["uncharted"] = {start = "7701", ct = "5"},
    ["vidblain"] = {start = "33570", ct = "6", vidblain = true},
    ["aardington"] = {start = "47509"}, -- A --
    ["academy"] = {start = "35233"},
    ["adaldar"] = {start = "34400"},
    ["afterglow"] = {start = "38134"},
    ["agroth"] = {start = "11027"},
    ["ahner"] = {start = "30129"},
    ["alehouse"] = {start = "885"},
    ["amazon"] = {start = "1409"},
    ["amusement"] = {start = "29282"},
    ["andarin"] = {start = "2399"},
    ["annwn"] = {start = "28963"},
    ["anthrox"] = {start = "3993"},
    ["arboretum"] = {start = "39100"},
    ["arena"] = {start = "25768"},
    ["arisian"] = {start = "28144"},
    ["ascent"] = {start = "43150"},
    ["asherodan"] = {start = "37400", vidblain = true},
    ["astral"] = {start = "27882"},
    ["atlantis"] = {start = "10573"},
    ["autumn"] = {start = "13839"},
    ["avian"] = {start = "4334"},
    ["aylor"] = {start = "32418"},
    ["bazaar"] = {start = "34454"}, -- B --
    ["beer"] = {start = "20062"},
    ["believer"] = {start = "25940"},
    ["blackrose"] = {start = "1817"},
    ["bliss"] = {start = "29988"},
    ["bonds"] = {start = "23411"},
    ["caldera"] = {start = "26341"}, -- C --
    ["callhero"] = {start = "33031"},
    ["camps"] = {start = "4714"},
    ["canyon"] = {start = "25551"},
    ["caravan"] = {start = "16071"},
    ["cards"] = {start = "6255"},
    ["carnivale"] = {start = "28635"},
    ["cataclysm"] = {start = "19976"},
    ["cathedral"] = {start = "27497"},
    ["cats"] = {start = "40900"},
    ["chasm"] = {start = "29446"},
    ["chessboard"] = {start = "25513"},
    ["childsplay"] = {start = "678"},
    ["cineko"] = {start = "1507"},
    ["citadel"] = {start = "14963"},
    ["conflict"] = {start = "27711"},
    ["coral"] = {start = "4565"},
    ["cougarian"] = {start = "14311"},
    ["cove"] = {start = "49941"},
    ["cradle"] = {start = "11267"},
    ["crynn"] = {start = "43800"},
    ["damned"] = {start = "10469"}, -- D --
    ["darklight"] = {start = "19642", vidblain = true},
    ["darkside"] = {start = "15060"},
    ["ddoom"] = {start = "4193"},
    ["deadlights"] = {start = "16856"},
    ["deathtrap"] = {start = "1767"},
    ["deneria"] = {start = "35006"},
    ["desert"] = {start = "20186"},
    ["desolation"] = {start = "19532"},
    ["dhalgora"] = {start = "16755"},
    ["diatz"] = {start = "1254"},
    ["diner"] = {start = "36700"},
    ["dortmund"] = {start = "16577"},
    ["drageran"] = {start = "25894"},
    ["dread"] = {start = "26075"},
    ["dsr"] = {start = "30030"},
    ["dundoom"] = {start = "25661"},
    ["dunoir"] = {start = "14222"},
    ["duskvalley"] = {start = "37301"},
    ["dynasty"] = {start = "30799"},
    ["earthlords"] = {start = "42000"}, -- E --
    ["earthplane"] = {start = "1354"},
    ["elemental"] = {start = "41624"},
    ["empire"] = {start = "32203"},
    ["empyrean"] = {start = "14042"},
    ["entropy"] = {start = "29773"},
    ["fantasy"] = {start = "15205"}, -- F --
    ["farm"] = {start = "10676"},
    ["fayke"] = {start = "30418"},
    ["fens"] = {start = "16528"},
    ["fields"] = {start = "29232"},
    ["firebird"] = {start = "32885"},
    ["firenation"] = {start = "41879"},
    ["fireswamp"] = {start = "34755"},
    ["fortress"] = {start = "31835"},
    ["fortune"] = {start = "38561"},
    ["fractured"] = {start = "17033"},
    ["ft1"] = {start = "1205"},
    ["ftii"] = {start = "26673"},
    ["gallows"] = {start = "4344"}, -- G --
    ["gathering"] = {start = "36451"},
    ["gauntlet"] = {start = "31652"},
    ["gilda"] = {start = "4243"},
    ["glamdursil"] = {start = "35055"},
    ["glimmerdim"] = {start = "26252"},
    ["gnomalin"] = {start = "34397"},
    ["goldrush"] = {start = "15014"},
    ["graveyard"] = {start = "28918"},
    ["greece"] = {start = "2089"},
    ["gwillim"] = {start = "25974"},
    ["hades"] = {start = "29161"}, -- H --
    ["hatchling"] = {start = "34670"},
    ["hawklord"] = {start = "40550"},
    ["hedge"] = {start = "15146"},
    ["helegear"] = {start = "30699"},
    ["hell"] = {start = "30984"},
    ["hoard"] = {start = "1675"},
    ["hodgepodge"] = {start = "30469"},
    ["horath"] = {start = "91"},
    ["horizon"] = {start = "31959"},
    ["illoria"] = {start = "10420"},
    ["imagi"] = {start = "36800"}, -- I --
    ["imperial"] = {start = "16966", vidblain = true},
    ["infamy"] = {start = "26641"},
    ["infest"] = {start = "16165"},
    ["insan"] = {start = "6850"},
    ["jenny"] = {start = "29637"}, -- J --
    ["jotun"] = {start = "31508"},
    ["kearvek"] = {start = "29722"}, -- K --
    ["kerofk"] = {start = "16405"},
    ["ketu"] = {start = "35114"},
    ["kingsholm"] = {start = "27522"},
    ["knossos"] = {start = "28193"},
    ["kobaloi"] = {start = "10691"},
    ["kultiras"] = {start = "31161"},
    ["lab"] = {start = "28684"}, -- L --
    ["labyrinth"] = {start = "31405"},
    ["lagoon"] = {start = "30549"},
    ["landofoz"] = {start = "510"},
    ["laym"] = {start = "6005"},
    ["legend"] = {start = "16224"},
    ["lemdagor"] = {start = "1966"},
    ["lidnesh"] = {start = "27995"},
    ["livingmine"] = {start = "37008"},
    ["longnight"] = {start = "26367"},
    ["losttime"] = {start = "28584"},
    ["lowlands"] = {start = "28044"},
    ["lplanes"] = {start = "29364"},
    ["maelstrom"] = {start = "38058"}, -- M --
    ["manor"] = {start = "10621"},
    ["masq"] = {start = "29840"},
    ["mayhem"] = {start = "1866"},
    ["melody"] = {start = "14172"},
    ["minos"] = {start = "20472"},
    ["mistridge"] = {start = "4491"},
    ["monastery"] = {start = "15756"},
    ["mudwog"] = {start = "2347"},
    ["nanjiki"] = {start = "11203"}, -- N --
    ["necro"] = {start = "29922"},
    ["nenukon"] = {start = "31784"},
    ["newthalos"] = {start = "23853"},
    ["ninehells"] = {start = "4613"},
    ["northstar"] = {start = "11127"},
    ["nottingham"] = {start = "11077"},
    ["nulan"] = {start = "37900"},
    ["nursing"] = {start = "31977"},
    ["nynewoods"] = {start = "23562"},
    ["oceanpark"] = {start = "39600"}, -- O --
    ["omentor"] = {start = "15579", vidblain = true},
    ["ooku"] = {start = "39000"},
    ["origins"] = {start = "35900"},
    ["orlando"] = {start = "30331"},
    ["paradise"] = {start = "29624"}, -- P --
    ["partroxis"] = {start = "5814"},
    ["peninsula"] = {start = "35701"},
    ["petstore"] = {start = "995"},
    ["pompeii"] = {start = "57"},
    ["promises"] = {start = "25819"},
    ["prosper"] = {start = "28268"},
    ["qong"] = {start = "16115"}, -- Q --
    ["quarry"] = {start = "23510"},
    ["radiance"] = {start = "19805"}, -- R --
    ["raga"] = {start = "19861"},
    ["raukora"] = {start = "6040"},
    ["rebellion"] = {start = "10305"},
    ["remcon"] = {start = "25837"},
    ["reme"] = {start = "32703"},
    ["rosewood"] = {start = "6901"},
    ["ruins"] = {start = "16805"},
    ["sagewood"] = {start = "28754"}, -- S --
    ["sahuagin"] = {start = "34592"},
    ["salt"] = {start = "4538"},
    ["sanctity"] = {start = "10518"},
    ["sanctum"] = {start = "15307"},
    ["sandcastle"] = {start = "37701"},
    ["sanguine"] = {start = "15436"},
    ["scarred"] = {start = "34036"},
    ["sendhian"] = {start = "20288", vidblain = true},
    ["sennarre"] = {start = "15491"},
    ["shadowsend"] = {start = "40096"},
    ["shouggoth"] = {start = "34087"},
    ["siege"] = {start = "43265"},
    ["sirens"] = {start = "16298"},
    ["slaughter"] = {start = "1601"},
    ["snuckles"] = {start = "182"},
    ["soh"] = {start = "25611"},
    ["sohtwo"] = {start = "30752"},
    ["solan"] = {start = "23713"},
    ["songpalace"] = {start = "47013"},
    ["spyreknow"] = {start = "34800"},
    ["stone"] = {start = "11386"},
    ["storm"] = {start = "6304"},
    ["stormhaven"] = {start = "20649"},
    ["stronghold"] = {start = "20572"},
    ["stuff"] = {start = "40400"},
    ["takeda"] = {start = "15952"}, -- T --
    ["talsa"] = {start = "26917"},
    ["temple"] = {start = "31597"},
    ["tanra"] = {start = "46913"},
    ["terra"] = {start = "19679"},
    ["terramire"] = {start = "4493"},
    ["thieves"] = {start = "7"},
    ["tilule"] = {start = "39771"},
    ["times"] = {start = "28463"},
    ["tirna"] = {start = "20136"},
    ["titan"] = {start = "38234"},
    ["tol"] = {start = "16325"},
    ["tombs"] = {start = "15385"},
    ["umari"] = {start = "36601"}, -- U --
    ["underdark"] = {start = "27341"},
    ["uplanes"] = {start = "29364"},
    ["uprising"] = {start = "15382"},
    ["vale"] = {start = "1036"}, -- V --
    ["verdure"] = {start = "24090"},
    ["verume"] = {start = "30607"},
    ["village"] = {start = "30850"},
    ["vlad"] = {start = "15970"},
    ["volcano"] = {start = "6091"},
    ["weather"] = {start = "40499"}, -- W --
    ["werewood"] = {start = "30956"},
    ["wildwood"] = {start = "322"},
    ["winter"] = {start = "1306"},
    ["wizards"] = {start = "31316"},
    ["wonders"] = {start = "32981"},
    ["wooble"] = {start = "11335"},
    ["woodelves"] = {start = "32199"},
    ["wtc"] = {start = "37895"},
    ["wyrm"] = {start = "28847"},
    ["xmas"] = {start = "6212"}, -- X --
    ["xylmos"] = {start = "472"},
    ["yarr"] = {start = "30281"},
    ["ygg"] = {start = "24186"}, -- Y --
    ["yurgach"] = {start = "29450"},
    ["zangar"] = {start = "6164"}, -- Z --
    ["zodiac"] = {start = "15857"},
    ["zoo"] = {start = "5920"},
    ["zyian"] = {start = "729"},
    -- Non-questable Areas
    ["manor1"] = {start = "14460", noquest = true}, -- Manor areas
    ["manor3"] = {start = "20836", noquest = true},
    ["manorisle"] = {start = "6366", noquest = true},
    ["manormount"] = {start = "39449", noquest = true},
    ["manorsea"] = {start = "35003", noquest = true},
    ["manorville"] = {start = "35004", noquest = true},
    ["manorwoods"] = {start = "35002", noquest = true},
    ["blackclaw"] = {start = "   -1", noquest = true}, -- epic areas
    ["geniewish"] = {start = "38464", noquest = true},
    ["icefall"] = {start = "38701", noquest = true},
    ["inferno"] = {start = "-1", noquest = true},
    ["oradrin"] = {start = "25436", noquest = true},
    ["transcend"] = {start = "0", noquest = true},
    ["winds"] = {start = "39900", noquest = true},
    ["badtrip"] = {start = "32877", noquest = true}, -- Other no-quest areas
    ["birthday"] = {start = "10920", noquest = true},
    ["seaking"] = {start = "-1", noquest = true},
    ["amazonclan"] = {start = "34212", noquest = true}, -- Public clan halls
    ["bard"] = {start = "30538", noquest = true},
    ["bootcamp"] = {start = "49256", noquest = true},
    ["cabal"] = {start = "15704", noquest = true},
    ["chaos"] = {start = "28909", noquest = true},
    ["crimson"] = {start = "27989", noquest = true},
    ["crusaders"] = {start = "31122", noquest = true},
    ["daoine"] = {start = "30949", noquest = true},
    ["doh"] = {start = "16803", noquest = true},
    ["dominion"] = {start = "5863", noquest = true},
    ["dragon"] = {start = "642", noquest = true},
    ["druid"] = {start = "29582", noquest = true},
    ["emerald"] = {start = "831", noquest = true},
    ["gaardian"] = {start = "20026", noquest = true},
    ["imperium"] = {start = "30415", noquest = true},
    ["light"] = {start = "2339", noquest = true},
    ["loqui"] = {start = "28580", noquest = true},
    ["masaki"] = {start = "15852", noquest = true},
    ["perdition"] = {start = "19968", noquest = true},
    ["pyre"] = {start = "15141", noquest = true},
    ["romani"] = {start = "24180", noquest = true},
    ["seekers"] = {start = "14165", noquest = true},
    ["shadokil"] = {start = "32407", noquest = true},
    ["tanelorn"] = {start = "31561", noquest = true},
    ["tao"] = {start = "29210", noquest = true},
    ["touchstone"] = {start = "28346", noquest = true},
    ["twinlobe"] = {start = "15575", noquest = true},
    ["vanir"] = {start = "878", noquest = true},
    ["watchmen"] = {start = "32342", noquest = true},
    ["baal"] = {start = "-1", noquest = true}, -- Closed clan halls
    ["hook"] = {start = "-1", noquest = true},
    ["retri"] = {start = "-1", noquest = true},
    ["rhabdo"] = {start = "-1", noquest = true},
    ["rogues"] = {start = "-1", noquest = true},
    ["xunti"] = {start = "-1", noquest = true},
    ["challenge"] = {start = "-1", noquest = true}, -- Normally inaccessible areas, or which lack a sensible starting room.
    ["immhomes"] = {start = "-1", noquest = true},
    ["lasertwo"] = {start = "-1", noquest = true},
    ["limbo"] = {start = "-1", noquest = true},
    ["lualand"] = {start = "-1", noquest = true},
    ["midgaard"] = {start = "-1", noquest = true},
    ["oldclanone"] = {start = "-1", noquest = true},
    ["oldclantwo"] = {start = "-1", noquest = true},
    ["oldclanthr"] = {start = "-1", noquest = true},
    ["oldclanfou"] = {start = "-1", noquest = true},
    ["vault"] = {start = "-1", noquest = true},
    ["warzone"] = {start = "-1", noquest = true},
    ["wolfmaze"] = {start = "-1", noquest = true}
}

local vidblain_area_list = {
    ["asherodan"] = {},
    ["darklight"] = {},
    ["imperial"] = {},
    ["omentor"] = {},
    ["sendhian"] = {},
    ["vidblain"] = {}
}

--	[[ Lookup table to get area id from area long name ]]
local areaNameXref = {
    ["A Genie's Last Wish"] = "geniewish",
    ["A Magical Hodgepodge"] = "hodgepodge",
    ["A Peaceful Giant Village"] = "village",
    ["Aardington Estate"] = "aardington",
    ["Aardwolf Zoological Park"] = "zoo",
    ["Adventures in Sendhia"] = "sendhian",
    ["Aerial City of Cineko"] = "cineko",
    ["Afterglow"] = "afterglow",
    ["Alagh, the Blood Lands"] = "alagh",
    ["All in a Fayke Day"] = "fayke",
    ["Ancient Greece"] = "greece",
    ["Andolor's Ocean Adventure Park"] = "oceanpark",
    ["Annwn"] = "annwn",
    ["Anthrox"] = "anthrox",
    ["Arboretum"] = "arboretum",
    ["Arisian Realm"] = "arisian",
    ["Art of Melody"] = "melody",
    ["Artificer's Mayhem"] = "mayhem",
    ["Ascension Bluff Nursing Home"] = "nursing",
    ["Atlantis"] = "atlantis",
    ["Avian Kingdom"] = "avian",
    ["Battlefields of Adaldar"] = "adaldar",
    ["Black Lagoon"] = "lagoon",
    ["Black Rose"] = "blackrose",
    ["Brightsea and Glimmerdim"] = "glimmerdim",
    ["Canyon Memorial Hospital"] = "canyon",
    ["Castle Vlad-Shamir"] = "vlad",
    ["Chaprenula's Laboratory"] = "lab",
    ["Child's Play"] = "childsplay",
    ["Christmas Vacation"] = "xmas",
    ["Cloud City of Gnomalin"] = "gnomalin",
    ["Cradlebrook"] = "cradle",
    ["Crossroads of Fortune"] = "fortune",
    ["Crynn's Church"] = "crynn",
    ["Dark Elf Stronghold"] = "stronghold",
    ["Death's Manor"] = "manor",
    ["Deathtrap Dungeon"] = "deathtrap",
    ["Den of Thieves"] = "thieves",
    ["Descent to Hell"] = "hell",
    ["Desert Doom"] = "ddoom",
    ["Dhal'Gora Outlands"] = "dhalgora",
    ["Diamond Soul Revelation"] = "dsr",
    ["Dortmund"] = "dortmund",
    ["Dread Tower"] = "dread",
    ["Dusk Valley"] = "duskvalley",
    ["Earth Plane 4"] = "earthplane",
    ["Elemental Chaos"] = "elemental",
    ["Empyrean, Streets of Downfall"] = "empyrean",
    ["Entrance to Hades"] = "hades",
    ["Eternal Autumn"] = "autumn",
    ["Faerie Tales II"] = "ftii",
    ["Faerie Tales"] = "ft1",
    ["Fantasy Fields"] = "fantasy",
    ["Foolish Promises"] = "promises",
    ["Fort Terramire"] = "terramire",
    ["Gallows Hill"] = "gallows",
    ["Gelidus"] = "gelidus",
    ["Giant's Pet Store"] = "petstore",
    ["Gilda And The Dragon"] = "gilda",
    ["Gnoll's Quarry"] = "quarry",
    ["Gold Rush"] = "goldrush",
    ["Guardian's Spyre of Knowledge"] = "spyreknow",
    ["Wayfarer's Caravan"] = "caravan",
    ["Halls of the Damned"] = "damned",
    ["Hatchling Aerie"] = "hatchling",
    ["Hedgehogs' Paradise"] = "hedge",
    ["Helegear Sea"] = "helegear",
    ["Hotel Orlando"] = "orlando",
    ["House of Cards"] = "cards",
    ["Icefall"] = "icefall",
    ["Imagi's Nation"] = "imagi",
    ["Imperial Nation"] = "imperial",
    ["Insanitaria"] = "insan",
    ["Into the Long Night"] = "longnight",
    ["Intrigues of Times Past"] = "times",
    ["Island of Lost Time"] = "losttime",
    ["Jenny's Tavern"] = "jenny",
    ["Jotunheim"] = "jotun",
    ["Jungles of Verume"] = "verume",
    ["Keep of the Kobaloi"] = "kobaloi",
    ["Kerofk"] = "kerofk",
    ["Ketu Uplands"] = "ketu",
    ["Kiksaadi Cove"] = "cove",
    ["Kimr's Farm"] = "farm",
    ["Kingdom of Ahner"] = "ahner",
    ["Kingsholm"] = "kingsholm",
    ["Kobold Siege Camp"] = "siege",
    ["Kul Tiras"] = "kultiras",
    ["Land of Legend"] = "legend",
    ["Living Mines of Dak'Tai"] = "livingmine",
    ["Masquerade Island"] = "masq",
    ["Mount duNoir"] = "dunoir",
    ["Mudwog's Swamp"] = "mudwog",
    ["Nanjiki Ruins"] = "nanjiki",
    ["Nebulous Horizon"] = "horizon",
    ["Necromancers' Guild"] = "necro",
    ["Nenukon and the Far Country"] = "nenukon",
    ["New Thalos"] = "newthalos",
    ["Northstar"] = "northstar",
    ["Nottingham"] = "nottingham",
    ["Olde Worlde Carnivale"] = "carnivale",
    ["Onyx Bazaar"] = "bazaar",
    ["Ookushka Garrison"] = "ooku",
    ["Paradise Lost"] = "paradise",
    ["Plains of Nulan'Boar"] = "nulan",
    ["Pompeii"] = "pompeii",
    ["Prosper's Island"] = "prosper",
    ["Qong"] = "qong",
    ["Radiance Woods"] = "radiance",
    ["Raganatittu"] = "raga",
    ["Realm of Deneria"] = "deneria",
    ["Realm of the Firebird"] = "firebird",
    ["Realm of the Sacred Flame"] = "firenation",
    ["Realm of the Zodiac"] = "zodiac",
    ["Rebellion of the Nix"] = "rebellion",
    ["Rosewood Castle"] = "rosewood",
    ["Sagewood Grove"] = "sagewood",
    ["Sanctity of Eternal Damnation"] = "sanctity",
    ["Sen'narre Lake"] = "sennarre",
    ["Seven Wonders"] = "wonders",
    ["Shadow's End"] = "shadowsend",
    ["Sheila's Cat Sanctuary"] = "cats",
    ["Sho'aram, Castle in the Sand"] = "sandcastle",
    ["Siren's Oasis Resort"] = "sirens",
    ["Snuckles Village"] = "snuckles",
    ["Storm Mountain"] = "storm",
    ["Storm Ships of Lem-Dagor"] = "lemdagor",
    ["Sundered Vale"] = "vale",
    ["Swordbreaker's Hoard"] = "hoard",
    ["Tairayden Peninsula"] = "peninsula",
    ["Tai'rha Laym"] = "laym",
    ["Takeda's Warcamp"] = "takeda",
    ["Tanra'vea"] = "tanra",
    ["Thandeld's Conflict"] = "conflict",
    ["The Abyssal Caverns of Sahuagin"] = "sahuagin",
    ["The Amazon Nation"] = "amazon",
    ["The Amusement Park"] = "amusement",
    ["The Archipelago of Entropy"] = "entropy",
    ["The Astral Travels"] = "astral",
    ["The Aylorian Academy"] = "academy",
    ["The Blighted Tundra of Andarin"] = "andarin",
    ["The Blood Opal of Rauko'ra"] = "raukora",
    ["The Blood Sanctum"] = "sanctum",
    ["The Broken Halls of Horath"] = "horath",
    ["The Call of Heroes"] = "callhero",
    ["The Cataclysm"] = "cataclysm",
    ["The Chasm and The Catacombs"] = "chasm",
    ["The Chessboard"] = "chessboard",
    ["The Continent of Mesolar"] = "mesolar",
    ["The Coral Kingdom"] = "coral",
    ["The Cougarian Queendom"] = "cougarian",
    ["The Council of the Wyrm"] = "wyrm",
    ["The Covenant of Mistridge"] = "mistridge",
    ["The Cracks of Terra"] = "terra",
    ["The Curse of the Midnight Fens"] = "fens",
    ["The Dark Continent, Abend"] = "abend",
    ["The Dark Temple of Zyian"] = "zyian",
    ["The DarkLight"] = "darklight",
    ["The Darkside of the Fractured Lands"] = "darkside",
    ["The Deadlights"] = "deadlights",
    ["The Desert Prison"] = "desert",
    ["The Drageran Empire"] = "drageran",
    ["The Dungeon of Doom"] = "dundoom",
    ["The Earth Lords"] = "earthlords",
    ["The Eighteenth Dynasty"] = "dynasty",
    ["The Empire of Aiighialla"] = "empire",
    ["The Empire of Talsa"] = "talsa",
    ["The Fabled City of Stone"] = "stone",
    ["The Fire Swamp"] = "fireswamp",
    ["The First Ascent"] = "ascent",
    ["The Flying Citadel"] = "citadel",
    ["The Forest of Li'Dnesh"] = "lidnesh",
    ["The Fractured Lands"] = "fractured",
    ["The Gathering Horde"] = "gathering",
    ["The Gauntlet"] = "gauntlet",
    ["The Gladiator's Arena"] = "arena",
    ["The Glamdursil"] = "glamdursil",
    ["The Goblin Fortress"] = "fortress",
    ["The Grand City of Aylor"] = "aylor",
    ["The Graveyard"] = "graveyard",
    ["The Great City of Knossos"] = "knossos",
    ["The Great Salt Flats"] = "salt",
    ["The Icy Caldera of Mauldoon"] = "caldera",
    ["The Imperial City of Reme"] = "reme",
    ["The Infestation"] = "infest",
    ["The Keep of Kearvek"] = "kearvek",
    ["The Killing Fields"] = "fields",
    ["The Labyrinth"] = "labyrinth",
    ["The Land of Oz"] = "landofoz",
    ["The Land of the Beer Goblins"] = "beer",
    ["The Lower Planes"] = "lplanes",
    ["The Maelstrom"] = "maelstrom",
    ["The Marshlands of Agroth"] = "agroth",
    ["The Misty Shores of Yarr"] = "yarr",
    ["The Monastery"] = "monastery",
    ["The Mountains of Desolation"] = "desolation",
    ["The Nine Hells"] = "ninehells",
    ["The Nyne Woods"] = "nynewoods",
    ["The Old Cathedral"] = "cathedral",
    ["The Palace of Song"] = "songpalace",
    ["The Partroxis"] = "partroxis",
    ["The Path of the Believer"] = "believer",
    ["The Realm of Infamy"] = "infamy",
    ["The Realm of the Hawklords"] = "hawklord",
    ["The Relinquished Tombs"] = "tombs",
    ["The Reman Conspiracy"] = "remcon",
    ["The Ruins of Diamond Reach"] = "ruins",
    ["The Ruins of Stormhaven"] = "stormhaven",
    ["The Sanguine Tavern"] = "sanguine",
    ["The Scarred Lands"] = "scarred",
    ["The School of Horror"] = "soh",
    ["The Shadows of Minos"] = "minos",
    ["The Silver Volcano"] = "volcano",
    ["The Slaughter House"] = "slaughter",
    ["The Southern Ocean"] = "southern",
    ["The Stuff of Shadows"] = "stuff",
    ["The Temple of Shal'indrael"] = "temple",
    ["The Temple of Shouggoth"] = "shouggoth",
    ["The Three Pillars of Diatz"] = "diatz",
    ["The Titans' Keep"] = "titan",
    ["The Tournament of Illoria"] = "illoria",
    ["The Town of Solan"] = "solan",
    ["The Tree of Life"] = "tol",
    ["The Trouble with Gwillimberry"] = "gwillim",
    ["The Uncharted Oceans"] = "uncharted",
    ["The UnderDark"] = "underdark",
    ["The Upper Planes"] = "uplanes",
    ["The Uprising"] = "uprising",
    ["The Were Wood"] = "werewood",
    ["The Witches of Omen Tor"] = "omentor",
    ["The Wobbly Woes of Woobleville"] = "wooble",
    ["The Wood Elves of Nalondir"] = "woodelves",
    ["The Yurgach Domain"] = "yurgach",
    ["Tilule Rehabilitation Clinic"] = "tilule",
    ["Tir na nOg"] = "tirna",
    ["Tournament Camps"] = "camps",
    ["Transcendece"] = "transcend",
    ["Tribal Origins"] = "origins",
    ["Tumari's Diner"] = "diner",
    ["Umari's Castle"] = "umari",
    ["Unearthly Bonds"] = "bonds",
    ["Verdure Estate"] = "verdure",
    ["Vidblain, the Ever Dark"] = "vidblain",
    ["War of the Wizards"] = "wizards",
    ["Warrior's Training Camp"] = "wtc",
    ["Wayward Alehouse"] = "alehouse",
    ["Weather Observatory"] = "weather",
    ["Wedded Bliss"] = "bliss",
    ["Wildwood"] = "wildwood",
    ["Winds of Fate"] = "winds",
    ["Winterlands"] = "winter",
    ["Xyl's Mosaic"] = "xylmos",
    ["Yggdrasil: The World Tree"] = "ygg",
    ["Zangar's Demonic Grotto"] = "zangar",
    -- New areas
    ["The Keep of the Asherodan"] = "asherodan",
    ["Bloodlust Dungeon"] = "dungeon"
}

-- 	[[ Lookup table: Game calendar data]]
local gCalendar = {}

--	[[ Load saved table data ]]
function load_saved_table_data()
    load_area_start_rooms()
    load_area_range_index()
end

function load_area_start_rooms()
    if (GetVariable("mcvar_areaStartRooms") ~= nil) then
        code = "obj = " .. GetVariable("mcvar_areaStartRooms")
        assert(loadstring(code or ""))()
        area_start_rooms = obj
    end
end

function load_area_range_index()
    send_gmcp_packet("request room")
    if (GetVariable("mcvar_area_range") ~= nil) then
        code = "obj = " .. GetVariable("mcvar_area_range")
        assert(loadstring(code or ""))()
        area_range_index = obj
        do_cp_info()
    else
        area_index_process()
    end
end

--	[[ Area index process ]]
function area_index_process()
    DebugNote("Processing area index")
    Execute("xset suspend page size")
    DoAfterSpecial(0.1, [[ SendNoEcho("areas 1 300 keyword") ]], sendto.script)
end

function area_index_start() -- called by trigger for "Showing areas from 0 to 300" line at start of areas list.
    area_range_index = {}
    InfoNote("*** Indexing area levels")
end

function area_index_line(name, line, wildcards) -- 1055
    SnDdb = assert(sqlite3.open(GetInfo(66) .. "/SnDdb.db"))
    local sqlQuery = 'INSERT INTO area VALUES ("%s", "%s", "%d", "%d", "%d", "%d", "%s", "%s", "%s")'

    local areaName = Trim(wildcards.areaName)
    local arid = Trim(wildcards.arid)
    if not areaDefaultStartRooms[arid] then
        areaDefaultStartRooms[arid] = {start = "-1", noquest = false}
    end
    local minLvl = tonumber(Trim(wildcards.min)) or 1
    local maxLvl = tonumber(Trim(wildcards.max)) or 201
    local levelLock = tonumber(Trim(wildcards.lock)) or 0
    local noQuest = (areaDefaultStartRooms[arid].noquest == true and "true") or "false"
    local vidblain = (tostring(areaDefaultStartRooms[arid].vidblain) == true and "true") or "false"

    if arid == "sahuagin" then
        areaName = "The Abyssal Caverns of Sahuagin"
    elseif arid == "darkside" then
        areaName = "The Darkside of the Fractured Lands"
    elseif arid == "academy" or arid == "lowlands" then
        maxLvl = 10
    elseif arid == "sohtwo" then
        minLvl = 170
    end

    area_range_index[areaName] = {arid = arid, min = minLvl, max = maxLvl} -- lock = levelLock }

    local queryExists = "SELECT * FROM area WHERE name LIKE '%s'"

    local areaExists = false

    for a in SnDdb:rows(queryExists:format(areaName:gsub("'", "''"))) do
        if a[1] then
            areaExists = true
            break
        end
    end

    if not areaExists then
        if areaDefaultStartRooms[arid] then
            sqlQuery =
                sqlQuery:format(
                areaName,
                arid,
                minLvl,
                maxLvl,
                levelLock,
                areaDefaultStartRooms[arid].start,
                noQuest,
                vidblain,
                arid
            )
        else
            sqlQuery = sqlQuery:format(areaName, arid, minLvl, maxLvl, levelLock, -1, noQuest, vidblain, arid)
            ErrorNote("*** Missing default start room - ", areaName)
            ErrorNote("*** Please update by manually running to the area and using '", "xset mark", "'.")
        end

        SnDdb:exec(sqlQuery)
    end

    SnDdb:close()
end

function area_index_end(name, line, wildcards)
    set_variable("mcvar_area_range", serialize.save_simple(area_range_index))
    InfoNote("\n*** Area levels indexed!")
    Execute("xset resume page size")
    DoAfterSpecial(0.1, "cp info", sendto.execute)
end

--	[[ Guess mob keywords ]]
local gmkw_omit = {["a"] = "", ["an"] = "", ["and"] = "", ["of"] = "", ["or"] = "", ["some"] = "", ["the"] = ""}
local gmkw_area_filters = {
    ["adaldar"] = {{f = "^.*(el)vish (%a*%s?%a+)$", g = "%1 %2"}},
    ["bonds"] = {{f = "^(.*[bgry]%a+) dragon$", g = "%1"}},
    ["citadel"] = {{f = "^([bgjlmsv]%a+) ([ap]r%a+[el]) .+$", g = "%1 %2"}},
    ["elemental"] = {
        {f = "^(%a+)%'(%a+) (%a+)$", g = "%1%2 %3"},
        {f = "^wandering (%a+)%'(%a+) (%a+)$", g = "%1%2 %3"}
    },
    ["hatchling"] = {
        {f = "^(%a+) dragon (egg)$", g = "%1 %2"},
        {f = "^(%a+) dragon (hatchling)$", g = "%1 %2"},
        {f = "^(%a+ %a+) dragon whelp$", g = "%1"},
        {f = "^(%a+) dragon (whelp)$", g = "%1 %2"}
    },
    ["sirens"] = {{f = "^miss ([%a']+)%s?(%a*).*%a$", g = "%1 %2"}},
    ["sohtwo"] = {
        {f = "^(evil) %a+", g = "%1"},
        {f = "^(good) %a+", g = "%1"}
    },
    ["verume"] = {{f = "^lizardman (temple %a+)$", g = "%1"}},
    ["wooble"] = {
        {f = "^sea (%a+)$", g = "%1"},
        {f = "^sea (%a+ %a+)$", g = "%1"}
    }
}

local gmkw_exceptions = {
    ["aardington"] = {["a very large portrait"] = {kw = "large port"}},
    ["alehouse"] = {
        ["a dancing male patron"] = {kw = "dancing male"},
        ["a dancing female patron"] = {kw = "dancing female"}
    },
    ["anthrox"] = {
        ["the little white rabbit"] = {kw = "rabb"},
        ["the bee"] = {kw = "worker bee"},
        ["an escaped creature"] = {kw = "prisoner creature"},
        ['a "business" man'] = {kw = "business man"}
    },
    ["ddoom"] = {
        ["a dangerous scorpion"] = {kw = "scorp"},
        ["Lwji, the Sunrise great warrior"] = {kw = "lwji"},
        ["Taji, the Sunset leader"] = {kw = "taji lead"},
        ["Taji's personal advisor"] = {kw = "pers advi"},
        ["Tjac, the Sunrise leader"] = {kw = "tjac lead"},
        ["Tjac's personal advisor"] = {kw = "sunr advis"},
        ["Yki, the great Sunset warrior"] = {kw = "yki"}
    },
    ["deneria"] = {["High Priest of Miad'Bir"] = {kw = "high miad"}},
    ["desert"] = {["a village citizen"] = {kw = "citi"}},
    ["fields"] = {["a mutated goat"] = {kw = "goat"}},
    ["fortress"] = {
        ["a grizzled goblin dressed in skins"] = {kw = "grizz gobl"},
        ["Blood Silk, Collector of souls, Queen of the spiders"] = {kw = "silk queen"}
    },
    ["hell"] = {
        ["a scrumptious chicken pot pie"] = {kw = "chicken pot pie"},
        ["a yummy vegetable pot pie"] = {kw = "vegetable pot pie"},
        ["a yummy beef pot pie"] = {kw = "beef pot pie"}
    },
    ["illoria"] = {["the King and Queen's Guard"] = {kw = "pers guard"}},
    ["landofoz"] = {["one of Dorothy's uncles"] = {kw = "doroth uncle"}},
    ["laym"] = {["an elite guard of the church"] = {kw = "elit guar"}},
    ["livingmine"] = {
        ["a member of the 'Cal tribe"] = {kw = "memb cal"},
        ["a member of the 'Sorr tribe"] = {kw = "memb sorr"},
        ["a member of the 'Tai tribe"] = {kw = "memb tai"},
        ["Dak'tai's shaman"] = {kw = "dakt shama"},
        ["the 'Tai chieftain"] = {kw = "tai chief"}
    },
    ["longnight"] = {["Mr. Roberge"] = {kw = "car rober"}},
    ["losttime"] = {
        ["T-Rex"] = {kw = "T-rex"},
        ["Great White Shark"] = {kw = "white shark"}
    },
    ["manor"] = {
        ["Aremata-Popua"] = {kw = "aremata-pop"},
        ["Aremata-Rorua"] = {kw = "aremata-ror"}
    },
    ["masq"] = {
        ["a gentleman on the way to the ball"] = {kw = "gentl"},
        ["a very attractive woman"] = {kw = "attr woman"}
    },
    ["necro"] = {["the head necromancer's assistant"] = {kw = "old mage assist"}},
    ["northstar"] = {
        ["a Blood Ring elite warrior"] = {kw = "elit warr"},
        ["Daryoon, a priest of nature"] = {kw = "dary pries"},
        ["Tristam, the Prince of the Orcs"] = {kw = "trist orc"}
    },
    ["sanctity"] = {["a half-converted human"] = {kw = "human"}},
    ["siege"] = {
        ["a kobold eating lunch"] = {kw = "kobold eating"},
        ["a large mole"] = {kw = "mole"},
        ["a very large firefly"] = {kw = "larg firef"},
        ["the fattest kobold ever"] = {kw = "fat kobold"},
        ["an oddly tall and clean kobold"] = {kw = "tall kobold"}
    },
    ["snuckles"] = {["the snuckle"] = {kw = "male snuckle"}},
    ["sohtwo"] = {
        ["An evil form of Sagen"] = {kw = "notcarlsagen"},
        ["Angelic Demonspawn"] = {kw = "angelic"},
        ["Bubbly Obyron"] = {kw = "fuzzybunny"},
        ["Dejected Broud"] = {kw = "dejected"},
        ["Disagreeable Rumour"] = {kw = "obstinate"},
        ["Disoriented Dadrake"] = {kw = "letsturnlefthere"},
        ["Evil Aaeron"] = {kw = "shinythings"},
        ["Evil Althalus"] = {kw = "homeskillet"},
        ["Evil Belmont"] = {kw = "bridgetroll"},
        ["Evil Domain"] = {kw = "66"},
        ["Evil Euphonix"] = {kw = "ragbrai"},
        ["Evil Ghaan"] = {kw = "longghaan"},
        ["Evil Halo"] = {kw = "jackandcoke"},
        ["Evil Ikyu"] = {kw = "ickypoo"},
        ["Evil Justme"] = {kw = "helperisme"},
        ["Evil Kharpern"] = {kw = "kittyimm"},
        ["Evil KlauWaard"] = {kw = "tricksy"},
        ["Evil Kt"] = {kw = "ktkat"},
        ["Evil Lasher"] = {kw = "thearchitect"},
        ["Evil Madcatz"] = {kw = "mathizard"},
        ["Evil Maerchyng"] = {kw = "maerchyng"},
        ["Evil Morrigu"] = {kw = "morrigu"},
        ["Evil OrcWarrior"] = {kw = "sheepshagger"},
        ["Evil Pane"] = {kw = "painintheneck"},
        ["Evil Plaideleon"] = {kw = "crazycanadian"},
        ["Evil Rekhart"] = {kw = "hartsawreck"},
        ["Evil Sarlock"] = {kw = "l33td00d"},
        ["Evil Tela"] = {kw = "telllllllla"},
        ["Evil Timeghost"] = {kw = "floppyimm"},
        ["Good Tripitaka"] = {kw = "laketripitaka"},
        ["Evil Tymme"] = {kw = "hourglass"},
        ["Evil Vladia"] = {kw = "sexyvamp"},
        ["Evil Whitdjinn"] = {kw = "thundercat"},
        ["Evil Windjammer"] = {kw = "justsomeimm"},
        ["Evil Wolfe"] = {kw = "likeobybutbritish"},
        ["Evil Xyzzy"] = {kw = "weirdcode"},
        ["Good Aerianne"] = {kw = "pointyears"},
        ["Good Cadaver"] = {kw = "newbiehater"},
        ["Good Delight"] = {kw = "turkishdelight"},
        ["Good Dirtworm"] = {kw = "wormy"},
        ["Good Eclaboussure"] = {kw = "dropbearimm"},
        ["Good Filt"] = {kw = "plainolefilt"},
        ["Good Glimmer"] = {kw = "betterhalfofclaire"},
        ["Good Kinson"] = {kw = "upgradeboy"},
        ["Good Lumina"] = {kw = "thievesrus"},
        ["Good Oladon"] = {kw = "spellingbee"},
        ["Good Rhuli"] = {kw = "rulistheworld"},
        ["Good Sausage"] = {kw = "fatbreakfast"},
        ["Good Sirene"] = {kw = "warriorprincess"},
        ["Good Takihisis"] = {kw = "dragonlady"},
        ["Good Terrill"] = {kw = "askcitron"},
        ["Good Tyanon"] = {kw = "tieoneon"},
        ["Good Valkur"] = {kw = "demonlord"},
        ["Good Vilgan"] = {kw = "unabridged"},
        ["Good Xantcha"] = {kw = "pokerimm"},
        ["Good Zane"] = {kw = "inzanity"},
        ["Goodie Goodie Jaenelle"] = {kw = "goodie"},
        ["Impatient Styliann"] = {kw = "willyouhurryup"},
        ["Kinda-Sorta Good Whisper"] = {kw = "kinda"},
        ["Master Shen"] = {kw = "master"},
        ["Mathematical Mordist"] = {kw = "complex"},
        ["Nascaard Rezit"] = {kw = "nascaard"},
        ["Pandemonium Penthesilea"] = {kw = "pandemonium"},
        ["Record Holding Guinness"] = {kw = "cantwriteatall"},
        ["Singing Paramore"] = {kw = "failedmusician"},
        ["Sith Lord Neeper"] = {kw = "sith"},
        ["Smurfy Laren"] = {kw = "lovethemsmurfs"},
        ["Sober Citron"] = {kw = "sober"},
        ["Socialite Arthon"] = {kw = "airhead"},
        ["Straight Dreamfyre"] = {kw = "straight"},
        ["The cool version of Xeno"] = {kw = "onex"},
        ["The Pancake Flat"] = {kw = "pancake"},
        ["Tjopping Quadrapus"] = {kw = "tjopping"},
        ["Unhelpful Claire"] = {kw = "cookies"},
        ["Unremarkable Korridel"] = {kw = "unremarkable"},
        ["Unrestrained Elvandar"] = {kw = "omgsheneverstopstalking"},
        ["Warsnail Anaristos"] = {kw = "warsnail"},
        ["Cuddlebear Koala"] = {kw = "cuddlebear"},
        ["(Helper) Fenix"] = {kw = "helper"}
    },
    ["snuckles"] = {["Sarah, the grieving snuckle"] = {kw = "sarah griev"}},
    ["stone"] = {["a Citadel of Stone Cityguard"] = {kw = "cit guar"}},
    ["talsa"] = {["a dwarven mercenary"] = {kw = "dwar merc"}},
    ["wooble"] = {["the Sea Snake Master-at-Arms"] = {kw = "snake mast"}},
    ["yarr"] = {
        ["a pirate sorting the treasure"] = {kw = "pirat sort"},
        ["a pirate stealing some treasure"] = {kw = "pirat steal"}
    },
    ["zoo"] = {["a black-footed pine marten"] = {kw = "pine marte"}}
}

function populate_mob_keyword_table(db)
    local inserts = {}
    for area, mob_keywords in pairs(gmkw_exceptions) do
        for mob_name, keyword in pairs(mob_keywords) do
            local str =
                string.format(
                "INSERT INTO mob_keyword_exceptions VALUES (%s,%s,%s);",
                fixsql(area),
                fixsql(mob_name),
                fixsql(keyword["kw"])
            )
            table.insert(inserts, str)
        end
    end
    execute_in_transaction(db, inserts)
    db:execute(table.concat(inserts, ""))
end

function set_mob_keyword(name, line, wildcards)
    local current_area = current_room.arid
    local area_list = {}
    local db = assert(sqlite3.open(mapper_db_file))
    local i
    local area
    local mob_name
    local keyword

    for row in db:nrows("SELECT uid FROM areas ORDER BY uid ASC") do
        area_list[row.uid] = row.uid
    end

    db:close_vm()

    area = utils.choose("Area", "Please choose the mob's area.", area_list, current_area)
    if not area then
        return
    end

    function require_input(input)
        return #Trim(input) > 0
    end

    mob_name =
        utils.inputbox(
        "Enter the mob's full name.\nFor example: a yummy beef pot pie",
        "Enter mob name",
        nil,
        nil,
        0,
        {validate = require_input}
    )
    if not mob_name then
        return
    end
    mob_name = Trim(mob_name)

    keyword =
        utils.inputbox(
        string.format("Enter the new keyword for '%s'.\nFor example: beef pie", mob_name),
        "Enter new keyword",
        nil,
        nil,
        0,
        {validate = require_input}
    )
    if not keyword then
        return
    end
    keyword = Trim(keyword)

    if save_mob_keyword_keyword(area, mob_name, keyword) then
        if has_activity_target() and current_target.name == mob_name then
            update_target_keyword(keyword)
        end
        update_main_target_list_keyword(area, mob_name, keyword)
    end
end

function set_current_mob_keyword(name, line, wildcards)
    local keyword = Trim(wildcards.keyword)
    local area

    if has_activity_target() then
        if not current_target.area then
            InfoNote(
                "\nSearch and Destroy: Target's area could not be identified. Try visiting its area and trying again."
            )
            return
        end

        if save_mob_keyword_keyword(current_target.area, current_target.name, keyword) then
            update_target_keyword(keyword)
            update_main_target_list_keyword(current_target.area, current_target.name, keyword)
        end
    else
        InfoNote(
            "\nSearch and Destroy: 'kw' has no target.  Use 'xcp' to select a target, or use 'xset kw' with no arguments."
        )
    end
end

function update_main_target_list_keyword(area, mob_name, keyword)
    for i, mobdesc in ipairs(main_target_list) do
        if area == mobdesc.arid and mob_name == mobdesc.mob then
            mobdesc.kw = keyword
        end
    end
end

function save_mob_keyword_keyword(area, mob_name, keyword)
    local found_area = false
    local query

    local db = assert(sqlite3.open(snd_db_file))
    query =
        string.format(
        "INSERT OR REPLACE INTO mob_keyword_exceptions VALUES (%s,%s,%s);",
        fixsql(area),
        fixsql(mob_name),
        fixsql(keyword)
    )
    db:exec(query)
    db:close_vm()

    InfoNote("Updated keyword for ", mob_name, " to ", keyword, " in area ", area .. "\n")
    return true
end

function gmkw(s, a) -- guess mob keywords
    if not s then
        return ""
    end
    local ri = current_room
    local ar = a or ri.zone
    local guess

    local db = sqlite3.open(snd_db_file)
    query =
        string.format(
        "SELECT keyword FROM mob_keyword_exceptions WHERE area_name = %s AND mob_name = %s LIMIT 1;",
        fixsql(ar),
        fixsql(s)
    )
    for row in db:nrows(query) do
        guess = row.keyword
    end
    db:close_vm()

    if guess then
        DebugNote("Found custom keyword for '", s, "': ", guess)
        return guess
    end

    local omit = gmkw_omit
    local s1 = {}
    for w in string.gmatch(string.lower(s), "[^ ]+") do
        w = string.gsub(w, "%p%-", "")
        w = string.gsub(w, ",", "")
        w = string.gsub(w, "%.", "")
        w = string.gsub(w, "'s$", "")
        w = string.gsub(w, "[!?]+$", "")
        table.insert(s1, w)
    end

    local s2
    for i, v in ipairs(s1) do
        if omit[v] then
            -- do nothing
        else
            s2 = (s2 == nil) and v or s2 .. " " .. v
        end
    end

    local s3
    if gmkw_area_filters[ar] then
        for i, v in ipairs(gmkw_area_filters[ar]) do
            s3 = string.gsub(s2, v.f, v.g)
            if (s3 ~= s2) then
                break
            end
        end
    else
        s3 = s2
    end
    s3 = string.gsub(s3, "-", " ")

    local s4 = {}
    for w in string.gmatch(s3, "[^ ]+") do
        table.insert(s4, w)
    end
    local len1 = #(s4[1])
    local len2 = #(s4[#s4]) or 0
    if (#s4 > 1) then -- mob name has multiple words
        local x, y = math.random(4, 6), math.random(4, 6)
        guess = string.sub(s4[1], 1, x) .. " " .. string.sub(s4[#s4], 1, y)
    elseif (#s4 == 1) then -- mob name has one word
        local x = math.random(2 + round_banker(len1 * 0.5), len1)
        guess = string.sub(s4[1], 1, x)
    else -- Sometimes all of the mob words get deleted, if so just use original input.  In theory, if we reached this step
        guess = s or "gmkw error in stage 4" -- then the input is non-nil and I've never seen it be "" ... so, if it errors it means Lua is propagating a nil
    end
     -- somehow or doing one of the other mickey mouse nonsense things that Lua likes to do.
    return guess
end

function target_matches_current_target(target, index)
 --   if not current_target.name then
	if not current_target then
        return false
    elseif target.mob ~= current_target.name then
        return false
    elseif target.roomName ~= current_target.room_name then
        return false
    elseif target.arid ~= current_target.area then
        return false
    elseif current_activity ~= current_target.activity then
        return false
    elseif index and index ~= current_target.index then
        return false
    else
        return true
    end
end

function set_target_from_main_target_list(index, keyword)
    local target = main_target_list[index]
    local activity = current_activity
    if activity == "none" then
        activity = nil
    end
    keyword = keyword or target.kw

    change_target(
        {
            name = target.mob,
            keyword = keyword,
            room_name = target.roomName,
            index = index,
            area = target.arid,
            activity = current_activity
        }
    )
end

function set_target_from_quest(quest_target)
    change_target(
        {
            name = quest_target.mob,
            keyword = gmkw(quest_target.mob, quest_target.arid),
            room_name = quest_target.room,
            area = quest_target.arid,
            activity = "quest"
        }
    )
end

function set_adhoc_target(keyword)
    change_target(
        {
            keyword = keyword,
            area = current_room.arid
        }
    )
end

function clear_target()
    change_target(nil)
end

-- Function that should be called whenever the target changes. This will
-- broadcast to other plugins that the target has changed.
function change_target(new_target)
    if are_targets_identical(current_target, new_target) then
        DebugNote("Attempted to change target to the same target")
        return
    end

    current_target = new_target
    if new_target then
        DebugNote("Emitting target changed event. Target is now ", target_as_json())
        BroadcastPlugin(1, "target_changed")
    else
        DebugNote("Emitting target cleared event. Target is now ", target_as_json())
        BroadcastPlugin(2, "target_cleared")
    end
end

function update_target_keyword(new_keyword)
    if not current_target then
        return
    end

    current_target.keyword = new_keyword
    DebugNote("Emitting keyword changed event. Target is now ", target_as_json())
    BroadcastPlugin(3, "keyword_changed")
end

-- function intended to be called from other plugins to get the current target
function target_as_json()
    return json.encode(current_target)
end

function are_targets_identical(old_target, new_target)
    if old_target == new_target then
        return true
    elseif not old_target or not new_target then
        return false
    end

    for k, v in pairs(old_target) do
        if v ~= new_target[k] then
            return false
        end
    end

    for k, v in pairs(new_target) do
        if v ~= old_target[k] then
            return false
        end
    end

    return true
end

--	[[ Detect campaign (or gquest) type - area or room ]]
function area_room_type_check(list)
    local areaCount = 0
    local roomCount = 0
    local ar_rm
    for i, v in ipairs(list) do
        if areaNameXref[v.loc] then
            areaCount = areaCount + 1
        else
            roomCount = roomCount + 1
        end
    end
    if (areaCount >= roomCount) then
        ar_rm = "area"
    else
        ar_rm = "room"
    end
    return ar_rm
end

--	[[ Quest target process ]]
function xq_command() -- enables 'xq' command (reload quest info)
    send_gmcp_packet("request quest")
end

function retarget_quest()
    if has_active_quest() then
        target_quest_mob(true)
        xg_draw_window()
    elseif quest_target.qstat == "3" then
        InfoNote("\nSearch and Destroy: You have already killed your quest target!\n")
    else
        InfoNote("\nSearch and Destroy: You are not on a quest.\n")
    end
end

function target_quest_mob(bool) -- Re-targets your quest mob if you un-target it somehow (xcp, etc.)
    local qt = quest_target
    xcp_clear_target(true)
    qw_reset(false)
    if (qt.mob == "missing") and (qt.arid == nil) and (qt.areaName == nil) and (qt.room == nil) then
        qt.mob = GetVariable("mcvar_qt_mob")
        qt.arid = GetVariable("mcvar_qt_arid")
        qt.areaName = GetVariable("mcvar_qt_areaName")
        qt.room = GetVariable("mcvar_qt_mob")
        if (bool == true) then
            InfoNote(
                "\n'Target quest mob' (xq) not done - the mob is currently dead, or you can't see it (check detects)."
            )
            InfoNote("\n'The last known location, before it went missing, was:\n")
            InfoNote("mob : ", qt.mob .. " ")
            InfoNote("area: ", qt.areaName .. " (" .. qt.arid .. ")")
            InfoNote("room: ", qt.room)
        end
    else
        set_target_from_quest(qt)
        set_variable("mcvar_qt_mob", qt.mob)
        set_variable("mcvar_qt_arid", qt.arid)
        set_variable("mcvar_qt_areaName", qt.areaName)
        set_variable("mcvar_qt_room", qt.room)
        if (bool == true) then
            InfoNote("\nYour quest mob is: \n")
            InfoNote("mob : ", qt.mob .. " ")
            InfoNote("area: ", qt.areaName .. " (" .. qt.arid .. ")")
            InfoNote("room: ", qt.room)
        end
    end
    search_rooms_exact(qt.room, qt.arid, qt.mob)
end

function quest_status_gmcp(q) -- sets quest status when you take a new quest, kill qmob, complete quest, etc.
    local quest_time = q.wait or q.timer
    if quest_time then
        next_quest_time = os.time() + quest_time * 60
        DebugNote("Quest time: ", quest_time)
    end
    if (q.action == "start") then -- you've just taken a new quest
        quest_target = {
            qstat = "2",
            mob = q.targ,
            areaName = q.area,
            arid = areaNameXref[q.area] or q.area,
            room = (string.gsub(q.room, "@[bcgmrwyBCDGMRWY]", ""))
        }
        target_quest_mob(true)
    elseif (q.action == "status" and q.targ and q.timer) then -- on quest, qmob not yet killed
        quest_target = {
            qstat = "2",
            mob = q.targ,
            areaName = q.area,
            arid = areaNameXref[q.area] or q.area,
            room = (string.gsub(q.room, "@[bcgmrwyBCDGMRWY]", ""))
        }
        target_quest_mob(true)
    else
        if (q.action == "killed") then -- you've just killed the target
            --elseif (q.action == "start") then	-- you've just taken a new quest
            --	quest_target = { qstat = "2", mob = q.targ,	areaName = q.area, arid = areaNameXref[q.area], room = (string.gsub(q.room, "@[bcgmrwyBCDGMRWY]", "")) }
            --	target_quest_mob(true)
            quest_target.qstat = "3"
        elseif (q.action == "comp") or (q.action == "fail") or (q.action == "reset") then -- quest has ended (completed, failed, or reset)
            quest_target = {qstat = "1"}
            xcp_clear_target(false)
            qw_reset(false)
        elseif (q.action == "ready") or (q.action == "timeout") then -- can take new quest immediately
            -- in all of these, the action is "status"
            quest_target = {qstat = "0"}
            next_quest_time = os.time()
        elseif (q.action == "status" and q.target == "killed") then -- on quest, qmob has been killed (do not confuse q.target with q.targ above!)
            --elseif (q.action == "status" and q.targ and q.timer) then		-- on quest, qmob not yet killed
            --	quest_target = { qstat="2", mob = q.targ, areaName = q.area, arid = areaNameXref[q.area], room = (string.gsub(q.room, "@[bcgmrwyBCDGMRWY]", "")) }
            --	target_quest_mob(true)
            quest_target.qstat = "3"
            InfoNote("\nSearch and Destroy: You have already killed your quest target!\n")
        elseif (q.action == "status" and (q.wait)) then -- off quest, must wait before requesting new
            quest_target = {qstat = "1"}
            InfoNote("\nSearch and Destroy: Not on quest - must wait before requesting new.\n")
        elseif (q.action == "status" and q.status == "ready") then -- off quest, can request new quest immediately
            next_quest_time = os.time()
            quest_target = {qstat = "0"}
            InfoNote("\nSearch and Destroy: Not on quest - can request new quest immediately. \n")
        end
        set_variable("mcvar_qt_mob", "")
        set_variable("mcvar_qt_arid", "")
        set_variable("mcvar_qt_areaName", "")
        set_variable("mcvar_qt_room", "")
        if is_quest_mob_targeted() then
            clear_target()
        end
    end
    quest_timer_tick()
    xg_draw_window()
end

--	[[ "cp info" process path ]]
function do_cp_info()
    cp_info_list = {}
    main_target_list = {}
    room_targets_ignored = {}
    EnableTrigger("trg_cp_info_level_taken", true)
    EnableTrigger("trg_cp_info_targets", true)
    SendNoEcho("cp info")
    xg_draw_window() -- redraw window during latency period between sending the command and receiving a response, which would otherwise be 'dead' time.
end

function cp_info_level_taken(name, line, wildcards)
    local x = tonumber(wildcards.level)
    cp_info_level = x
    set_variable("mcvar_cp_level_taken", x)
end

function cp_info_line(name, line, wildcards)
    local mob, loc = parse_mob_target(wildcards.target)
    table.insert(cp_info_list, {mob = mob, loc = loc})
end

function cp_info_end()
    player_on_cp = "yes"
    current_activity = "cp"
    local t = cp_info_list
    area_room_type = area_room_type_check(t)
    print("cp type detection: " .. area_room_type .. " (level " .. cp_info_level .. ")\n")
    xg_draw_window()
    DoAfterSpecial(0.1, [[ do_cp_check() ]], sendto.script)
end

--	[[ "cp check" process path ]]
function do_cp_check()
    local time_check = os.clock() -- prevent double cp checks from different plugins
    if ((time_check - last_cp_check) < 1.0) then
        return
    end
    last_cp_check = time_check
    cp_check_list = {}
    EnableTrigger("trg_cp_check_line", true)
    SendNoEcho("cp ch")
end

function cp_check_line(name, line, wildcards)
    local mob, loc, is_dead = parse_mob_target(wildcards.target)
    table.insert(cp_check_list, {mob = mob, qty = 1, loc = loc, is_dead = is_dead})
end

function cp_check_end(name, line, wildcards)
    player_on_cp = "yes"
    current_activity = "cp"
    build_main_target_list("cp", area_room_type)
    xcp_retry()
end

--	[[ general cp status functions ]]
function player_start_new_cp() -- called by line "good luck on your campaign" when starting new cp
    player_on_cp = "yes"
    can_get_new_cp = "no"
    local x = tonumber(gmcp("char.status.level"))
    cp_info_level = x
    current_activity = "cp"
    xg_draw_window()
    if (noexp_onoff == "on") and (anex_tnl_cutoff > 0) then
        InfoNote("Search and Destroy: Turning 'noexp' OFF (you have started a new CP)")
        anex_set_noexp("off")
    end
    do_cp_info()
end

function cp_mob_killed()
    if current_activity ~= "gq" then
        xcp_retry_stat = 1
        qw_reset(false)
        last_kill_index = get_last_kill_index()
        if last_kill_index and main_target_list[last_kill_index] then
            main_target_list[last_kill_index].is_dead = "yes"
            record_target_killed(main_target_list[last_kill_index])
        end
        if is_cp_mob_targeted() then
            if current_target.index == last_kill_index then
                xcp_clear_target(false)
            end
        end
        xg_draw_window()

        DoAfterSpecial(0.1, "do_cp_check()", 12)
    else
        DebugNote("Skipping cp update because current activity is ", current_activity)
    end
end

function get_last_kill_index()
    for i, target in ipairs(main_target_list) do
        DebugNote("comparing ", last_mob_killed, " (", current_room.arid, ") to ", target.mob, " (", target.arid, ")")
        if current_room.arid == target.arid and last_mob_killed == target.mob then
            DebugNote("killed mob is number ", i)
            return i
        end
    end
    DebugNote("Couldn't find last mob kill on target list")
    return nil
end

function record_target_killed(target)
    -- a mob was killed as part of a cp/gq
    queries = {
        string.format(
            [[
				INSERT OR IGNORE INTO mobs (mob,room,roomid,zone)
				VALUES (%s,%s,%s,%s);
			]],
            fixsql(target.mob),
            fixsql(current_room.name),
            tonumber(current_room.rmid),
            fixsql(current_room.arid)
        ),
        string.format(
            [[
				UPDATE mobs
				SET kill_count = kill_count + 1
				WHERE mob = %s AND roomid = %i;
			]],
            fixsql(target.mob),
            tonumber(current_room.rmid)
        )
    }
    local db = assert(sqlite3.open(snd_db_file))
    execute_in_transaction(db, queries)
    DebugNote("Increment mob kill count for ", target.mob, " in room ", current_room.rmid)
    db:close_vm()
end

function player_level_up()
    can_get_new_cp = "yes"
    xg_draw_window()
end

function player_is_on_cp()
    player_on_cp = "yes"
end

function do_cp_complete(name, line, wildcards)
    DebugNote("Campaign complete")
    player_not_on_cp()
end

function player_not_on_cp()
    DebugNote("Called player_not_on_cp")
    player_on_cp = "no"
    EnableTriggerGroup("trg_campaign", false)
    cp_info_level = "0"
    set_variable("mcvar_cp_level_taken", "0")
    cp_info_list = {}
    cp_check_list = {}
    if (player_on_gq == "yes") then
        -- do nothing, we don't want to clear our gq info
        DebugNote("Still on gq, not clearing target list")
    else
        DebugNote("Not on gq, clearing target list")
        main_target_list = {}
        room_targets_ignored = {}
        area_room_type = "none"
        current_activity = "none"
        if is_cp_or_gq_mob_targeted() then
            clear_target()
        end
        xg_draw_window()
    end
end

function cp_check_can_get_new_cp()
    can_get_new_cp = "yes"
    anex_can_get_new_cp()
    xg_draw_window()
end

function cp_check_cannot_get_new_cp()
    can_get_new_cp = "no"
    anex_must_level_new_cp()
    xg_draw_window()
end

function can_player_get_new_cp()
    return (can_get_new_cp == "yes") and true or false
end

--	[[ Gquest beginning event messages: declare, join, start ]]
function gqmsg_joined(name, line, wildcards)
    gqid_joined = wildcards.gq_id

    set_variable("mcvar_gqid_joined", gqid_joined)
    DebugNote("Joined gq ", gqid_joined, " gqid_started ", gqid_started)
    if (gqid_joined == gqid_started) then
        EnableTriggerGroup("trg_gqmsg", true)
        do_gq_info()
    end
end

function gqmsg_info_num(name, line, wildcards)
    gqid_joined = wildcards.gq_id
    set_variable("mcvar_gqid_joined", gqid_joined)
end

function gqmsg_started(name, line, wildcards)
    gqid_started = wildcards.gq_id
    set_variable("mcvar_gqid_started", gqid_started)
    if (gqid_started == gqid_joined) then
        EnableTriggerGroup("trg_gqmsg", true)
        do_gq_info()
    end
end

--	[[ Gquest info functions ]]
function do_gq_info()
    if (gqid_joined ~= "-1") then
        xcp_clear_target(false)
        main_target_list = {}
        room_targets_ignored = {}
        gq_info_list = {}
        send_gq_info(gqid_joined)
    else
        send_gq_info()
    end
end

function send_gq_info(gqid)
    if debug_gq_mode then
        simulate_send_gq_info(gqid)
    elseif gqid then
        SendNoEcho("gq info " .. gqid)
    else
        SendNoEcho("gq info")
    end
end

function gq_info_quest_name(name, line, wildcards)
    local gqid = wildcards.gq_id
    potential_gq = {id = gqid, targets = {}}
    EnableTriggerGroup("trg_gq_info", true)
end

function gq_info_extended()
    potential_gq.extended = true
end

function gq_info_finished()
    potential_gq.finished = true
end

function gq_info_level_range(name, line, wildcards)
    local min = tonumber(wildcards.minlvl)
    local max = tonumber(wildcards.maxlvl)
    local eff = math.floor((min + max) / 2)
    potential_gq.efflvl = eff
end

function gq_info_line(name, line, wildcards)
    local qty = wildcards.qty
    local mob, loc = parse_mob_target(wildcards.target)
    table.insert(potential_gq.targets, {mob = mob, qty = qty, loc = loc})
end

function gq_info_end()
    EnableTriggerGroup("trg_gq_info", false)

    if potential_gq.finished then
        DebugNote("Looking at the info of a finished gq. No action needed")
        return
    elseif #potential_gq.targets > 0 then
        player_is_on_gq()
        gq_info_list = potential_gq.targets
        gq_joined = potential_gq.id
        gqid_started = potential_gq.id
        gqid_extended = potential_gq.extended and potential_gq.id or "-1"
        set_variable("mcvar_gqid_joined", gqid_joined)
        set_variable("mcvar_gqid_started", gqid_started)
        set_variable("mcvar_gqid_extended", gqid_extended)

        gq_info_efflvl = potential_gq.efflvl
        set_variable("mcvar_gq_info_efflvl", gq_info_efflvl)

        area_room_type = area_room_type_check(gq_info_list)

        -- cp_info_level = tonumber(gmcp("char.status.level"))	-- room target builder will crash without a sensible value here.  Just use current player level.
        DebugNote("gq type detection: ", area_room_type, " (level ", gq_info_efflvl, ")")
        xg_draw_window()
        DoAfterSpecial(0.1, "do_gq_check()", sendto.script)
    else
        DebugNote("Gq info for pending gq or not your gq")
    end
end

--	[[ Gquest check functions ]]
function do_gq_check()
    player_is_on_gq()
    local time_check = os.clock() -- prevent double cp checks from different plugins
    if ((time_check - last_gq_check) < 1.0) then
        return
    end
    last_gq_check = time_check
    gq_check_list = {}
    EnableTrigger("trg_gq_check_line", true)
    DoAfterSpecial(0.1, "send_gq_check()", sendto.script)
end

function send_gq_check()
    if debug_gq_mode then
        DoAfterSpecial(2, "simulate_send_gq_check()", sendto.script)
    else
        SendNoEcho("gq ch")
    end
end

-- Parses the mob and location out of a target line, returning them
-- separately, along with a boolean for whether or not the mob is dead.
-- This is parenthesis aware so it should properly handle parentheses in both
-- the location name and target name
function parse_mob_target(target_line)
    local char, location, i
    local temp = ""
    local mob_name = ""
    local paren_counter = 0
    local dead = "no"

    for i = 1, #target_line do
        char = target_line:sub(i, i)
        if char == "(" then
            paren_counter = paren_counter + 1
            if paren_counter == 1 then
                mob_name = mob_name .. temp
                temp = char
            else
                temp = temp .. char
            end
        elseif char == ")" then
            paren_counter = paren_counter - 1
            temp = temp .. char

            if paren_counter == 0 then
                if i == #target_line then
                    location = temp
                else
                    mob_name = mob_name .. temp
                end
                temp = ""
            end
        else
            temp = temp .. char
        end
    end

    if location then
        location = Trim(location)
        location = location:sub(2, #location - 1)
        if location:match(" %- Dead$") then
            location = location:sub(1, #location - 7)
            dead = "yes"
        end
    else
        ErrorNote("The target line ", target_line, " could not be parsed properly. Contact Crowley to get it fixed")
        return nil
    end

    mob_name = Trim(mob_name)

    return mob_name, location, dead
end

function gq_check_line(name, line, wildcards)
    EnableTrigger("trg_gq_check_end", true)
    local qty = wildcards.qty
    local mob, loc, is_dead = parse_mob_target(wildcards.target)
    table.insert(gq_check_list, {mob = mob, qty = qty, loc = loc, is_dead = is_dead})
end

function gq_check_end()
    EnableTriggerGroup("trg_gq_check", false)

    player_is_on_gq()
    build_main_target_list("gq", area_room_type)
    xcp_retry()
end

function xcp_retry()
    -- About xcp_retry_stat:
    -- after killing gq mob, it's possible to 'xcp' after tables are cleared,
    -- but before they're refreshed, which would cause 'xcp' to fail with the
    -- message "no data yet".  Instead, gq_mob_killed sets a flag that does
    -- two things: 1) tells 'xcp' to silently abort, 2) tells gq_check_end to
    -- do 'xcp' again (with or without arg), which works normally now that
    -- table data is available.
    DebugNote("xcp retry with state ", xcp_retry_stat)
    if xcp_retry_stat == 1 and is_cp_or_gq_mob_targeted() and last_kill_index then
        -- If the killed mob was different from your current mob, you might
        -- need to adjust the targeted mob's index so that it is the correct
        -- one on the new list
        DebugNote("Killed mob was ", tostring(last_kill_index), " and current target index is ", current_target.index)
        local target_found = false
        for i, target in ipairs(main_target_list) do
            if target_matches_current_target(target) then
                target_found = true
                DebugNote("Current target found in list after update")
                set_target_from_main_target_list(i)
                break
            end
        end
        if not target_found then
            DebugNote("Current target not found in target list after update. Clearing")
            clear_target()
        end
        xg_draw_window()
    elseif xcp_retry_stat == 2 then
        local xcp_index = xcp_index_attempt
        if last_kill_index and last_kill_index < xcp_index_attempt then
            xcp_index = math.max(1, xcp_index_attempt - 1)
        end
        xcp_retry_stat = 0
        xcp_arg("", "", {index = xcp_index})
    end
    xcp_retry_stat = 0
end

--	[[ Gquest general status functions ]]
function gq_mob_killed()
    if current_activity ~= "gq" then
        return
    end
    last_kill_index = get_last_kill_index()
    if last_kill_index and main_target_list[last_kill_index] then
        local target = main_target_list[last_kill_index]
        local x = tonumber(target.qty) - 1
        record_target_killed(target)
        target.qty = x
        if (#main_target_list > 1) then
            if x and (x > 0) then
                xg_draw_window()
                print_target_links(main_target_list)
            else
                qw_reset(false)
                DebugNote("Setting xcp_retry_stat to ", 1)
                xcp_retry_stat = 1
                target.is_dead = "yes"
                if is_gq_mob_targeted() then
                    if current_target.index == last_kill_index then
                        xcp_clear_target(false)
                    end
                end
                xg_draw_window()
                DoAfterSpecial(0.1, "do_gq_check()", 12)
            end
        elseif (#main_target_list == 1) then
            DebugNote("last mob!")
            if x and (x > 0) then
                xg_draw_window()
                print_target_links(main_target_list)
            else
                qw_reset(false)
                xcp_clear_target(false)
            end
        end
    else
        qw_reset(false)
        xcp_retry_stat = 1
        xcp_clear_target(false)
        DoAfterSpecial(0.1, "do_gq_check()", 12)
    end
end

function gqmsg_winner(name, line, wildcards)
    local gqid = wildcards.gq_id
    local winner = wildcards.winner
    local you = gmcp("char.base.name")
    if (winner == you) then
        ColourNote("#FFFFFF", "", "\nA WINNER IS YOU\n")
        player_not_on_gq()
    elseif (gqid == gqid_joined) then
        EnableTrigger("trg_gqmsg_extended_time", true)
        DoAfterSpecial(0.5, "gq_check_if_extended()", sendto.script)
    else
        -- do nothing, message is for a different gq.
    end
end

function gqmsg_extended_time(name, line, wildcards)
    local gqid = wildcards.gq_id
    if (gqid == gqid_joined) then
        gqid_extended = gqid
    end
end

function gq_check_if_extended()
    EnableTrigger("trg_gqmsg_extended_time", false)
    if (gqid_extended ~= gqid_joined) then
        player_not_on_gq()
    end
end

function gq_check_not_yet_started(name, line, wildcards)
    gqid_joined = wildcards[1]
    player_is_on_gq()
    gqid_started = "-1"
    set_variable("mcvar_gqid_started", "-1")
end

function player_is_on_gq()
    EnableTriggerGroup("trg_gqmsg", true)
    player_on_gq = "yes"
    current_activity = "gq"
end

function gq_ended(name, line, wildcards)
    if gqid_joined == wildcards.gq_id then
        player_not_on_gq()
    end
end

function player_not_on_gq()
    EnableTriggerGroup("trg_gqmsg", false)
    EnableTrigger("trg_gqmsg_extended_time", false)
    player_on_gq = "no"
    area_room_type = "none"
    current_activity = "none"
    gq_info_list = {}
    gq_check_list = {}
    main_target_list = {}
    room_targets_ignored = {}

    gqid_joined = "-1"
    set_variable("mcvar_gqid_joined", gqid_joined)
    -- gqid_started = "-1"
    -- set_variable("mcvar_gqid_started", gqid_started)
    gqid_extended = "-1"
    set_variable("mcvar_gqid_extended", gqid_extended)

    xcp_clear_target(true)

    if (player_on_cp == "yes") then
        DoAfterSpecial(0.4, [[ InfoNote("Reloading your cp targets....")
								do_cp_info() ]], sendto.script)
    end
end

--	[[ Build main target list process path ]]
function build_main_target_list(cp_or_gq, area_or_room)
    local cp_gq = cp_or_gq
    local ar_rm = area_or_room

    local sqla = " SELECT uid as arid, name as areaName " .. "FROM areas " .. "WHERE name = %s " .. "ORDER BY arid ASC "
    local sqlr =
        " SELECT r.uid as roomid, r.name as roomName, a.uid as arid, a.name as areaName, 'room' as link_type " ..
        "FROM rooms r " .. "INNER JOIN areas a ON r.area = a.uid " .. "WHERE r.name = %s " .. "ORDER BY arid ASC "
    if (ar_rm == "area") then
        main_target_list = build_area_targets(cp_gq, sqla)
    elseif (ar_rm == "room") then
        main_target_list, room_targets_ignored = build_room_targets(cp_gq, sqlr, sqla)
    elseif (ar_rm == "none") then -- should never be called but who knows
        print("main_target_list build error - tried to run while on " .. cp_gq .. " but area/room type is 'none'.")
    end
    xg_draw_window()
    DebugNote("Print target links after build main target list")
    print_target_links(main_target_list)
end

function color_for_target(target, targeted)
    if targeted then
        return text_colors.targeted
    elseif target.unlikely then
        return text_colors.unlikely
    elseif target.is_dead == "yes" and target.link_type == "unknown" then
        return text_colors.unknown_dead
    elseif target.is_dead == "yes" then
        return text_colors.dead
    elseif target.link_type == "unknown" then
        return text_colors.unknown
    else
        return text_colors.normal
    end
end

function build_area_targets(cp_gq, sqla)
    local t, list = {}, {}
    local unlikely_mobs = {}
    if (cp_gq == "cp") then
        list = cp_check_list
    elseif (cp_gq == "gq") then
        list = gq_check_list
    end
    local db = assert(sqlite3.open(mapper_db_file))
    local SnDdb = assert(sqlite3.open(snd_db_file))
    for i, v in ipairs(list) do
        local dead = v.is_dead
        local results_found = false
        local select = string.format(sqla, fixsql(v.loc))
        local possibilities = {}
        local areas_sql = {}
        for row in db:nrows(select) do
            results_found = true
            table.insert(
                possibilities,
                {
                    mob = v.mob,
                    arid = row.arid,
                    qty = v.qty,
                    is_dead = dead,
                    link_type = "area"
                }
            )
            table.insert(areas_sql, fixsql(row.arid))
        end
        if #possibilities > 1 then
            local mobs_by_area_query =
                string.format(
                [[
					SELECT DISTINCT(zone)
					FROM mobs
					WHERE mob = %s AND zone IN (%s);
				]],
                fixsql(v.mob),
                table.concat(areas_sql, ",")
            )
            local mob_found = false

            for row in SnDdb:nrows(mobs_by_area_query) do
                for i, mob in ipairs(possibilities) do
                    if mob.arid == row.zone then
                        mob_found = true
                        mob.found = true
                        break
                    end
                end
            end

            if mob_found then
                local found = {}
                local not_found = {}

                for i, mob in ipairs(possibilities) do
                    mob.duplicates = #possibilities
                    if mob.found then
                        table.insert(found, mob)
                    else
                        mob.unlikely = true
                        table.insert(not_found, mob)
                    end
                end

                for i, mob in ipairs(found) do
                    mob.index = i
                    table.insert(t, mob)
                end

                for i, mob in ipairs(not_found) do
                    mob.index = i + #found
                    table.insert(unlikely_mobs, mob)
                end
            else
                for i, mob in ipairs(possibilities) do
                    mob.index = i
                    mob.duplicates = #possibilities
                    table.insert(t, mob)
                end
            end
        elseif #possibilities == 1 then
            table.insert(t, possibilities[1])
        else
            table.insert(
                t,
                {
                    mob = v.mob,
                    location = v.loc,
                    arid = "-1",
                    qty = v.qty,
                    is_dead = dead,
                    link_type = "unknown",
                    unknown = true
                }
            )
        end
    end
    SnDdb:close_vm()
    db:close_vm()

    for i, mob in ipairs(unlikely_mobs) do
        table.insert(t, mob)
    end

    for i, v in ipairs(t) do
        v.kw = gmkw(v.mob, v.arid)
    end
    return t
end

function build_room_targets(cp_gq, sqlr, sqla)
    local ig, list = {}, {}
    local low_chance = {}
    local high_chance = {}
    local level_taken
    if (cp_gq == "cp") then
        list = cp_check_list
        level_taken = tonumber(cp_info_level)
    elseif (cp_gq == "gq") then
        list = gq_check_list
        level_taken = tonumber(gq_info_efflvl)
    end
    local db = assert(sqlite3.open(mapper_db_file))
    local SnDdb = assert(sqlite3.open(snd_db_file))
    local area_sorter = function(a, b)
        if a.arid == "-1" then
            return false
        elseif b.arid == "-1" then
            return true
        else
            return a.arid < b.arid
        end
    end

    for i, v in ipairs(list) do
        local possibilities = {}
        local dead = v.is_dead
        local lt  -- link type (area, room, unknown)
        local areas_sql = {}
        if (dead == "yes") then
            lt = "area"
        else
            lt = "room"
        end
        local results_found = false
        local select = string.format(sqlr, fixsql(v.loc))
        local last_mob_sig = ""
        for row in db:nrows(select) do -- if not row then / print("error - room db search returned no rows") / elseif not row.areaName then / print("area name missing from row") / end
            if (area_range_index[row.areaName]) then -- don't include areas that never contain quest mobs
                local mob_sig = row.arid .. "|" .. v.mob
                if (mob_sig ~= last_mob_sig) then
                    last_mob_sig = mob_sig
                    local area_min_lvl = (area_range_index[row.areaName].min) or 1
                    local area_max_lvl = (area_range_index[row.areaName].max) or 300
                    if (level_taken >= area_min_lvl) and (level_taken <= (area_max_lvl + 25)) then -- limit results to sensible level range.
                        results_found = true
                        table.insert(areas_sql, fixsql(row.arid))
                        table.insert(
                            possibilities,
                            {
                                mob = v.mob,
                                arid = row.arid,
                                roomid = row.roomid,
                                roomName = row.roomName,
                                qty = v.qty,
                                is_dead = dead,
                                 --v.is_dead,
                                minlvl = area_min_lvl,
                                maxlvl = area_max_lvl,
                                link_type = lt --((v.is_dead == false) and "room" or "area"),	-- deals with dead mobs when area contains roomnames same as area name e.g. Aardington Estate
                            }
                        )
                    else
                        table.insert(
                            ig,
                            {
                                -- build table of search results for areas out of your level range.
                                mob = v.mob, -- Usually invalid, but valid links can wind up here if area's level range is too broad, or wrong.
                                arid = row.arid,
                                roomid = row.roomid,
                                roomName = row.roomName,
                                qty = v.qty,
                                is_dead = dead,
                                minlvl = area_min_lvl,
                                maxlvl = area_max_lvl,
                                link_type = "ignored"
                            }
                        )
                    end
                end
            end
        end
        if results_found then
            -- When more than one possible area is found, check if you've seen the mob in that room in any of the areas
            -- if never seen in any of the rooms, check if you've seen them anywhere in the areas
            if #possibilities > 1 then
                local mobs_by_room_query =
                    string.format(
                    "SELECT DISTINCT(zone) FROM mobs WHERE mob = %s AND room = %s AND zone IN (%s);",
                    fixsql(v.mob),
                    fixsql(v.loc),
                    table.concat(areas_sql, ",")
                )
                local mob_found = false
                for row in SnDdb:nrows(mobs_by_room_query) do
                    for i, possibility in ipairs(possibilities) do
                        if possibility.arid == row.zone then
                            mob_found = true
                            possibility.found = true
                            break
                        end
                    end
                end

                if not mob_found then
                    local mobs_by_area_query =
                        string.format(
                        "SELECT DISTINCT(zone) FROM mobs WHERE mob = %s AND zone IN (%s);",
                        fixsql(v.mob),
                        table.concat(areas_sql, ",")
                    )
                    for row in SnDdb:nrows(mobs_by_room_query) do
                        for i, possibility in ipairs(possibilities) do
                            if possibility.arid == row.zone then
                                mob_found = true
                                possibility.found = true
                                break
                            end
                        end
                    end
                end

                table.sort(possibilities, area_sorter)
                if mob_found then
                    local temp_high = {}
                    local temp_low = {}
                    for i, possibility in ipairs(possibilities) do
                        possibility.duplicates = #possibilities
                        if possibility.found then
                            table.insert(temp_high, possibility)
                        else
                            possibility.unlikely = true
                            table.insert(temp_low, possibility)
                        end
                    end
                    for i, possibility in ipairs(temp_high) do
                        possibility.index = i
                        table.insert(high_chance, possibility)
                    end

                    for i, possibility in ipairs(temp_low) do
                        possibility.index = i + #temp_high
                        table.insert(low_chance, possibility)
                    end
                else
                    for i, possibility in ipairs(possibilities) do
                        possibility.duplicates = #possibilities
                        possibility.index = i
                        table.insert(high_chance, possibility)
                    end
                end
            elseif #possibilities == 1 then
                table.insert(high_chance, possibilities[1])
            end
        else -- no results were returned: either the mob is dead, or the location is unknown.
            if (dead == "yes") then -- mob is dead
                local results_found = false
                local select = string.format(sqla, fixsql(v.loc)) -- dead mobs only give area name (even in room cp's) so search area info only.
                for dead_row in db:nrows(select) do -- mob is dead, location is known
                    results_found = true
                    table.insert(
                        high_chance,
                        {mob = v.mob, arid = dead_row.arid, qty = v.qty, is_dead = "yes", link_type = "area"}
                    )
                end
                if (results_found == false) then -- mob is dead, location is unknown
                    table.insert(
                        high_chance,
                        {
                            mob = v.mob,
                            arid = "-1",
                            location = v.loc,
                            qty = v.qty,
                            is_dead = "yes",
                            link_type = "unknown"
                        }
                    )
                end
            else -- mob is alive, but location is unknown
                table.insert(
                    high_chance,
                    {mob = v.mob, arid = "-1", location = v.loc, qty = v.qty, is_dead = "no", link_type = "unknown"}
                )
            end
        end
    end
    table.sort(ig, area_sorter)
    table.sort(high_chance, area_sorter)
    table.sort(low_chance, area_sorter)

    for i, v in ipairs(low_chance) do
        table.insert(high_chance, v)
    end

    db:close_vm()
    SnDdb:close_vm()
    for i, v in ipairs(high_chance) do
        v.kw = gmkw(v.mob, v.arid)
    end
    return high_chance, ig
end

--	[[ Display target links in MUD window ]]
function print_target_links(list)
    if (#room_targets_ignored > 0) then
        print_room_links_ignored()
    end
    if silentMode == "off" then
        if (#list > 0) then
            ColourNote("#808080", "", string.rep("-", 80))
             --
            --[[if list[1].link_type == "room" then
					for _,v in ipairs(list) do
						if string.match(v.roomName, "^Hiding from") then
							v.arid = "zz" .. v.arid ]] for i, v in ipairs(
                list
            ) do
                local mob_text = string.format("%s%s", ((v.is_dead == "no") and "" or "[D] "), v.mob)
                local arid = v.arid:sub(1, 10)
                local background = (i % 2) == 0 and text_colors.alternating_row or ""
                local link_text
                local tooltip = "Target cp mob " .. i .. " - " .. mob_text .. " (" .. v.arid .. ")"
                local notehelp = "Show notes for item " .. i
                local color = color_for_target(v)
                mob_text = ellipsify(mob_text, 32)
                if (v.link_type == "area") then
                    link_text = string.format("%2d  %-32s - %-10s", i, mob_text, arid)
                    Hyperlink("xcp " .. i, link_text, tooltip, color, background, 0, 1)
                    Hyperlink(
                        "roomnote area " .. v.arid,
                        string.format("  %-29s", "[notes]"),
                        notehelp,
                        ((v.is_dead == "yes") and "#006000" or "lightgreen"),
                        background,
                        0,
                        1
                    )
                elseif v.link_type == "room" and v.unlikely then
                    ColourNameToRGB(text_colors.unlikely_tag)
                    Hyperlink("xcp " .. i, string.format("%2d  ", i), tooltip, color, background, 0, 1)
                    Hyperlink("xcp " .. i, "(U) ", tooltip, text_colors.unlikely_tag, background, 0, 1)
                    mob_text = ellipsify(mob_text, 28)
                    local roomText = string.format("'%s'", ellipsify(v.roomName, 27))
                    link_text = string.format("%-28s - %-10s  %-29s", mob_text, v.arid, roomText)
                    Hyperlink("xcp " .. i, link_text, tooltip, color, background, 0, 1)
                elseif v.link_type == "room" then
                    local roomText = string.format("'%s'", ellipsify(v.roomName, 27))
                    link_text = string.format("%2d  %-32s - %-10s  %-29s", i, mob_text, v.arid, roomText)
                    Hyperlink("xcp " .. i, link_text, tooltip, color, background, 0, 1)
                elseif (v.link_type == "unknown") then
                    local location = ellipsify(v.location, 30)
                    link_text =
                        string.format(
                        "%2d  %-32s - unknown: '%s'%s",
                        i,
                        mob_text,
                        location,
                        string.rep(" ", 30 - #location)
                    )
                    tooltip = "Location not found in mapper database"
                    Hyperlink(" ", link_text, tooltip, color, background, 0, 1)
                end
                print("")
            end
            ColourNote("#808080", "", string.rep("-", 80))
            ColourNote("#808080", "", "Type 'xcp <index>' or click link to go to that target.")
        else
            InfoNote("   No target items to show.")
        end
    end
end

function ellipsify(str, max_length)
    if #str <= max_length then
        return str
    else
        return str:sub(1, max_length - 1) .. ""
    end
end

function print_room_links_ignored()
    local ig = room_targets_ignored
    ColourNote("#808080", "", string.rep("-", 80))
    for i, v in ipairs(ig) do
        local link =
            string.format(
            " ** Ignoring due to level: %s - '%s' (%s) [%s-%s]",
            v.mob,
            v.roomName,
            v.arid,
            v.minlvl,
            v.maxlvl
        )
        Hyperlink("xmapper move " .. v.roomid, link, "Move to room " .. v.roomid, "#002460", "", 0, 1)
        print("")
    end
end

-- [[ "xcp" command ]]
function xcp_noarg() -- xcp with no argument given, so find the first available mob (alive, location known) and go to it.
    local t = main_target_list
    if xcp_targets_quest_onoff == "on" and has_active_quest() then
        target_quest_mob(true)
        xg_draw_window()
    elseif (area_room_type == "none") then -- abort if not on cp
        InfoNote("\nSearch and Destroy: 'xcp' aborted - you're not on a cp.\n")
    elseif (#main_target_list == 0) then -- abort if on a cp, but target list is empty
        InfoNote("\nSearch and Destroy: 'xcp' aborted - cp is active but target list is empty.\n")
    else
        local target_found = false
        for i, mob in ipairs(main_target_list) do -- loop through list and try to find something to kill.
            if (mob.is_dead == "no") and (mob.link_type == "area" or mob.link_type == "room") then -- if mob is alive and location known, go to it.
                DebugNote("Switching to target ", i)
                xcp_goto_target(i)
                xg_draw_window()
                target_found = true
                break
            end
        end
        if not target_found then
            InfoNote("\nSearch and Destroy: 'xcp' aborted - lack of targets (dead, or location unknown)")
        end
    end
end

function xcp_arg(name, line, wildcards)
    local index = tonumber(wildcards.index)
    local cp_list = main_target_list
    if (area_room_type == "none") then
        InfoNote("\nSearch and Destroy: 'xcp' aborted - you're not on a cp.\n")
    elseif (#cp_list == 0) then
        InfoNote("\nSearch and Destroy: 'xcp' aborted - cp is active but target list is empty.\n")
    elseif (index > #cp_list) or (index < 0) then -- index doesn't exist
        InfoNote("\nSearch and Destroy: 'xcp' aborted - index doesn't exist (" .. index .. ")\n")
    elseif (index == 0) then -- clear xcp target
        xcp_clear_target(true)
        InfoNote("\nSearch and Destroy: 'xcp' current target cleared.\n")
    elseif (cp_list[index].link_type == "unknown") then -- or (cp_list[index].link_type == "unknown_room") then	-- abort if unknown
        InfoNote("\nSearch and Destroy: 'xcp' aborted - no mapper data for target (#" .. index .. ").\n")
    else -- everything is in order, so go to mob.
        local ch_state = current_character_state
        xcp_goto_target(index)
        xg_draw_window()
    end
end

function is_character_ready()
    return current_character_state == "3"
end

local CHARACTERS_STATES = {
    "logging in",
    "logging in", -- MOTD sequence
    "ready",
    "AFK",
    "writing a note",
    "building",
    "reading a page",
    "fighting",
    "sleeping",
    "in an unknown state",
    "resting",
    "running"
}

function character_state_string()
    local str
    if current_character_state then
        local ch_state = tonumber(current_character_state)
        str = CHARACTERS_STATES[ch_state]
    end

    return str or "in an unknown state"
end

function xcp_goto_target(index)
    DebugNote("xcp goto target index ", index)
    local t = main_target_list[index]
    if (xcp_retry_stat == 0) then
        local ri = current_room
        local action = xcp_action_mode
        gotoArea = -1
        gotoIndex = 1
        next_room = -1
        gotoList = {}
        if (t ~= nil) and (ri.rmid ~= nil) then
            set_target_from_main_target_list(index)
            if is_character_ready() then
                DebugNote("Character ready")
                if (t.link_type == "area") then -- Area cp links - "xcp" goes to target area, then runs Hunt Trick to get target room.
                    if (action == "ht" and current_activity == "cp") then -- do hunt trick or quick where after arriving in area.
                        local func = function()
                            do_hunt_trick(1, t.kw)
                        end
                        execute_in_area(t.arid, func)
                    elseif (action == "qw" or (action == "ht" and current_activity ~= "cp")) then
                        local func = function()
                            qw_exact()
                        end
                        execute_in_area(t.arid, func)
                    elseif (action == "off") then -- do nothing
                        InfoNote("Xcp action is off - no additional action\n")
                    end
                    if (ri.arid ~= t.arid) then -- if you're not in target area, xrunto target area.
                        --Execute("xrt " .. t.arid)
                        xrun_to(t.arid, true)
                    end
                else -- Room cp:  get target room from mapper, but don't move yet.  "go" takes you to room.
                    search_rooms_exact(t.roomName, t.arid, t.mob)
                end
            else
                InfoNote(string.format("\nYou can't run there while you're %s!\n", character_state_string()))
            end
        else
            InfoNote("No item exists, or data is busy")
        end
    else
        set_target_from_main_target_list(index)
        xcp_index_attempt = index
        xcp_retry_stat = 2
    end
end

function xcp_clear_target(redraw_miniwin)
    clear_target()
    gotoArea = -1
    gotoIndex = 0
    gotoList = {}
    if redraw_miniwin then
        xg_draw_window()
    end
end

function xcp_set_action_mode(name, line, wildcards)
    local opt = wildcards.option or ""
    local options = {
        ["ht"] = "ht - do hunt trick",
        ["qw"] = "qw - do quick where",
        ["off"] = "off - no additional action"
    }
    if (opt == "ht") or (opt == "qw") or (opt == "off") then
        xcp_action_mode = opt
        set_variable("mcvar_xcp_action_mode", opt)
        InfoNote("Set 'xcp' mode to: ", options[opt], ".")
    elseif (opt == "") then
        InfoNote("Current 'xcp' mode: " .. options[xcp_action_mode] .. ".")
        InfoNote("Syntax: 'xcp mode [ht|qw|off]'")
    else
        InfoNote("Invalid 'xcp' mode given.  Syntax: 'xcp mode [ht|qw|off]'")
    end
    print("")
end

function xcp_toggle_quest_targeting()
    if xcp_targets_quest_onoff == "on" then
        xcp_targets_quest_onoff = "off"
    else
        xcp_targets_quest_onoff = "on"
    end
    set_variable("mcvar_xcp_targets_quest_onoff", xcp_targets_quest_onoff)

    InfoNote("\nxcp quest targeting is now ", string.upper(xcp_targets_quest_onoff))
end

-- [[  Goto area (xrt), goto room (go), goto next (nx), goto previous (nx-) ]]
local xrun_to_sql_uid =
    "SELECT r.uid, r.name as room, r.area " .. "FROM rooms r " .. "WHERE r.area like %s " .. "ORDER BY r.name "
local xrun_to_sql_name =
    "SELECT r.uid, r.name as room, r.area " ..
    "FROM rooms r " ..
        "INNER JOIN areas a ON a.uid = r.area " .. "WHERE r.area like %s OR a.name like %s " .. "ORDER BY r.name "

function xrun_to_alias(name, line, wildcards)
    xrun_to(wildcards.destination, false)
end

function xrun_to(arid, exact)
    local ri = current_room
    if (arid == "ft2") then
        arid = "ftii"
    end
    local rmid = get_start_room(arid, exact)
    if (rmid == "-1") then -- area has no start room defined.
        InfoNote("X-runto: No default start room is defined for area: " .. arid .. ".\n")
        SendNoEcho("areas 1 299 keywords " .. arid)
    else
        InfoNote("X-runto: " .. arid .. ", room ID: " .. rmid .. " (" .. start_room_type .. ")\n")
        goto_room_id(rmid, arid)
    end
end

function goto_room_id(rmid, arid) -- go to specific room id (do not confuse with goto_number, see below)
    local ri = current_room
    local rmid = rmid
    local arid = arid or getAreaFromRoomId(rmid)
    if (is_vidblain_area(rmid) == true) then -- if target is in a vidblain area,
        if (is_vidblain_area(ri.rmid) == false) then -- but if you are not
            vidblain_nav(rmid, arid)
        else
            do_mapper_goto(rmid, "walk")
        end
    else
        do_mapper_goto(rmid)
    end
end

function action_on_destination_arrived()
    DebugNote("Executing action on destination arrived: ", tostring(xset_nx_action))
    if xset_nx_action == "smartscan" then
        smart_scan()
    elseif xset_nx_action == "con" then
        EnableTrigger("consider_end_empty", true)
        SendNoEcho("consider")
    elseif xset_nx_action == "scan" then
        SendNoEcho("scan")
    elseif xset_nx_action == "scanhere" then
        SendNoEcho("scan here")
    elseif xset_nx_action == "qs" then
        quick_scan()
    end
end

function set_going_to_room(room_id)
    going_to_room = tostring(room_id)
    DebugNote("setting going to room to ", going_to_room)
    if current_room.rmid == going_to_room then
        DebugNote("You're already at the destination room. Do action now")
        action_on_destination_arrived()
        going_to_room = nil
    end
end

function goto_number(name, line, wildcards)
    if is_character_ready() then
        gotoIndex = tonumber(wildcards.index) or 1
        if gotoList[gotoIndex] then
            if (tonumber(gotoList[gotoIndex]) == nil) then
                set_going_to_room(get_start_room(gotoList[gotoIndex], true))
                xrun_to(gotoList[gotoIndex], true)
            else
                next_room = gotoList[gotoIndex]
                set_going_to_room(next_room)
                goto_room_id(next_room)
            end
        else
            InfoNote("Goto room result (go) aborted - No destination yet.")
        end
    else
        InfoNote("\nYou can't use ", "go", string.format(" while you're %s!", character_state_string()))
    end
end

function goto_next(name, line, wildcards)
    if is_character_ready() then
        if (next_room == nil) or (next_room == "") or (not tonumber(next_room)) then
            InfoNote("Goto next (nx) aborted - No data yet.")
        else
            if (tonumber(next_room) == tonumber(gmcp("room.info.num"))) and (gotoIndex < #gotoList) then
                gotoIndex = gotoIndex + 1
            end
            gotoIndex = math.max(1, gotoIndex)
            if gotoList[gotoIndex] then
                InfoNote("Next room (nx) - ", gotoIndex, " of ", #gotoList)
                next_room = gotoList[gotoIndex]
                set_going_to_room(next_room)
                do_mapper_goto(next_room)
            else
                InfoNote("Goto next (nx) aborted - No more rooms.")
            end
        end
    else
        InfoNote("\nYou can't use ", "nx", string.format(" while you're %s!", character_state_string()))
    end
end

function goto_previous(name, line, wildcards)
    local ch_state = current_character_state
    if is_character_ready() then
        if (next_room == nil) or (next_room == "") or (not tonumber(next_room)) then
            InfoNote("Goto previous (nx-) aborted - No data yet.")
        else
            if (tonumber(next_room) == tonumber(gmcp("room.info.num"))) and (gotoIndex > 1) then
                gotoIndex = gotoIndex - 1
            end
            if gotoList[gotoIndex] then
                InfoNote("Previous room (nx-) - ", gotoIndex, " of ", #gotoList)
                next_room = gotoList[gotoIndex]
                do_mapper_goto(next_room)
                quick_scan()
            else
                InfoNote("Goto previous (nx-) aborted - No more rooms.")
            end
        end
    else
        InfoNote("\nYou can't use ", "nx-", string.format(" while you're %s!", character_state_string()))
    end
end

--	[[ Vidblain navigation ]]
function vidblain_nav(rmid, arid)
    local ch_state = current_character_state
    vidblain_nav_tbl = {i = 0, j = 0, rmid = rmid, arid = arid, stat = ch_state}
    EnableTimer("execute_in_area_timer", false)
    EnableTimer("vidblain_nav_timer", true)
    Execute("mapper goto 11910") -- move to vidblain and enter the portal
    Execute("enter hole")
end

function vidblain_nav_tick()
    local ri = current_room
    local ch_state = current_character_state
    local vnt = vidblain_nav_tbl
    local eiat = execute_in_area_tbl
    if (ri.arid ~= nil) and (ch_state ~= nil) then
        if (ri.arid ~= "vidblain") then -- not in vidblain yet
            vnt.i = vnt.i + 1
            if (vnt.i > 200) then
                EnableTimer("vidblain_nav_timer", false)
                xcp_clear_target(true)
                InfoNote("** vidblain nav:  abort timer - took too long to get to destination.")
                vidblain_nav_tbl = {i = 0, j = 0, rmid = "", arid = "", stat = 1}
            end
        else -- arrived in vidblain proper
            if (ch_state == "3") and (ch_state == vnt.stat) then -- monitor char state for 3 ticks, if stable, start EIA timer and run to target area
                vnt.j = vnt.j + 1
                if (vnt.j > 3) then
                    EnableTimer("vidblain_nav_timer", false) -- stop vidblain timer
                    do_mapper_goto(vnt.rmid, "walk")
                    execute_in_area(vnt.arid, eiat.f) -- start EIA timer
                    vidblain_nav_tbl = {i = 0, j = 0, rmid = "", arid = "", stat = 1}
                end
            else
                vnt.stat = ch_state
            end
        end
    end
end

--	[[ Execute in Area ]]
function execute_in_area(arid, func) -- id is the process or function calling this one.
    local ri = current_room
    local ch_state = current_character_state
    local fn
    if (type(func) == "function") then
        fn = func
    else
        fn = function()
        end
    end
    execute_in_area_tbl = {i = 0, j = 0, arid = arid, f = fn, stat = ch_state}
    if (ri.arid == arid) then -- in target area
        func()
        execute_in_area_tbl = {i = 0, j = 0, arid = "", f = "", stat = 1}
    elseif (ri.arid == nil) then --
        print("execute_in_area - nil area name")
        send_gmcp_packet("request room")
    else
        EnableTimer("execute_in_area_timer", true)
    end
end

function execute_in_area_tick()
    local ri = current_room
    local ch_state = current_character_state
    local eiat = execute_in_area_tbl
    if (ri.arid ~= nil) and (ch_state ~= nil) then
        if (ri.arid ~= eiat.arid) then
            eiat.i = eiat.i + 1
            if (eiat.i > 200) then
                EnableTimer("execute_in_area_timer", false)
                xcp_clear_target(true)
                InfoNote("** execute-in-area:  abort timer - took too long to get to destination.")
                execute_in_area_tbl = {i = 0, j = 0, arid = "", f = "", stat = 1}
            end
        else
            if (ch_state == "3") and (ch_state == eiat.stat) then
                eiat.j = eiat.j + 1
                if (eiat.j > 3) then
                    EnableTimer("execute_in_area_timer", false)
                    eiat.f()
                --eiat.f()
                end
            else
                eiat.stat = ch_state
                if (ch_state == "8") then
                    EnableTimer("execute_in_area_timer", false)
                    DoAfterSpecial(1.5, [[ EnableTimer("execute_in_area_timer", true) ]], 12)
                end
            end
        end
    end
end

function execute_in_room(rmid, func)
end

function execute_in_room_tick()
end

--	[[ quick where ]]
function qw_reset(exact)
    EnableTrigger("trg_quick_where_match", false)
    EnableTrigger("trg_quick_where_no_match", false)
    qw = {index = 1, exact = exact}
end

function qw_noarg()
    local ix = qw.index or 1
    if has_activity_target() then
        if (qw.exact == true) then
            qw_exact()
        else
            do_quick_where(ix, current_target.keyword)
        end
    else
        InfoNote("\nSearch and Destroy: 'Quick-where' has no target.")
        InfoNote("Use 'xcp', 'qw <mob>, or 'ht <mob>' to get target info.\n")
    end
end

function qw_arg_alias(name, line, wildcards)
    local mob = wildcards.mob
    local index = tonumber(wildcards.index) or 1

    qw_arg(index, mob)
    xg_draw_window()
end

function qw_arg(index, mob)
    set_adhoc_target(mob)
    qw.index = index
    qw.exact = false

    do_quick_where(index, mob)
end

function qw_exact() -- called from code, e.g. xcp function
    if has_activity_target() then
        local ix = qw.index or 1
        local p1 = split(current_target.name, "[^ ]+")
        local p2
        for i, v in ipairs(p1) do
            if gmkw_omit[v] then
                -- do nothing
            else
                p2 = (p2 == nil) and v or p2 .. " " .. v
            end
        end
        qw.exact = true
        qw.match = p2
        do_quick_where(ix, current_target.keyword)
    else
        print("\nqw exact: You have no 'xcp' target.")
    end
end

function do_quick_where(ix, s)
    EnableTrigger("trg_quick_where_match", true)
    EnableTrigger("trg_quick_where_no_match", true)
    if (ix == 1) then -- don't use 1.mob
        Send(string.format("where %s", s))
    else
        Send(string.format("where %s.%s", ix, s))
    end
end

function qw_match(name, line, wildcards)
    if not has_target() then
        return
    end

    local mob = Trim(wildcards.mobname):lower()
    local room = wildcards.roomname
    local parts
    local found = false
    qw.index = qw.index or 1
    if (qw.exact == true) then -- tells this function to look for an exact match for the current xcp target mob name.
        if mob == Trim(string.sub(current_target.name, 1, 30)):lower() then
            found = true
        end
    else
        parts = split(string.lower(current_target.keyword), "[^ ]+")
        for i = 1, #parts do
            if (string.find(mob, parts[i], 1, true) ~= nil) then
                found = true
                break -- leave loop
            end
        end
    end
    if (found == false) then -- not our line, keep looking
        qw.index = qw.index + 1
        if (qw.index < 101) then
            SendNoEcho(string.format("where %s.%s", qw.index, current_target.keyword))
            return
        else
            print("qw: too many fails")
            found = true
            return
        end
    end
    qw_reset(qw.exact)
    -- change target
    if
        quest_target.mob and current_room.arid == quest_target.arid and
            quest_target.mob:lower():sub(1, 30) == Trim(mob):lower()
     then
        set_target_from_quest(quest_target)
    else
        for i, target in ipairs(main_target_list) do
            if current_room.arid == target.arid and mob == target.mob:lower():sub(1, 30) then
                set_target_from_main_target_list(i, current_target and current_target.keyword)
                break
            end
        end
    end
    xg_draw_window()
    search_rooms_exact(room, current_room.arid, Trim(wildcards.mobname))

    if go_after then
        goto_number(nil, nil, {})
    end
end

function qw_no_match() -- responds to "There is no <mob name> around here."
    qw_reset(qw.exact)
    if has_activity_target() then
        lookup_not_found_mob()
    end
end

function lookup_not_found_mob()
    local full_name = current_target.name:lower()
    local arid = current_room.arid
    local found = false
    local query =
        string.format(
        "SELECT room, roomid, seen_count FROM mobs WHERE zone = %s AND mob = %s;",
        fixsql(arid),
        fixsql(full_name)
    )

    local db = assert(sqlite3.open(snd_db_file))
    local possible_rooms = {}
    local roomids = {}
    local total_count = 0

    for row in db:nrows(query) do
        found = true
        table.insert(
            possible_rooms,
            {
                rmid = row.roomid,
                name = row.room,
                arid = arid,
                seen_count = row.seen_count
            }
        )
        total_count = total_count + row.seen_count
        table.insert(roomids, row.roomid)
    end
    db:close_vm()

    if not found then
        return
    end

    query = string.format("SELECT uid, notes FROM bookmarks WHERE uid in (%s);", table.concat(roomids, ","))
    db = assert(sqlite3.open(mapper_db_file))

    for row in db:nrows(query) do
        for i, room in ipairs(possible_rooms) do
            if tostring(room.rmid) == row.uid then
                room.notes = row.notes
                break
            end
        end
    end
    db:close_vm()

    for i, room in ipairs(possible_rooms) do
        if total_count > 0 then
            room.percentage = (room.seen_count / total_count)
        else
            room.percentage = 0
        end
    end

    table.sort(possible_rooms, sort_rooms_by_seen_count)

    InfoNote("\nMob not found. There are multiple possible reasons for this:")
    InfoNote("  * It might be dead")
    InfoNote("  * You might be using the wrong keyword (use `xset kw` to update if needed)")
    InfoNote("  * It might be flagged nowhere")
    InfoNote("You have previously seen ", current_target.name, " in:")
    search_rooms_results(possible_rooms)
end

--	[[ Hunt trick ]]
function ht_reset()
    EnableTriggerGroup("HuntTrick", false)
    ht = {index = 1, first_target = true}
end

function ht_noarg()
    local ix = ht.index or 1

    if has_target() then
        do_hunt_trick(ix, current_target.keyword)
    else
        InfoNote("\nSearch and Destroy: 'Hunt trick' has no target.")
        InfoNote("Use 'xcp', 'ht <mob>', or 'qw <mob>' to pick a target.\n")
    end
end

function ht_arg(name, line, wildcards)
    local ix = tonumber(wildcards.index) or 1
    set_adhoc_target(wildcards.mob)
    xg_draw_window()
    do_hunt_trick(ix, current_target.keyword)
end

function do_hunt_trick(ix, s)
    ht.index = ix or 1
    EnableTriggerGroup("AutoHunt", false)
    EnableTriggerGroup("HuntTrick", true)
    if (ix == 1) then -- don't use "1.mob"
        Send(string.format("hunt %s", s))
    else
        Send(string.format("hunt %s.%s", ix, s))
    end
end

function ht_continue()
    local ix = (ht.index + 1) or 1
    ht.first_target = false
    if has_target() then
        do_hunt_trick(ix, current_target.keyword)
    else
        DebugNote("You no longer have a target. Stopping hunt trick.")
    end
end

function ht_complete(name, line, wildcards)
    EnableTriggerGroup("AutoHunt", false)
    local ix = ht.index or 1
    if has_activity_target() then
        qw.index = ix
        qw_exact()
    elseif has_target() then
        qw_arg(ix, current_target.keyword)
    else
        DebugNote("You no longer have a target. Stopping hunt trick.")
    end
    ht_reset()
end

function ht_fail()
    local first_target = ht.first_target
    EnableTriggerGroup("HuntTrick", false)
    ht_reset()

    if first_target and has_activity_target() then
        InfoNote("Search and Destroy:  Hunt trick failed. Attempting quick where.")
        qw_exact()
    else
        InfoNote("Search and Destroy:  Hunt trick failed.")
    end
end

function ht_abort(name, line, wildcards)
    EnableTriggerGroup("HuntTrick", false)
    ht_reset()
    InfoNote("Search and Destroy:  Hunt trick cancelled.")
end

-- [[ quick scan, quick kill ("kk") ]]
function quick_scan()
    if has_target() then
        sound_not_played = true
        Send(string.format("scan %s", current_target.keyword))
    else
        Send("scan")
    end
end

function smart_scan()
    if has_activity_target() then
        running_smart_scan = true
        DebugNote("Performing smart scan.")
        SendNoEcho("scan")
    else
        quick_scan()
    end
end

function quick_kill(name, line, wildcards)
    if has_target() then
        local targName = " '" .. current_target.keyword .. "'"
        for command in quick_kill_command:gmatch("[^;]+") do
            command = Trim(command)

            if string.match(command, "%s+notarg$") then
                command = command:gsub("%s+notarg$", "")
                Execute(command)
            else
                Execute(command .. targName)
            end
        end
    else
        InfoNote("\nSearch and Destroy: 'Quick-kill' has no target.  Use 'ht', 'qw', or 'xcp' to select a target.\n")
    end
end

function xset_quick_kill_command(name, line, wildcards) -- user-defined attack to use with qk/kk
    if (wildcards.arg == "") then
        InfoNote("Search and Destroy: Quick-kill command currently set to: '", quick_kill_command, "'")
    else
        quick_kill_command = wildcards.arg
        --quick_kill_command = wildcards.arg
        set_variable("mcvar_quick_kill_command", quick_kill_command)
        InfoNote("Search and Destroy: Quick-kill command is now set to: '", quick_kill_command, "'")
    end
end

function xset_silentMode(name, line, wildcards)
    if (not wildcards[1] or wildcards[1] == "") then
        InfoNote("Search and Destroy: Silent mode currently set to: '", silentMode, "'")
    else
        silentMode = wildcards[1]:lower()
        set_variable("mcvar_silentMode_command", silentMode)
        InfoNote("Search and Destroy: Silent mode is now set to: '", silentMode, "'")
    end
end

-- [[ Room search processes ]]
function search_rooms_exact(room, arid, mob_name)
    local select =
        string.format(
        [[
			SELECT uid, name, area
			FROM rooms
			WHERE name = %s AND area = %s
			ORDER BY area
		]],
        fixsql(room),
        fixsql(arid)
    )
    search_rooms(select, mob_name)
end

function search_rooms_fuzzy(room, arid)
    arid = arid or "all"
    local like_room = "%" .. room .. "%"
    local select =
        string.format(
        [[
			SELECT uid, name, area, 1 as DisplayOrder
			FROM rooms r
			WHERE name = %s AND (%s = 'all' OR area = %s)
			UNION
			SELECT uid, name, area, 0 as DisplayOrder
			FROM rooms
			WHERE name <> %s AND name LIKE %s AND (%s = 'all' OR area = %s)
			ORDER BY area, DisplayOrder DESC;
		]],
        fixsql(room),
        fixsql(arid),
        fixsql(arid),
        fixsql(room),
        fixsql(like_room),
        fixsql(arid),
        fixsql(arid)
    )
    search_rooms(select)
end

function search_rooms(query, mob_name)
    local db = assert(sqlite3.open(mapper_db_file))
    local results = {}
    local roomid_list = {}
    local has_results = false
    for row in db:nrows(query) do
        has_results = true
        local id = (tonumber(row.uid) or -1) -- sanitize text room ids for "unmappable" (nomap) rooms that are now being mapped
        table.insert(
            results,
            {
                rmid = id,
                name = row.name,
                arid = row.area
            }
        )
        if (id > 0) then -- make a list of room ids
            table.insert(roomid_list, fixsql(row.uid))
        end
    end

    if has_results then
        local notes_query =
            string.format("SELECT uid, notes FROM bookmarks WHERE uid in (%s);", table.concat(roomid_list, ","))
        for row in db:nrows(notes_query) do
            for i, room in ipairs(results) do
                if tostring(room.rmid) == row.uid then
                    room.notes = row.notes
                    break
                end
            end
        end
    end

    db:close_vm()

    if has_results and mob_name then
        local SnDdb = assert(sqlite3.open(snd_db_file))
        local count_by_room = {}
        local sum = 0

        select =
            string.format(
            "SELECT roomid, seen_count FROM mobs WHERE mob = %s AND roomid in (%s);",
            fixsql(mob_name),
            table.concat(roomid_list, ",")
        )
        DebugNote("Searching for mob: ", select)

        for row in SnDdb:nrows(select) do
            count_by_room[row.roomid] = row.seen_count
            sum = sum + row.seen_count
        end
        SnDdb:close_vm()

        for i, result in ipairs(results) do
            result.seen_count = count_by_room[result.rmid] or 0
            if sum > 0 then
                result.percentage = (result.seen_count / sum)
            else
                result.percentage = 0
            end
        end

        table.sort(results, sort_rooms_by_seen_count)
    end

    search_rooms_results(results)
end

function sort_rooms_by_seen_count(a, b)
    if a.seen_count > b.seen_count then
        return true
    elseif a.seen_count < b.seen_count then
        return false
    else
        return a.rmid < b.rmid
    end
end

function search_rooms_results(results) -- Display list of 'go' links from hunt-trick, quick-where, etc.
    gotoArea = -1
    gotoIndex = 1
    next_room = -1
    gotoList = {}
    local mapper_area_index = 0
    local line_num = 0
    local note_width = table_width - 62
    local last_area = ""
    local has_chance = #results > 0 and results[1].percentage
    ColourTell("#808080", "", string.format("\nXCP  %-38s  %-7s  %-6s", "Location", "(uid)", ""))
    if has_chance then
        note_width = note_width - 11
        ColourTell("#808080", "", string.format("  %-9s", "(chance)"))
    end
    ColourTell("#808080", "", "  Notes")
    print("")
    ColourNote("#808080", "", string.rep("-", table_width))
    for i, v in ipairs(results) do
        line_num = line_num + 1
        local background = (line_num % 2) == 0 and text_colors.alternating_row or ""
        local instruction = "go " .. mapper_area_index
        if (last_area ~= v.arid) then
            local padding = string.rep(" ", table_width - 5 - #v.arid)
            if (mapper_area_index == 0) then
                local areaLine = string.format("%3d  %s%s", mapper_area_index, v.arid, padding)
                Hyperlink("go " .. mapper_area_index, areaLine, "go to area " .. v.arid, "silver", background, 0, 1)
                gotoList[mapper_area_index] = v.arid
                gotoArea = v.arid
                mapper_area_index = mapper_area_index + 1
            else
                local areaLine = string.format("     %s%s", v.arid, padding)
                Hyperlink("xrt " .. v.arid, areaLine, "go to area " .. v.arid, "silver", background, 0, 1)
            end
            print("")
            line_num = line_num + 1
            last_area = v.arid
        end
        background = (line_num % 2) == 0 and text_colors.alternating_row or ""
        local name = ellipsify(string.gsub(v.name, "@[a-zA-Z]", ""), 38)
        local text = string.format("%3d  %-38s  %-7s ", mapper_area_index, name, string.format("(%s)", v.rmid))
        Hyperlink("go " .. mapper_area_index, text, "go to item " .. mapper_area_index, "lightblue", background, 0, 1)

        local instruction = "mapper where " .. v.rmid
        local tooltip = "click for speedwalk to this room"
        Hyperlink(instruction, "   {sw}", tooltip, "#FF5000", background, 0, 1)
        gotoList[mapper_area_index] = v.rmid

        if v.percentage then
            local pct_string = string.format("%6.2f%%", v.percentage * 100)
            Hyperlink(instruction, "  (", tooltip, "silver", background, 0, 1)
            Hyperlink(instruction, pct_string, tooltip, mob_room_percentage_color(v.percentage), background, 0, 1)
            Hyperlink(instruction, ")", tooltip, "silver", background, 0, 1)
        end

        if v.notes then
            if show_notes_in_table() then
                text = ellipsify(strip_colours(v.notes), note_width)
            else
                text = "[notes]"
            end
            text = string.format("  %-" .. note_width .. "s", text)
            Hyperlink(string.format("roomnote %i", v.rmid), text, v.notes, "lightgreen", background, 0, 1)
        else
            ColourTell("", background, string.rep(" ", note_width + 2))
        end

        print("")
        mapper_area_index = mapper_area_index + 1
    end
    if (mapper_area_index == 0) then
        InfoNote("No matching rooms found.")
    end
    ColourNote("#808080", "", string.rep("-", table_width))
    ColourNote("#808080", "", "Type 'go <index>' or click link to go to that room.\n")
end

-- Return a color between #aaaaaa (grey, at 0%) and #44ff00 (green, at 100%)
function mob_room_percentage_color(percentage)
    local red_from, red_to = 170, 68
    local green_from, green_to = 170, 255
    local blue_from, blue_to = 170, 0

    -- using the straight percentage was resulting in numbers being too grey
    percentage = math.min(1, math.max(0, math.sqrt(percentage)))

    return string.format(
        "#%02x%02x%02x",
        red_from + (red_to - red_from) * percentage,
        green_from + (green_to - green_from) * percentage,
        blue_from + (blue_to - blue_from) * percentage
    )
end

function map_area(name, line, wildcards)
    search_rooms_fuzzy(wildcards.loc, current_room.arid)
end

function map_area_all(name, line, wildcards)
    search_rooms_fuzzy(wildcards.loc)
end

--	[[ "xwhere" command ]]
function do_xwhere(name, line, wildcards)
    local n1 = tonumber(wildcards.n1) or 12 -- if no number given, default to 12
    local n2 = tonumber(wildcards.n2) or ""
    local mob = wildcards.mob or ""
    if (mob == "") then -- user entered no numbers, no mobname, or no args at all
        InfoNote("\nSearch and Destroy: 'xwhere' required parameter missing.\n")
        InfoNote("              Syntax: 'xwhere <mobname>'") -- default to 10
        InfoNote("                      'xwhere <n1> <mobname>'") -- where 1.mobname to n1.mobname
        InfoNote("                      'xwhere <n1> <n2> <mobname>'") -- where 1.mobname to n2.mobname
        return
    elseif (n2 == "") then -- user entered one number (n1) and a mobname, but no second number (n2)
        InfoNote("\nSearch and Destroy: 'xwhere ", n1, " ", mob, "'")
        for i = 1, n1, 1 do
            if (i == 1) then
                Send("where " .. mob)
            else
                Send("where " .. i .. "." .. mob)
            end
        end
    elseif (mob ~= "") and (n2 ~= "") then -- user entered n1, n2, and mobname
        InfoNote("Search and Destroy: 'xwhere ", n1, " ", n2, " ", mob, "'")
        for i = n1, n2, 1 do
            if (i == 1) then
                Send("where " .. mob)
            else
                Send("where " .. i .. "." .. mob)
            end
        end
    else
        InfoNote("Search and Destroy: 'xwhere' data entry problem!")
    end
end

--	[[ Autohunt ]]
function auto_hunt(name, line, wildcards)
    local s = string.lower(wildcards.arg)
    if (s == "abort") or (s == "cancel") or (s == "0") then
        auto_hunt_abort()
    else
        ht_reset()
        EnableTriggerGroup("AutoHunt", true)
        auto_hunt_mob = s
        Send("hunt " .. s)
    end
end

function auto_hunt_noarg()
    EnableTriggerGroup("AutoHunt", true)
    if current_target then
    	auto_hunt_mob = current_target.keyword
    	Send("hunt " .. auto_hunt_mob)
    else
	Send("ahem")
    end
end

function auto_hunt_abort()
    auto_hunt_reset()
    InfoNote("Search and Destroy:  Auto-hunt cancelled.\n")
end

function auto_hunt_complete()
    auto_hunt_reset()
    InfoNote("Search and Destroy: Auto-hunt complete.\n")
end

function auto_hunt_lowskill()
    InfoNote("\nSearch and Destroy:  Autohunt not available - hunt skill is too low.")
    InfoNote("                     If hunt skill is available, practice it to 85% or higher.")
    auto_hunt_reset()
end

function auto_hunt_move(direction)
    local ri = current_room
    local dir = dir_map[direction]
    auto_hunt_direction = dir
    if (ri) then -- don't know our gmcp exits, so just go with it
        if (ri.exits[dir] == nil) then -- exit is visible in gmcp
            Send("open " .. dir)
        end
    end
    Send(dir)
end

function auto_hunt_next(name, line, wildcards)
    local dir = wildcards.dir
    auto_hunt_move(dir)
    Send("hunt " .. auto_hunt_mob)
end

function auto_hunt_door()
    EnableTrigger("trg_autohunt_next_1", false)
    EnableTrigger("trg_autohunt_next_2", false)
    Send("open " .. auto_hunt_direction)
end

function auto_hunt_door_open()
    EnableTrigger("trg_autohunt_next_1", true)
    EnableTrigger("trg_autohunt_next_2", true)
    Send(auto_hunt_direction)
    Send("hunt " .. auto_hunt_mob)
end

function auto_hunt_portal()
    InfoNote(
        "\nSearch and Destroy: Auto-hunt through portals not working yet.  Enter portal manually and then autohunt again."
    )
    auto_hunt_reset()
end

function auto_hunt_reset()
    EnableTriggerGroup("AutoHunt", false)
    auto_hunt_mob = ""
    auto_hunt_direction = ""
    autoHuntData = {count = 0, north = 0, south = 0, east = 0, west = 0, up = 0, down = 0}
end

--	[[ Automatic noexp ]]
function xset_noexp_tnl(name, line, wildcards) -- called by alias: "xset noexp" when argument given
    local set_tnl = wildcards.arg or "-1"
    if (anex_automatic_onoff == "on") then
        if (wildcards.arg == "-1") or (wildcards.arg == "") or (wildcards.arg == nil) then
            if (anex_tnl_cutoff == 0) then
                InfoNote("Search and Destroy: Auto 'noexp' is currently OFF.")
            else
                InfoNote("Search and Destroy: Auto 'noexp' is ON and set to ", anex_tnl_cutoff, " TNL.\n")
            end
        elseif (wildcards.arg == "off") or (wildcards.arg == "0") then -- "xset noexp off" and "xset noexp 0" turn auto-noexp off.
            EnableTrigger("trg_anex_mobdeath_xp1", false)
            anex_tnl_cutoff = 0
            set_variable("mcvar_anex_tnl_cutoff", anex_tnl_cutoff)
            InfoNote("\nSearch and Destroy: Auto 'noexp' is now OFF.\n")
        else -- xset with any other (positive) number turns auto-noexp on.
            EnableTrigger("trg_anex_mobdeath_xp1", true)
            anex_tnl_cutoff = tonumber(set_tnl)
            set_variable("mcvar_anex_tnl_cutoff", anex_tnl_cutoff)
            InfoNote("\nSearch and Destroy: Auto 'noexp' now set to ", anex_tnl_cutoff, " TNL.\n")
        end
    else
        InfoNote("\nSearch and Destroy: 'noexp' is *manually* OFF.\nType 'noexp' again to turn it back on.")
    end
    xg_draw_window()
end

function anex_set_noexp(x)
    if (anex_automatic_onoff) == "on" then
        if (x == "on") or (x == "off") then
            noexp_onoff = x
            send_gmcp_packet("config noexp " .. x)
            print("noexp: " .. noexp_onoff)
        end
    else
        noexp_onoff = "off"
    end
    xg_draw_window()
end

function anex_can_get_new_cp() -- called by line 'You may take campaign this level.' in 'cp check'
    if (anex_automatic_onoff == "on") then
        if (anex_tnl_cutoff > 0) then -- if anex_tnl_cutoff > 0 then auto-noexp is on.
            local level = tonumber(gmcp("char.status.level"))
            if not level then
                return
            elseif (level < 200) then
                local tnl = tonumber(gmcp("char.status.tnl"))
                if (tnl < anex_tnl_cutoff) and (noexp_onoff == "off") then -- tnl less than set point and noexp is off --> turn that shit on
                    anex_set_noexp("on")
                    InfoNote("\nSearch and Destroy: Turning 'noexp' ON (Your TNL is less than ", anex_tnl_cutoff, ")")
                elseif (tnl > anex_tnl_cutoff) and (noexp_onoff == "on") then -- if over min TNL and noexp is on --> turn noexp off regardless
                    anex_set_noexp("off")
                    InfoNote(
                        "\nSearch and Destroy: Turning 'noexp' OFF (your TNL is greater than ",
                        anex_tnl_cutoff,
                        ")"
                    )
                end
            else
                if (noexp_onoff == "on") then
                    anex_set_noexp("off")
                    InfoNote("\nSearch and Destroy: Turning noexp OFF (you have reached level ", plevel, ")")
                end
            end
        else -- feature is turned off, just show reminder
            anex_tnl_cutoff = 0 -- set to 0 if somehow negative
            InfoNote("Automatic 'noexp' is currently turned OFF.\n")
        end
    end
end

function anex_must_level_new_cp() -- called by trigger:  You must level to get a new campaign
    if anex_automatic_onoff == "on" then
        if (anex_tnl_cutoff > 0) then
            local level = tonumber(gmcp("char.status.level"))
            if not level then
                return
            end
            if (level < 200) then
                if (noexp_onoff == "on") and (player_on_cp == "yes") then
                    InfoNote("Search and Destroy: Turning noexp OFF (must level to get new cp)")
                    anex_set_noexp("off")
                end
            else
                if (noexp_onoff == "on") then
                    anex_set_noexp("off")
                    InfoNote("Search and Destroy: Turning noexp OFF (you have reached level ", level, ")")
                end
            end
        end
    end
end

function anex_mobdeath_xp1(name, line, wildcards) -- called when mob kill awards xp
    if (anex_automatic_onoff == "on") then
        local level = tonumber(gmcp("char.status.level"))
        if (anex_tnl_cutoff > 0) then
            if (level < 200) then
                DoAfterSpecial(0.1, [[ anex_mobdeath_xp2() ]], 12)
            else
                if (noexp_onoff == "on") then
                    anex_set_noexp("off")
                    InfoNote("Search and Destroy: Turning noexp OFF (you have reached level ", level, ")")
                    InfoNote("                    Use 'xset noexp off' to override.")
                end
            end
        end
    end
end

function anex_mobdeath_xp2() -- called via timer set by function anex_mobdeath_xp1
    if (anex_automatic_onoff == "on") then
        local tnl = tonumber(gmcp("char.status.tnl"))
        if (can_get_new_cp == "yes") then
            if (tnl < anex_tnl_cutoff) then
                if (noexp_onoff == "off") then
                    anex_set_noexp("on")
                    InfoNote("\nSearch and Destroy: Turning 'noexp' ON (your TNL is less than ", anex_tnl_cutoff, ")")
                end
            else
                if (noexp_onoff == "on") then
                    anex_set_noexp("off")
                    InfoNote(
                        "\nSearch and Destroy: Turning 'noexp' OFF (your TNL is greater than ",
                        anex_tnl_cutoff,
                        ")"
                    )
                end
            end
        else
            if (noexp_onoff == "on") then
                anex_set_noexp("off")
                InfoNote("\nSearch and Destroy: Turning 'noexp' OFF (you must level before taking a new campaign)")
            end
        end
    end
end

function anex_check_tnl_silent() -- used by the window's clickable TNL cutoff changer
    local tnl = tonumber(gmcp("char.status.tnl"))
    if (can_get_new_cp == "yes") then
        if (tnl < anex_tnl_cutoff) then
            if (noexp_onoff == "off") then
                anex_set_noexp("on")
            end
        else
            if (noexp_onoff == "on") then
                anex_set_noexp("off")
            end
        end
    else
        if (noexp_onoff == "on") then
            anex_set_noexp("off")
        end
    end
end

function anex_automatic_on() -- Noexp will toggle automatically according to the TNL setting.
    anex_automatic_onoff = "on"
    noexp_onoff = "off"
    set_variable("mcvar_anex_automatic_onoff", "on")
    xg_draw_window()
end

function anex_automatic_off() -- Manually turns off experience and disables automatic toggling.  Typing noexp again turns the automatics back on.
    anex_automatic_onoff = "off"
    noexp_onoff = "on"
    set_variable("mcvar_anex_automatic_onoff", "off")
    xg_draw_window()
end

function xset_to_mark(name, line, wildcards)
    local ri = current_room
    local areaName = (type(wildcards[1]) == "string" and wildcards[1] ~= "" and wildcards[1]) or ri.arid
    local roomID   = (type(tonumber(wildcards[2])) == "number" and wildcards[2] ~= "" and wildcards[2]) or ri.rmid
    area_start_rooms[areaName] = {}
    area_start_rooms[areaName].roomid = roomID
    if debug_mode == "on" then
        tprint(area_start_rooms)
    end
    local serial = serialize.save_simple(area_start_rooms)
    set_variable("mcvar_areaStartRooms", serial)

    local db = assert(sqlite3.open(snd_db_file))
    operation = string.format("UPDATE area SET startRoom = %s WHERE key = %s;", fixsql(ri.rmid), fixsql(ri.arid))
    db:exec(operation)
    db:close_vm()

    InfoNote("\nxset mark: Room ", roomID, " set as start of area ", areaName, ".\n")
end

function get_start_room(area_id, exact)
    local arid = string.lower(area_id)
    start_room_type = "xset mark" -- If 'xset mark' was set, xrunto will go there.
    local possible_room_type
    if area_start_rooms[arid] then -- Function exits as soon as any 'return' statement is encountered.
        return area_start_rooms[arid].roomid -- Exact match on area id
    end

    local possible_match = nil
    for k, v in pairs(area_start_rooms) do
        if k:lower() == arid then -- exact match
            return v.roomid
        elseif string.match(string.lower(k), arid) then
            possible_room_type = "xset_mark"
            possible_match = v.roomid
        end
    end
    start_room_type = "default" -- If 'xset mark' isn't set, look up start room from the table areaDefaultStartRooms.
    if areaDefaultStartRooms[arid] then -- Note, Upper/Lower Planes have the same default room.  More development needed here.
        return areaDefaultStartRooms[arid].start -- exact match on area id
    end
    for k, v in pairs(areaDefaultStartRooms) do
        if k:lower() == arid then -- exact match
            return v.start
        elseif string.match(string.lower(k), arid) then
            possible_room_type = possible_room_type or "default"
            possible_match = possible_match or v.start
        end
    end
    if possible_match and not exact then
        start_room_type = possible_room_type
        return possible_match
    else
        return "-1"
    end
end

--  [[ "xset gqalias" ]]
function xset_gqalias(name, line, wildcards)
    local x = xset_gq_check_extra_aliases
    x = (x == "on") and "off" or "on"
    xset_gq_check_extra_aliases = x
    set_variable("mcvar_xset_gq_check_extra_aliases", x)
    apply_xset_gqalias()
    InfoNote("\nExtra 'gq check' aliases are now ", string.upper(x), "\n")
end

function apply_xset_gqalias()
    if (xset_gq_check_extra_aliases == "on") then
        EnableAlias("extra_gq_check_aliases", true)
    else
        EnableAlias("extra_gq_check_aliases", false)
    end
end

--	[[ "xset vidblain" ]]
function xset_vidblain(name, line, wildcards)
    local x = xset_vidblain_onoff
    x = (x == "on") and "off" or "on"
    xset_vidblain_onoff = x
    set_variable("mcvar_xset_vidblain_onoff", x)
    InfoNote("\nVidblain navigation is now ", string.upper(x), "\n")
end

function xset_vidblain_setlevel(name, line, wildcards)
    local x = tonumber(wildcards.level) or "check"
    if (x == "check") then
        InfoNote("\n'xset vidblain' portal level is ", xset_vidblain_level, "\n")
    else
        xset_vidblain_level = x
        set_variable("mcvar_xset_vidblain_level", x)
        InfoNote("\n'xset vidblain' portal level set to ", x, "\n")
    end
end

local is_vidblain_area_sql = "SELECT area FROM rooms WHERE uid = %s "

function is_vidblain_area(roomid)
    local level = tier_level()
     --tonumber(gmcp("char.status.level")) + 10 * tonumber(gmcp("char.base.tier"))
    if (xset_vidblain_onoff == "on") and (level < xset_vidblain_level) then
        --local worldPath = GetInfo(66) .. Trim(sanitize_filename(WorldName()))
        --local db = assert(sqlite3.open(worldPath .. ".db"))
        local db = assert(sqlite3.open(mapper_db_file))
        local select = string.format(is_vidblain_area_sql, fixsql(roomid))
        local ar
        for row in db:nrows(select) do
            ar = row.area
        end
        db:close_vm()
        if (vidblain_area_list[ar]) then
            return true
        else
            return false
        end
    else
        return false
    end
end

--	[[ Simulate cp ]]
function simulate_cp(name, line, wildcards)
    if (wildcards.type == "") then
        area_room_type = "area"
        current_activity = "cp"
    else
        area_room_type = wildcards.type
        current_activity = "cp"
    end
    local time_check = os.clock() -- prevent double cp checks from different plugins
    if ((time_check - last_cp_check) < 1.0) then
        return
    end
    last_cp_check = time_check
    cp_check_list = {}
    EnableTrigger("trg_cp_check_line", true)
    Simulate("\n")
    if (area_room_type == "area") then
        Simulate("You still have to kill * red velvet (tm) lipstick (Andolor's Ocean Adventure Park)\n")
        Simulate("You still have to kill * the crypt thing (The Gauntlet)\n")
        Simulate("You still have to kill * an ultroloth (The Lower Planes)\n")
        Simulate("You still have to kill * (Helper) Fenix (The School of Horror)\n")
        Simulate("You still have to kill * the head necromancer's assistant (Necromancers' Guild)\n")
        Simulate("You still have to kill * Isscheburqua (Insanitaria)\n")
        Simulate("You still have to kill * a rook citizen (Avian Kingdom - Dead)\n") -- dead
        Simulate("You still have to kill * Lea, the farmer's daughter (Farmyard)\n") -- unknown
        Simulate("You still have to kill * a former court jester (The Labyrinth)\n")
        Simulate("You still have to kill * Parent (A Cold Path - Dead)\n") --dead and unknown
        Simulate("You still have to kill * a wealth redistribution specialist (Empyrean, Streets of Downfall)\n") -- long unnknown
        Simulate(
            "You still have to kill * a wealth redistribution specialist (Empyrean, Streets of Downfall and Upfall and Other Things)\n"
        ) -- really long unnknown
        Simulate(
            "You still have to kill * Laurence, archangel of the sword and shield and other implements of war (The Flying Citadel)\n"
        ) -- long known
        Simulate("You still have to kill * a sinister vandal (The Three Pillars of Diatz)\n") -- noscan
        Simulate("You still have to kill * a hideously hairy spider (The Temple of Shouggoth)\n") -- nowhere
        Simulate("You still have to kill * Don Crumble (Zangar's Demonic Grotto)\n") -- nohunt
        Simulate("You still have to kill * A very large firefly (Kobold Siege Camp)\n") -- nohunt/nowhere
    else
        Simulate("You still have to kill * red velvet (tm) lipstick (Skirting a Fissure)\n")
        Simulate("You still have to kill * a staggering barbegazi (Cell block A (Lower))\n")
        Simulate("You still have to kill * a former court jester (The Labyrinth)\n")
        Simulate("You still have to kill * the iron golem (Audience Chamber)\n")
        Simulate("You still have to kill * probably a fake mob (Probably a Fake Room)\n")
        Simulate("You still have to kill * Jarre (The UnderDark - Dead)\n") -- known dead
        Simulate("You still have to kill * the heart of a sandstorm (Buried in the Great Desert's unrelenting dunes)\n") -- long
        Simulate("You still have to kill * Parent (The Kitchen)\n") -- lots of options
        Simulate("You still have to kill * A sprite prisoner (A cell)\n")
        Simulate("You still have to kill * the cutpurse (Road of Shadows)\n") -- many rooms
        Simulate("You still have to kill * definitely a fake mob (Fake Area - Dead)\n") -- unknown dead
        Simulate("You still have to kill * the gibbering mouther (Dining Hall)\n") -- lots of options
        Simulate("You still have to kill * a sinister vandal (In The Courtyard)\n") -- noscan
        Simulate("You still have to kill * a hideously hairy spider (The Landing)\n") -- nowhere
        Simulate(
            "You still have to kill * Sssssuper long mob name that should break formatting (This can't be a real room, right)\n"
        ) -- long unknown
        Simulate(
            "You still have to kill * Laurence, archangel of the sword and shield and other implements of war (In the clouds)\n"
        ) -- long known
        Simulate("You still have to kill * a giant bee (An Impossibly Dark Intersection in the Labyrinth)\n") -- long room name
    end
    Simulate("Note: Dead means that the target is dead, not that you have killed it.\n")
    Simulate("\n")
    Simulate("You have 6 days, 23 hours and 56 minutes left to finish this campaign.\n")
    Simulate("\n")
end

function spoof_gq_level_range()
    local level = tonumber(gmcp("char.status.level"))
    local min = math.max(level - 10, 1)
    local max = math.min(level + 10, 201)

    return min, max
end

function simulate_declare_gq(name, line, wildcards)
    local min, max = spoof_gq_level_range
    local gq_num
    if #wildcards.num then
        gq_num = math.min(10000, tonumber(wildcards.num))
    else
        gq_num = math.random(1, 10000)
    end

    Simulate(string.format("Global Quest: Global quest #%i has been declared for levels %i to %i\n", gq_num, min, max))
end

function xtest_debug_gquest()
    if debug_mode ~= "on" then
        xtest_debug()
    end

    player_not_on_gq()

    gqid_started = "-1"
    -- gqid_joined = "-1"
    -- gqid_extended = "-1"

    debug_gq_mode = not debug_gq_mode

    mock_gquests = {}
    DebugNote("GQuest Debug mode ", debug_gq_mode and "enabled" or "disabled")
end

function assert_debug_gq_mode()
    if not debug_gq_mode then
        ErrorNote("Not in Gquest testing mode.")
        return false
    end

    return true
end

function xtest_gq_waiting(name, line, wildcards)
    if not assert_debug_gq_mode() then
        return
    end

    local gqid = tonumber(wildcards.num) or 123
    mock_gquests[gqid] = {state = "waiting", id = gqid}
    Simulate(string.format("Global Quest: Global quest # %i has been declared for levels 1 to 201\n", gqid))
    DebugNote("Added mock gquest ", gqid, " in waiting state.")
end

function xtest_gq_start(name, line, wildcards)
    if not assert_debug_gq_mode() then
        return
    end
    local targets
    local gqid = tonumber(wildcards.num) or 123
    local type = wildcards.type

    if type == "" then
        type = "area"
    end

    if type == "area" then
        targets = gq_area_targets()
    else
        targets = gq_room_targets()
    end

    mock_gquests[gqid] = {state = "running", id = gqid, targets = targets}
    Simulate(string.format("Global Quest: Global quest # %i for levels 1 to 201 has now started.\n", gqid))
    DebugNote("Added mock gquest ", gqid, " (", type .. "-type", ") in running state state.")
end

function xtest_gq_join(name, line, wildcards)
    if not assert_debug_gq_mode() then
        return
    end
    local gqid = tonumber(wildcards.num)

    if gqid == 0 then
        mock_gqid_joined = 0
        gqid_joined = "-1"
        DebugNote("Removed from any gquests")
    elseif wildcards.silent == "s" then
        xtest_gq_joined_already(gqid)
    else
        xtest_gq_join_now(gqid)
    end
end

function xtest_gq_joined_already(gqid)
    if mock_gquests[gqid] then
        mock_gqid_joined = gqid
        DebugNote("Silently joining gq ", gqid)
    else
        DebugNote("No mock gq #", gqid, " is running")
    end
end

function xtest_gq_join_now(gqid)
    if mock_gquests[gqid] then
        mock_gqid_joined = gqid
        Simulate(
            string.format("You have now joined Global Quest # %i. See 'help gquest' for available commands.\n", gqid)
        )
    else
        DebugNote("No mock gq #", gqid, " is running")
    end
end

function xtest_gq_end(name, line, wildcards)
    if not assert_debug_gq_mode() then
        return
    end
    local gqid = tonumber(wildcards.num) or 123
    if mock_gquests[gqid] then
        simulate_gq_end(gqid)
        mock_gquests[gqid] = nil
    else
        DebugNote("No mock gq #", gqid, " is running")
    end
end

function xtest_gq_win(name, line, wildcards)
    if not assert_debug_gq_mode() then
        return
    end
    local gqid = tonumber(wildcards.num) or 123
    if mock_gquests[gqid] then
        simulate_gq_win(gqid)
        mock_gquests[gqid] = nil
    else
        DebugNote("No mock gq #", gqid, " is running")
    end
end

function xtest_gq_lose(name, line, wildcards)
    if not assert_debug_gq_mode() then
        return
    end

    local gqid = tonumber(wildcards.num) or 123
    local noextended = #wildcards.noextended > 0
    if mock_gquests[gqid] then
        simulate_gq_lose(gqid, noextended)
        if noextended then
            mock_gquests[gqid] = nil
        end
    else
        DebugNote("No mock gq #", gqid, " is running")
    end
end

function xtest_gq_kill(name, line, wildcards)
    if not assert_debug_gq_mode() then
        return
    end

    local kill_num = tonumber(wildcards.num) or 1
    if mock_gquests[mock_gqid_joined] then
        simulate_gq_kill(kill_num)
    elseif mock_gqid_joined then
        DebugNote("No mock gq #", mock_gqid_joined, " is running")
    else
        DebugNote("You're not in a gquest")
    end
end

function xtest_gq_quit(name, line, wildcards)
    if not assert_debug_gq_mode() then
        return
    end

    local gqid = tonumber(wildcards.num) or 123
    Simulate(string.format("You are no longer part of Global Quest # %i and will be unable to rejoin.\n", gqid))
end

function xtest_xcp(name, line, wildcards)
    local index = tonumber(wildcards.num) or 1
    if index > 0 and #main_target_list > 0 then
        index = math.min(#main_target_list, index)

        set_target_from_main_target_list(index)
        DebugNote("Targeting xcp ", index)

        xg_draw_window()
    else
        DebugNote("Clearing xcp index")
        xcp_clear_target(true)
    end
end

function simulate_gq_info(number, targets)
    Simulate("\n")
    Simulate("---------------------[  CURRENT GLOBAL QUEST DETAILS ]---------------------\n")
    Simulate(string.format("Quest Name.........: [ Global quest # %i ]\n", number))
    Simulate("Quest Type ........: [ Main Group ]\n")
    Simulate("Quest Status.......: [ Active ]\n")
    Simulate("Level range........: [  186 ] - [  201 ]\n")
    Simulate("Quest Duration.....: [   98 ]\n")
    Simulate("Time Expired.......: [    0 ]\n")
    Simulate("Time Remaining.....: [   98 ]\n")
    Simulate("Inactivity Timer...: [ 00:00:11 ]\n")
    Simulate("-----------------------------[ Quest Rewards ]-----------------------------\n")
    Simulate("Quest points.......: [    13 ] ( +3 for each mob killed )\n")
    Simulate("Gold Coins.........: [ 18600 ]\n")

    if targets then
        Simulate("-----------------------------[ Quest Targets ]-----------------------------\n")
        Simulate("To complete this quest, you must:\n")

        for i, mob in ipairs(targets) do
            Simulate(string.format("Kill at least %i * %s (%s).\n", mob.count or 1, mob.name, mob.location))
        end
    end

    Simulate("---------------------------------------------------------------------------\n\n")
end

function simulate_gq_check(targets)
    for i, mob in ipairs(targets) do
        Simulate(string.format("You still have to kill %i * %s (%s)\n", mob.count or 1, mob.name, mob.location))
    end
    Simulate("\n")
end

function gq_area_targets()
    return {
        {count = 1, name = "red velvet (tm) lipstick", location = "Andolor's Ocean Adventure Park"},
        {count = 2, name = "a horse", location = "Kul Tiras"},
        {count = 1, name = "a horse", location = "Kul Tiras"},
        {count = 1, name = "a treble clef", location = "Art of Melody"},
        {count = 1, name = "a spider", location = "Gallows Hill"},
        {count = 2, name = "800 baby spiders", location = "Gallows Hill"},
        {count = 1, name = "a Boy", location = "Gallows Hill"},
        {count = 1, name = "some wicked ale", location = "Gallows Hill"},
        {count = 3, name = "a grub", location = "Kimr's Farm"},
        {count = 1, name = "a bobwhite quail", location = "The Forest of Li'Dnesh"},
        {count = 1, name = "a small dark viper", location = "The Forest of Li'Dnesh"},
        {count = 1, name = "a hook-tailed dragonfly", location = "The Forest of Li'Dnesh"},
        {count = 2, name = "a golden honeybee", location = "The Forest of Li'Dnesh"},
        {count = 1, name = "a tiny red imp", location = "The Grand City of Aylor"},
        {count = 1, name = "a little girl", location = "The Land of the Beer Goblins"},
        {count = 1, name = "a true believer", location = "The Path of the Believer"}
    }
end

function gq_room_targets()
    return {
        {count = 1, name = "red velvet (tm) lipstick", location = "Cell block A (Lower)"},
        {count = 1, name = "Earshda the receptionist", location = "The Reception Area"},
        {count = 1, name = "a chorus girl", location = "Upstage Centre"},
        {count = 1, name = "a caretaker", location = "Entering Room 5"},
        {count = 1, name = "a Nulan'Boar mother", location = "A small grassy paddock"},
        {count = 1, name = "an agathinon aasimon", location = "In a Great Field on Arcadia"},
        {count = 1, name = "Prince Beelzebub", location = "The Training Field"},
        {count = 1, name = "an ant", location = "The Land of Oz"},
        {count = 1, name = "a taller man", location = "Patient Room 5"},
        {count = 1, name = "a Mud Dweller", location = "Within The Secret Passage"},
        {count = 1, name = "Duke Malagard", location = "The Jewelled Palace"},
        {count = 1, name = "a rabid rabbit", location = "Path to the castle"},
        {count = 1, name = "a heavily built goblin guard", location = "Before the fortress"},
        {count = 1, name = "a cottonmouth", location = "Thick vegetation on the river bank"},
        {count = 1, name = "a light aasimon", location = "On the Belierin layer of the Elysium"}
    }
end

function simulate_gq_end(gqid)
    Simulate(string.format("Global Quest: Global quest # %i (extended) is now over.\n", gqid))
end

function simulate_gq_win(gqid)
    simulate_gq_winner_message(gqid, gmcp("char.base.name"))
end

function simulate_gq_lose(gqid, extended)
    simulate_gq_winner_message(gqid, "Someone Else")
    if extended then
        Simulate(
            string.format("Global Quest: Global Quest # %i will go into extended time for 5 more minutes.\n", gqid)
        )
    end
end

function simulate_gq_winner_message(gqid, name)
    Simulate(string.format("Global Quest: Global Quest # %i has been won by %s - 53rd win.\n", gqid, name))
end

function simulate_send_gq_info(gqid)
    DebugNote("Simulating ", string.format("gq info %s", tostring(gqid)))
    local gq_info
    if gqid then
        gq_info = mock_gquests[tonumber(gqid)]
    elseif mock_gqid_joined then
        gq_info = mock_gquests[mock_gqid_joined]
    end

    if gq_info then
        simulate_gq_info(gq_info.id, gq_info.targets)
    else
        local first_gq
        local gq_count = 0

        for k, v in pairs(mock_gquests) do
            gq_count = gq_count + 1
            first_gq = first_gq or v
        end

        if gq_count == 0 then
            Simulate("There are no global quests running.\n")
        elseif gq_count == 1 then
            simulate_gq_info(first_gq.id)
        else
            Simulate("There is more than one global quest running.\n")
        end
    end
end

function simulate_send_gq_check()
    DebugNote("Simulating ", "gq check")
    if mock_gqid_joined then
        local gq_info = mock_gquests[mock_gqid_joined]
        if gq_info then
            if gq_info.state == "running" then
                simulate_gq_check(gq_info.targets)
            else
                Simulate(string.format("Global quest # %i has not yet started.", gq_info.id))
            end
            return
        end
    end
    Simulate("You are not in a global quest.\n")
end

function simulate_gq_kill(kill_num)
    mock_gq = mock_gquests[mock_gqid_joined]

    if mock_gq.targets and #mock_gq.targets >= kill_num then
        last_mob_killed = mock_gq.targets[kill_num].name

        local curr_arid = current_room.arid
        current_room.arid = areaNameXref[mock_gq.targets[kill_num].location] or curr_arid

        if mock_gq.targets[kill_num].count > 1 then
            mock_gq.targets[kill_num].count = mock_gq.targets[kill_num].count - 1
        else
            table.remove(mock_gq.targets, kill_num)
        end

        -- local old_arid = current_room.arid
        -- current_room.arid = mock_gq.targets[kill_num]
        Simulate("Congratulations, that was one of the GLOBAL QUEST mobs!\n")

        if #mock_gq.targets == 0 then
            simulate_gq_win(mock_gq.id)
        end
        current_room.arid = curr_arid
    else
        DebugNote("Target ", "#", "", kill_num, " is not on this gquest.")
    end
end

function echo_gqid_joined()
    if gqid_joined ~= "-1" then
        DebugNote("You are on gq # ", gqid_joined)
    else
        DebugNote("You are not on a gquest")
    end
end

function spoof_level(name, line, wildcards)
    local level = math.min(201, math.max(1, wildcards.level))
    gq_info_efflvl = level
    cp_info_level = level
    Note("Pretending level is ", level, " for testing purposes\n")
end

function simulate_quest(name, line, wildcards)
    local result = {
        targ = "a garden snake",
        area = "Kimr's Farm",
        room = "Old Farm Lane"
    }
    local status = wildcards.status
    if #status == 0 then
        status = "status"
    end

    InfoNote("Simulating quest with status ", status)

    if status == "start" then
        result.action = "start"
    elseif status == "status" then
        result.action = "status"
        result.timer = 60
    elseif status == "killed" then
        result.action = "killed"
    elseif status == "comp" then
        result.action = "comp"
    elseif status == "fail" then
        result.action = "fail"
    elseif status == "reset" then
        result.action = "reset"
    elseif status == "ready" then
        result.action = "ready"
    elseif status == "timeout" then
        result.action = "timeout"
    elseif status == "statkilled" then
        result.action = "status"
        result.target = "killed"
    elseif status == "wait" then
        result.action = "status"
        result.wait = 60
    elseif status == "ready" then
        result.action = "status"
        result.status = "ready"
    end

    quest_status_gmcp(result)
end

-- [[ Room notes ]]
function room_note_area(name, line, wildcards)
    if (wildcards.arid == "") then
        --get_notes(current_room.arid, nil)
        get_notes(gmcp("room.info.zone"), nil)
    else
        get_notes(wildcards.arid, nil)
    end
end

function room_note(name, line, wildcards)
    --get_notes(nil, current_room.rmid)
    if not get_notes(nil, gmcp("room.info.num")) then
        InfoNote("No notes found for room this room.\n")
    end
end

function room_note_room(name, line, wildcards)
    if not get_notes(nil, wildcards.roomid) then
        InfoNote(string.format("No notes found for room %s.\n", wildcards.roomid))
    end
end

function get_notes(arid, roomid, text_only)
    --local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
    --local db = assert(sqlite3.open(worldPath .. ".db"))
    local db = assert(sqlite3.open(mapper_db_file))
    local sql = " SELECT b.uid, b.notes "
    sql = sql .. " FROM bookmarks b "
    if arid then
        sql = sql .. " INNER JOIN rooms r ON b.uid = r.uid "
        sql = sql .. " WHERE r.area = " .. fixsql(arid)
    else
        sql = sql .. " WHERE b.uid = " .. fixsql(roomid)
    end
    sql = sql .. " ORDER BY b.uid "
    local found_notes = false
    if (arid ~= nil) then
        Simulate("\nNotes for " .. getAreaNameFromId(arid) .. "\n")
    end
    for row in db:nrows(sql) do
        found_notes = true
        if (text_only == true) then
            local line = string.format("    note:'%s'", strip_colours(row.notes))
            Hyperlink("xmapper move " .. row.uid, line, "go to room " .. row.uid, "lightblue", "black", 0, 1)
        else
            local line = string.format("    (%s) %s", row.uid, row.notes)
            local styles = ColoursToStyles(line, ColourNameToRGB("lightblue"), ColourNameToRGB("black"), 0, 0)

            for _, style in pairs(styles[1]) do
                Hyperlink(
                    "xmapper move " .. row.uid,
                    style.text,
                    "go to room " .. row.uid,
                    RGBColourToName(style.textcolour),
                    RGBColourToName(style.backcolour),
                    0,
                    1
                )
            end
        end

        print("")
    end
    db:close_vm()
    if not found_notes then
        if arid then
            Simulate("\tNo notes.\n")
        else
            return false
        end
    end
    return true
end

function getAreaIdFromName(name)
    local db = assert(sqlite3.open(mapper_db_file))
    local sql = "SELECT uid FROM areas WHERE name = %s"
    for row in db:nrows(string.format(sql, fixsql(name))) do
        db:close_vm()
        return row.uid
    end
    db:close_vm()
    return name
end

function getAreaNameFromId(arid)
    local db = assert(sqlite3.open(mapper_db_file))
    local sql = "SELECT name FROM areas WHERE uid = %s"
    for row in db:nrows(string.format(sql, fixsql(arid))) do
        db:close_vm()
        return row.name
    end
    db:close_vm()
    return arid
end

function getAreaFromRoomId(room_id)
    local db = assert(sqlite3.open(mapper_db_file))
    local sql = "SELECT area FROM rooms WHERE uid = %s"
    for row in db:nrows(string.format(sql, fixsql(room_id))) do
        db:close_vm()
        return row.area
    end
    db:close_vm()
    return room_id
end

function getAreaUid(name)
    local db = assert(sqlite3.open(mapper_db_file))
    local sql = "SELECT uid FROM areas WHERE name = %s order by uid "
    local areas = {}
    local index = 0
    for row in db:nrows(string.format(sql, fixsql(name))) do
        index = index + 1
        areas[index] = {uid = row.uid, name = name}
    end
    db:close_vm()
    return areas
end

--	[[ SQL execution ]]
function RunSql(name, line, wildcards)
    local worldPath = GetInfo(66) .. "/worlds/plugins/"
    local db = assert(sqlite3.open(snd_db_file))
    local index = 0
    local sql = wildcards.sql
    ColourNote("#00C040", "", "\nrunning sql: " .. sql)
    for row in db:nrows(sql) do
        index = index + 1
        print("----------- record " .. index .. " -----------")
        -- tprint(row)
        print(serialize.save("row", row))
    end
    db:close_vm()
end

function ExecSql(name, line, wildcards)
    local db = assert(sqlite3.open(mapper_db_file))
    Note("executing " .. wildcards.sql)
    --	dbcheck (db:execute (fixsql(wildcards.sql)))
    db:execute(fixsql(wildcards.sql))
    db:close_vm()
    Note("ok")
end

--	[[ page size functions ]]
local page_size = 0
local page_size_suspended = false

function capture_page_size(name, line, wildcards)
    EnableTrigger("trg_capture_page_size", false)
    local size = tonumber(wildcards[1])
    page_size = size or 0
    SendNoEcho("pagesize 0")
end

function suspend_page_size(name, line, wildcards)
    if (page_size_suspended == false) then
        page_size_suspended = true
        InfoNote("\nSearch and Destroy: Temporarily disabling pagesize (area index process)\n")
        EnableTrigger("trg_capture_page_size", true)
        EnableTrigger("trg_pagesize_gag_1", true)
        SendNoEcho("pagesize")
    end
end

function resume_page_size(name, line, wildcards)
    InfoNote("\nSearch and Destroy: Area index complete. Pagesize re-enabled (if >0)\n")
    EnableTrigger("trg_capture_page_size", false)
    if (page_size ~= 0) then
        SendNoEcho("pagesize " .. page_size)
    end
    page_size_suspended = false
end

function xmapper_move(name, line, wildcards)
    local r = wildcards.roomid
    local s = wildcards.speed
    if (r == "-1") then
        InfoNote("\nSearch and Destroy:  Can't go to room id -1 (nomap room)\n")
    elseif (r ~= "") then
        do_mapper_goto(r, s)
    end
end

function do_mapper_goto(r, s)
    if (s == nil or s == "") then
        s = speed
    end
    if (s == "walk") then
        --Note("walking to " .. r)
        Execute("mapper walkto " .. r)
    else
        Execute("mapper goto " .. r)
    end
end

--	[[ Former plugin - S&D GUI ]]
function clear_window_menu_hotspots()
    DebugNote("trying to clear all menu hotspots")
    for k, v in pairs(win_hotspots) do
        DebugNote("Deleting hotspot ", k)
        WindowDeleteHotspot(win, k)
    end
    win_hotspots = {}
end

local window_fonts = {
    ["title"] = {f = "Consolas", s = 10, b = false, i = false, u = false},
    ["bt1"] = {f = "Segoe", s = 10, b = true, i = false, u = false},
    ["circ1"] = {f = "Consolas", s = 11, b = false, i = false, u = false},
    ["circ2"] = {f = "Consolas", s = 9, b = false, i = false, u = false},
    ["cplevel"] = {f = "Consolas", s = 11, b = false, i = false, u = false},
    ["noexp"] = {f = "Consolas", s = 11, b = false, i = false, u = false}, --noexp tnl
    ["noexp2"] = {f = "Consolas", s = 9, b = false, i = false, u = false}
}

function xg_create_window(name, line, wildcards)
    if name then win_init = false end
    if (win_init == false) then
        win_init = true
        local width = win_width
        local height = win_height
	local left = ((windowinfo.window_left+width) < GetSystemMetrics(0) and windowinfo.window_left) or 0
	local top =  ((windowinfo.window_top+height) < GetSystemMetrics(1) and windowinfo.window_top) or 0
        WindowCreate(
            win,
            left,
            top,
            width,
            height,
            windowinfo.window_mode,
            windowinfo.window_flags,
            win_bgcolor
        ) -- create window
        for k, v in pairs(window_fonts) do
            WindowFont(win, k, v.f, v.s, v.b, v.i, v.u, false)
        end
        WindowFont(win, "cplist", win_font, win_font_size, win_font_bold, win_font_italic, win_font_underline, false)
        if not GetVariable("mcvar_xgui_window_onoff") then
            set_variable("mcvar_xgui_window_onoff", "on")
        end
        WindowShow(win, true and GetVariable("mcvar_xgui_window_onoff") == "on" or false) -- show it
        if (win_state == "min") then
            mouseup_drag(0, "hsMinimize")
        end
        if (IsPluginInstalled(plugin_id_z_order) and GetPluginInfo(plugin_id_z_order, 17)) then
            CallPlugin(plugin_id_z_order, "registerMiniwindow", win)
        end
        xg_draw_window()
    end
end

function xg_draw_window()
    WindowRectOp(win, miniwin.rect_fill, 0, 0, 0, 0, win_bgcolor) -- Clear the window, which is the first step in updating it
    WindowRectOp(win, 2, 0, 0, 0, 17, 0x000000) -- Draw title bar background and set color (almost black, "17" is height)
    WindowRectOp(win, 4, 0, 0, 0, 17, 0xE0E0E0, 0x909090) -- Draw title bar border (left/top = light grey, right/bottom = darker grey, "17" is height)
    WindowRectOp(win, 1, 0, 0, 0, 0, 0xC0C0C0, 15) -- Draw window border.
    WindowRectOp(win, 1, 1, 17, -1, -1, 0x000000, 15) -- Draw colored perimeter line.
    WindowText(
        win,
        "title", -- draw the window title text and set its color
        current_sd_version, -- window title text
        5,
        0,
        255,
        15, -- left (x1), top (y1), right (x2), bottom (y2) values for window title text
        0xA0FFFF, -- colour (light yellow)
        false
    ) -- not unicode
    if (win_hotspots["hsDrag1"] == nil) then -- make the title bar draggable
        win_hotspots["hsDrag1"] =
            WindowAddHotspot(
            win,
            "hsDrag1",
            0,
            0,
            win_width - 1,
            16, -- hotspot id, rectangle (left, top, right, bottom)
            "",
            "",
            "mousedown_drag",
            "",
            "mouseup_drag",
            "Left click = Drag title bar to move\nRight click = Send window to front/back",
            miniwin.cursor_arrow,
            0
        )
        WindowDragHandler(win, "hsDrag1", "dragmove", "dragrelease", 0)
    end

    local x_offset = 0
    if win_hide_settings_button == "off" then
        draw_settings_button(5, 20)
        x_offset = 40
    end
    draw_b1_action_buttons(47 + x_offset, 20) -- draw xcp, go, etc. buttons
    draw_circle_readout(5 + x_offset, 20) -- add circle text/level readout
    draw_noexp_readout(206 + x_offset, 22) -- add noexp on/off and TNL indicator
    draw_next_quest_time()
    draw_resize_tag()
    xg_show_target_links()
    Redraw()
end

local button_1_list = {
    --[[ 1 ]] ["hsXCP"] = {
        L = 0,
        text = "xcp",
        tdx = 3,
        tdy = 3,
        exec1 = "xcp",
        exec2 = "xcp 0",
        tooltip = "Left click = get target\nRight click = clear target"
    },
    --[[ 2 ]] ["hsGO"] = {
        L = 31,
        text = "go",
        tdx = 7,
        tdy = 3,
        exec1 = "go",
        exec2 = "go 0",
        tooltip = "Left click = Go to room 1\nRight click = Go to area start"
    },
    --[[ 3 ]] ["hsKK"] = {
        L = 62,
        text = "kk",
        tdx = 8,
        tdy = 3,
        exec1 = "kk",
        exec2 = "kk",
        tooltip = "Left click = 'kill' target mob\nRight click = kill with special"
    },
    --[[ 4 ]] ["hsNX"] = {
        L = 93,
        text = "nx",
        tdx = 7,
        tdy = 3,
        exec1 = "nx",
        exec2 = "nx-",
        tooltip = "Left click = goto next\nRight click = goto prev"
    },
    --[[ 5 ]] ["hsQS"] = {
        L = 124,
        text = "qs",
        tdx = 8,
        tdy = 3,
        exec1 = "qs",
        exec2 = "qs",
        tooltip = "Quick-scan for current target (cp, quest, ht, qw)"
    },
    --[[ 6 ]] ["hsQW"] = {
        L = 219,
        text = "qw",
        tdx = 5,
        tdy = 3,
        exec1 = "qw",
        exec2 = "qwx",
        tooltip = "Left click = Quick-where\nRight click = Quick-where exact"
    },
    --[[ 7 ]] ["hsHT"] = {
        L = 250,
        text = "ht",
        tdx = 9,
        tdy = 3,
        exec1 = "ht",
        exec2 = "hta",
        tooltip = "Left click = Do hunt trick\nRight click = Cancel hunt trick"
    },
    --[[ 8 ]] ["hsREF"] = {
        L = 281,
        text = "ref",
        tdx = 6,
        tdy = 3,
        exec1 = "xgui ref",
        exec2 = "xgui rel",
        tooltip = "Left click = Refresh target list - cp (gq) check\nRight click = Reload target data - cp (gq) info"
    }
}

function draw_b1_action_buttons(left, top)
    local b1 = button_1_list
    for hs, b in pairs(b1) do
        draw_button_1_A(left + b.L, top, b.text, hs, b.tooltip, b.tdx, b.tdy)
    end
end

function load_images()
    if images_loaded then
        return
    end

    images_loaded = true
    local mime = require("mime")
    local gear_base64 =
        "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAJPSURBVFhHtZeNNQQxEMeXCujgtgMq4CpABagAFXAV0AE6oAI6oAPXgevg/H97k7z9SDZz2N9787JfyUxmJpPsTrUly+XyWs2tZK950OVyNps92bWLXWu34UqSUg731rrJGqCZHjBbycweBXLKofNOffcyY0SSIVCHAzVvEgZcSc4kn5ILSWmWdwrDQmMc6/pRgvLVer2e13XNGB0GBvSU/ydJIzoGTKg8MDAiGmBx+pBMpTxASA8VpiU37SQkZlMrB3Sgq6FtwItkkCQTwMzfN5fDHMC6782dC9y5rddwf5xoqg4w6Bi8v5McSmoNxiRqyY2k1LdqK4e+ByizY+uczmchgfqYBwnlUfMgTVMn7LraMaXnElbBmDuZ3bw/gz5mBKspW/0EYyELDCDmnjh2LB9DY1IxqYJFyAFvEj1b64EwuMhuRn1ycU+hb3Gva0l7DShm92/xGsC2OpZUKVyhdYdAnFpbRMbyrctgDKCoeLi1JTaKfcOpqQRhfegXIooQdSHHuxJsbtcDTDljsAxzPEgWlqjJA0mpLtDxRgPEw6cp5iyBctox9oNy6HuAuH1t7lyEpVaqom3YP+KSjgbYLDgNlWbwV1DOjth4ob0KyNyplQPeijnSNsBdPv8IM49VMhpgLmGPnxJ08PcUT0SdQqQXWJYygo54yLMf8G1U0CIo73i6YwAkjAgd+TnxeIgzA7WCb+kLSeUwqAMBrQoSktPrizrGmZfqhL5tryzGOJG86nlyd8wakKNgwEqK9u3axSAEDiilObb6Na+qqvoBy3vRX8g9PVIAAAAASUVORK5CYII="

    -- local image_path = GetInfo(60) .. "images/gear_small.png"
    -- local f = io.open(image_path, "rb")
    -- local image_data = f:read("a*")
    -- local encoded
    -- f:close()
    -- encoded = mime.b64(image_data)
    -- Note("Base64:")
    -- Note(encoded)

    if not WindowLoadImageMemory(win, "gear", mime.unb64(gear_base64)) then
        ErrorNote("Image could not be decoded")
    end
end

function draw_settings_button(left, top, clicked)
    load_images()
    if images_loaded then
        local right = left + 36
        local bottom = top + 36
        local bgcolor = 0x000000
        local color_1 = 0xE0E0E0
        local color_2 = 0x808080

        if clicked then
            color_1, color_2 = color_2, color_1
        end

        WindowRectOp(win, 2, left, top, right, bottom, bgcolor, 0)
        WindowRectOp(win, 4, left, top, right, bottom, color_1, color_2)
        WindowDrawImageAlpha(win, "gear", left + 2, top + 2, right - 2, bottom - 2, 1, 0, 0)

        if (win_hotspots.config == nil) then
            -- Redoing the hotspot screws with mouseup actions so we'll leave the old one in place
            win_hotspots.config =
                WindowAddHotspot(
                win,
                "config",
                left,
                top,
                right,
                bottom,
                "",
                "",
                "config_mousedown",
                "config_mouseup",
                "config_mouseup_inside",
                "Settings",
                miniwin.cursor_arrow,
                0
            )
        end
    end
end

function config_mousedown()
    local left = WindowHotspotInfo(win, "config", 1)
    local top = WindowHotspotInfo(win, "config", 2)
    draw_settings_button(left, top, true)
    Redraw()
end

function config_mouseup()
    local left = WindowHotspotInfo(win, "config", 1)
    local top = WindowHotspotInfo(win, "config", 2)
    draw_settings_button(left, top)
    Redraw()
end

function config_mouseup_inside()
    config_mouseup()
    right_click_menu()
end

function draw_button_1_A(L, T, text, hsName, tooltip, tdx, tdy, clicked)
    local x, y, w, z = L, T, L + 30, T + 25
    local tx, ty = (x + tdx), (y + tdy) -- x and y values for text location
    local bgcolor = 0x000000
    local color_1 = 0xE0E0E0
    local color_2 = 0x808080
    local text_color = color_1

    if clicked then
        color_1, color_2 = color_2, color_1
    end

    WindowRectOp(win, 2, x, y, w, z, bgcolor) -- Draw background and set color (black)
    WindowRectOp(win, 4, x, y, w, z, color_1, color_2) -- Draw button border (left/top = light grey, right/bottom = darker grey)
    WindowText(win, "bt1", text, tx, ty, w - 1, z - 1, text_color, false) -- Draw button text ("button" font, light grey)
    if (win_hotspots[hsName] == nil) then -- Make button clickable by defining a hotspot
        win_hotspots[hsName] =
            WindowAddHotspot(
            win,
            hsName,
            x,
            y,
            w,
            z, -- Hotspot name and location info
            "",
            "",
            "mousedown_b1",
            "cancelmousedown_b1",
            "mouseup_b1", -- Mouse actions
            "" .. (tooltip or text),
            miniwin.cursor_arrow,
            0
        ) -- Tooltip text, cursor shape (hand)
    end
end

local win_circle_readout_vars = {
    ["cp"] = {cc, cc1 = "r", cc2y = "", tc1 = "", tc2 = "", tdx = "", tdy = "", text = ""},
    ["gq"] = {cc1n = "", cc2n = "", cc1y = "", cc2y = "", tc1 = "", tc2 = "", tdx = "", tdy = "", text = ""},
    ["init"] = {cc1n = "", cc2n = "", cc1y = "", cc2y = "", tc1 = "", tc2 = "", tdx = "", tdy = "", text = ""},
    ["none"] = {cc1n = "", cc2n = "", cc1y = "", cc2y = "", tc1 = "", tc2 = "", tdx = "", tdy = "", text = ""}
}

--local win_circle_readout_colors = { g1=0x30C000, g2=0x004000, r1=0x0040F0, r2=0x000080, u1=0xC08800, u2=0x403000, v1=0xC000C0, v2=0x400040 }
local win_circle_border_colors = {
    g = {0x30C000, 0x004000},
    r = {0x0040F0, 0x000080},
    u = {0xC08800, 0x403000},
    v = {0xC000C0, 0x400040}
}
local win_circle_text_colors

function draw_circle_readout(left, top)
    local level, ar_rm, get_new = cp_info_level, area_room_type, can_get_new_cp
    local activity = current_activity
    local width, height = 36, 36
    local cx1, cy1 = left + 1, top + 1
    local cx2, cy2 = (cx1 + width), (cy1 + height)
    local g1, g2, r1, r2, u1, u2, v1, v2 =
        0x30C000,
        0x004000,
        0x0040F0,
        0x000080,
        0xC08800,
        0x403000,
        0xC000C0,
        0x400040 -- green, red, blue, violet
    local tdx, tdy = 6, 8
    local circle_color_1, circle_color_2, text_color, text
    local font = "circ1"
    if (activity == "cp") then
        circle_color_1 = (get_new == "yes") and g1 or r1
        circle_color_2 = (get_new == "yes") and g2 or r2
        text_color_1 = 0xA0FFFF
        text_color_2 = 0x0C1830
        text = tostring(level)
        local llen = string.len(text)
        --if (llen == 3) then tdx = 6
        if (llen == 2) then
            tdx = 10
        elseif (llen == 1) then
            tdx = 14
        end
    elseif (activity == "none") then
        circle_color_1 = (get_new == "yes") and g1 or r1
        circle_color_2 = (get_new == "yes") and g2 or r2
        text_color_1 = (get_new == "yes") and 0x0050FF or 0x0070FF
        text_color_2 = 0x000040
        text = "off"
    elseif (activity == "gq") then
        circle_color_1 = v1
        circle_color_2 = v2
        text_color_1 = 0xA0FFFF
        text_color_2 = 0x0C1830
        text = "gq"
        tdx = 10
        tdy = 6
    elseif (activity == "init") then
        circle_color_1 = u1
        circle_color_2 = u2
        text_color_1 = 0xB0B0B0
        text_color_2 = 0x080808
        text = "init"
        font = "circ2"
        tdx = 4
        tdy = 10
    end

    --if (ar_rm == "none") then	-- player not on cp
    --	circle_color_1 = (get_new == "yes") and g1 or r1
    --	circle_color_2 = (get_new == "yes") and g2 or r2
    --	text_color_1 = (get_new == "yes") and 0x0050FF or 0x0070FF
    --	text_color_2 = 0x000040
    --	tdx = 6
    --	tdy = 8
    --	text = "off"
    --elseif (ar_rm == "init") then		-- plugin is loading, no info yet
    --	circle_color_1 = u1
    --	circle_color_2 = u2
    --	text_color_1 = 0xB0B0B0
    --	text_color_2 = 0x080808
    --	tdx = 4
    --	tdy = 10
    --	text = "init"
    --	font = "circ2"				-- show "init" in circle while plugin installs
    --	else							-- player is on cp or gq
    --		if (current_activity == "gq") then
    --			circle_color_1 = v1
    --			circle_color_2 = v2
    --			text_color_1 = 0xA0FFFF
    --			text_color_2 = 0x0C1830
    --			text = "gq"
    --			tdx = 10
    --			tdy = 6
    --		elseif (current_activity == "cp") then
    --			circle_color_1 = (get_new == "yes") and g1 or r1
    --			circle_color_2 = (get_new == "yes") and g2 or r2
    --			text_color_1 = 0xA0FFFF
    --			text_color_2 = 0x0C1830
    --			text = tostring(level)
    --			local llen = string.len(text)
    --			if (llen == 3) then tdx = 6
    --			elseif (llen == 2) then tdx = 10
    --			elseif (llen == 1) then tdx = 14
    --			else
    --				tdx = 6
    --				text = "err"
    --			end
    --		end
    --	end
    WindowCircleOp(win, 1, cx1 + 1, cy1 + 1, cx2 - 1, cy2 - 1, circle_color_2, 0, 2, win_bgcolor, 1) -- inner circle (dark)
    WindowCircleOp(win, 1, cx1 - 1, cy1 - 1, cx2 + 1, cy2 + 1, circle_color_2, 0, 2, win_bgcolor, 1) -- outer circle (dark)
    WindowCircleOp(win, 1, cx1, cy1, cx2, cy2, circle_color_1, 0, 2, win_bgcolor, 1) -- main circle (bright)
    local tx1, tx2, ty1, ty2 = (cx1 + tdx), (cx2), (cy1 + tdy), (cy2)
    WindowText(win, font, string.format("%s", text), tx1 + 1, ty1, tx2 + 1, ty2, text_color_2, false) -- text shadow effect
    WindowText(win, font, string.format("%s", text), tx1 + 2, ty1 + 1, tx2 + 2, ty2 + 1, text_color_2, false) -- text shadow effect
    WindowText(win, font, string.format("%s", text), tx1, ty1, tx2, ty2, text_color_1, false) -- actual text and color
end

function draw_noexp_readout(left, top)
    WindowDeleteHotspot(win, "hs_noexp")
    local symbol = {
        {x1 = 0, y1 = 0, x2 = 12, y2 = 0, c0 = 0x30FF00, c1 = 0x0030FF, th = 2}, -- top bar
        {x1 = 0, y1 = 3, x2 = 12, y2 = 3, c0 = 0x000000, c1 = 0x0030FF, th = 2}, -- second bar
        {x1 = 7, y1 = 6, x2 = 7, y2 = 21, c0 = 0x303030, c1 = 0x00073F, th = 1}, -- shadow vertical
        {x1 = 6, y1 = 6, x2 = 6, y2 = 21, c0 = 0xC0C0C0, c1 = 0x0060FF, th = 2}, -- vertical
        {x1 = 0, y1 = 10, x2 = 5, y2 = 5, c0 = 0xC0C0C0, c1 = 0x0060FF, th = 2}, -- left diagonal
        {x1 = 11, y1 = 10, x2 = 6, y2 = 5, c0 = 0xC0C0C0, c1 = 0x0060FF, th = 2}
    } -- right diagonal
    local text_color_1 = 0xA0FFFF
    local text_color_2 = 0x0C1830
    local tooltip = "Left click: +100 \nRight click: -100"
    for i, v in ipairs(symbol) do
        local color = (noexp_onoff == "on") and v.c1 or v.c0
        WindowLine(win, left + v.x1, top + v.y1, left + v.x2, top + v.y2, color, 256, v.th)
    end
    if (anex_automatic_onoff == "on") then
        --end
        WindowText(
            win,
            "noexp",
            string.format("%s", anex_tnl_cutoff),
            left + 18,
            top + 4,
            left + 62,
            top + 21,
            text_color_2,
            false
        )
        WindowText(
            win,
            "noexp",
            string.format("%s", anex_tnl_cutoff),
            left + 17,
            top + 4,
            left + 61,
            top + 20,
            text_color_2,
            false
        )
        WindowText(
            win,
            "noexp",
            string.format("%s", anex_tnl_cutoff),
            left + 16,
            top + 3,
            left + 60,
            top + 20,
            text_color_1,
            false
        )
        --if (win_hotspots["hs_noexp"] == nil) then																-- Make button clickable by defining a hotspot
        win_hotspots["hs_noexp"] =
            WindowAddHotspot(
            win,
            "hs_noexp",
            left,
            top,
            left + 55,
            top + 25, -- Hotspot name and location info
            "",
            "",
            "",
            "",
            "mouseup_noexp", -- Mouse actions
            "" .. (tooltip),
            miniwin.cursor_arrow,
            0
        ) -- Tooltip text, cursor shape (hand)
    else
        --end
        WindowText(
            win,
            "noexp2",
            string.format("%s", "manual"),
            left + 17,
            top + 4,
            left + 61,
            top + 21,
            text_color_2,
            false
        )
        WindowText(
            win,
            "noexp2",
            string.format("%s", "manual"),
            left + 16,
            top + 4,
            left + 60,
            top + 20,
            text_color_2,
            false
        )
        WindowText(
            win,
            "noexp2",
            string.format("%s", "manual"),
            left + 15,
            top + 3,
            left + 59,
            top + 20,
            text_color_1,
            false
        )
        --if (win_hotspots["hs_noexp"] == nil) then																-- Make button clickable by defining a hotspot
        win_hotspots["hs_noexp"] =
            WindowAddHotspot(
            win,
            "hs_noexp",
            left,
            top,
            left + 55,
            top + 25, -- Hotspot name and location info
            "",
            "",
            "",
            "",
            "mouseup_noexp", -- Mouse actions
            "" .. ("Noexp is manually off, type 'noexp' again to turn on"),
            miniwin.cursor_arrow,
            0
        )
    end
end

function quest_time_color()
    local color
    if quest_target.qstat == "2" then
        color = text_colors.targeted
    elseif quest_target.qstat == "0" then
        color = text_colors.quest_available
    elseif quest_target.qstat == "3" then
        color = text_colors.quest_complete
    else
        color = text_colors.quest_waiting
    end

    return ColourNameToRGB(color)
end

function draw_next_quest_time()
    if not next_quest_text then
        return
    end

    WindowRectOp(win, 2, win_width - 120, 1, win_width - 1, 16, 0)

    local width = WindowTextWidth(win, "title", next_quest_text)
    WindowText(win, "title", next_quest_text, win_width - width - 5, 1, win_width - 5, 16, quest_time_color(), false)
end

function quest_timer_text()
    if not next_quest_time then
        return
    end

    local quest_time = math.max(0, math.ceil((next_quest_time - os.time()) / 60))
    if quest_target.qstat == "2" or quest_target.qstat == "3" then
        return string.format("Quest time: %im", quest_time)
    else
        return string.format("Next quest: %im", quest_time)
    end
end

function quest_timer_tick()
    if not next_quest_time then
        return
    end

    local new_value = quest_timer_text()
    if new_value ~= next_quest_text then
        next_quest_text = new_value
        draw_next_quest_time()
        Redraw()
    end
end

function draw_resize_tag()
    local w = win_width
    local h = win_height
    local rts = 13
    local c1, c2 = 0x707070, 0xF0F0F0
    local x, y = w - 4, h - 4 -- bottom of resize widget tag
    for i = 0, 9, 3 do
        WindowLine(win, x - (i + 2), y, x + 1, y - (i + 3), c2, 0, 1) -- dark lines
        WindowLine(win, x - i, y, x + 1, y - (i + 1), c1, 0, 1) -- bright lines
    end
    WindowSetPixel(win, x, y, 0xF0F0F0)
    if (WindowHotspotInfo(win, "hsResize", 1) == nil) then
        WindowAddHotspot(
            win,
            "hsResize",
            w - rts,
            h - rts,
            win_width,
            h,
            "",
            "",
            "mousedown_resize_window",
            "",
            "",
            "",
            6,
            0
        )
        WindowDragHandler(win, "hsResize", "ResizeMoveCallback", "ResizeReleaseCallback", 0)
    else
        WindowMoveHotspot(win, "hsResize", w - rts, h - rts, 0, 0)
    end
end

function xg_show_target_links()
    for i, v in ipairs(win_target_hotspots) do
        WindowDeleteHotspot(win, v)
    end
    win_target_hotspots = {}
    if (win_state == "min") then
        return
    end
    local list = main_target_list
    local font = "cplist"
    local resize_tag = 13
    local targ_list_top = 59
    local targ_list_bottom = win_height - 5
    local font_height = WindowFontInfo(win, font, 1)

    if xg_show_quest_target_link(targ_list_top, resize_tag, font) then
        targ_list_top = targ_list_top + font_height * 2
    end

    for index, v in ipairs(list) do
        if (((index - 1) * font_height + targ_list_top) > targ_list_bottom) then
            break
        end -- Abort loop if printed item would not be visible.
        local mob = v.mob .. ((v.is_dead == "yes") and " [Dead]" or "")
        local ar = v.arid
        local ct = v.link_type
        local location
        local eventHandler = "win_mouseup_target_link"
        if (ct == "area") then
            location = string.format("%s", ar)
        elseif (ct == "room") then
            location = string.format("'%s' (%s)", v.roomName, ar)
        elseif (ct == "unknown") then
            location = string.format("'%s' (unknown)", v.location)
            eventHandler = ""
        end
        local qty = ((player_on_gq == "yes") and v.qty .. "* " or "")
        local counts = ""
        if v.duplicates and v.duplicates > 1 then
            counts = string.format("(%i/%i) ", v.index, v.duplicates)
        end
        local link = string.format("%2s) %s%s%s - %s", index, counts, qty, mob, location)
        local color = ColourNameToRGB(color_for_target(v, target_matches_current_target(v, index)))
        local hs_left = 6
        local hs_top = (targ_list_top + ((index - 1) * font_height))
        local hs_right = math.min(hs_left + WindowTextWidth(win, font, link), win_width - 5)
        local hs_bottom = (hs_top + font_height + 1)
        if v.unlikely then
            local added_width = WindowTextWidth(win, font, "(Unlikely) ")
            WindowText(win, font, "(Unlikely) ", 6, hs_top, 0, 0, ColourNameToRGB(text_colors.unlikely_tag), false)
            hs_left = hs_left + added_width
            hs_right = math.min(hs_right + added_width, win_width - 5)
        end
        WindowText(win, font, link, hs_left, hs_top, 0, 0, color, false)
        if (hs_bottom > win_height - resize_tag) then -- Prevent list item's hotspot from overlapping with the resize tag
            hs_right = math.min(hs_right, win_width - resize_tag - 5)
        end
        table.insert(win_target_hotspots, index)
        --WindowRectOp (win, 1,
        --				hs_left-1, hs_top+2, hs_right+2, hs_bottom, 0x000080, 15)
        WindowAddHotspot(
            win,
            index,
            hs_left - 1,
            hs_top + 2,
            hs_right + 2,
            hs_bottom, -- hotspot boundary rectangle
            "",
            "",
            "",
            "", -- "mouseover", "cancelmouseover", "mousedown", "cancelmousedown"
            eventHandler,
            "",
            miniwin.cursor_arrow,
            0
        ) -- "mouseup", tooltip, cursor type
    end
end

function has_target()
    return not not current_target
end

function is_cp_or_gq_mob_targeted()
    return is_cp_mob_targeted() or is_gq_mob_targeted()
end

function is_cp_mob_targeted()
    return has_target() and current_target.activity == "cp"
end

function is_gq_mob_targeted()
    return has_target() and current_target.activity == "gq"
end

function is_quest_mob_targeted()
    return has_target() and current_target.activity == "quest"
end

-- Return true if you have a target, and that target is from a cp/gq/quest
-- Otherwise false (no target or target is not from a cp/gq/quest, like
-- when you do `qw <mob name>`)
function has_activity_target()
    return is_cp_or_gq_mob_targeted() or is_quest_mob_targeted()
end

function has_active_quest()
    return quest_target.qstat == "2"
end

function has_active_cp_or_gq()
    return #main_target_list > 0
end

function xg_show_quest_target_link(targ_list_top, resize_tag, font)
    if not quest_target.qstat or quest_target.qstat == "1" then
        return false
    end

    local text
    local color
    local hs_left, hs_top, hs_right, hs_bottom

    if quest_target.qstat == "0" then
        text = " You may now quest again"
        color = text_colors.quest_available
    elseif has_active_quest() then
        color = is_quest_mob_targeted() and text_colors.targeted or text_colors.normal
        text = string.format(" Q) %s - '%s' (%s)", quest_target.mob, quest_target.room, quest_target.arid)
    elseif quest_target.qstat == "3" then
        text = " Quest complete! You may turn it in"
        color = text_colors.quest_complete
    else
        return false
    end

    hs_left = 6
    hs_top = targ_list_top
    hs_right = math.min(hs_left + WindowTextWidth(win, font, text), win_width - 5)
    hs_bottom = (hs_top + WindowFontInfo(win, font, 1) + 1)
    if (hs_bottom > win_height - resize_tag) then
        hs_right = math.min(hs_right, win_width - resize_tag - 5)
    end

    WindowText(win, font, text, hs_left, hs_top, 0, 0, ColourNameToRGB(color), false)

    if has_active_quest() then
        table.insert(win_target_hotspots, "q")
        WindowAddHotspot(
            win,
            "q",
            hs_left - 1,
            hs_top + 2,
            hs_right + 2,
            hs_bottom,
            "",
            "",
            "",
            "",
            "win_mouseup_target_quest",
            "",
            miniwin.cursor_arrow,
            0
        )
    end
    if #main_target_list > 0 then
        local font_height = WindowFontInfo(win, font, 1)
        local space_width = WindowTextWidth(win, font, " ")
        hs_top = math.floor(hs_top + font_height * 1.5)
        WindowRectOp(win, 2, hs_left + space_width, hs_top, hs_right, hs_top + 2, "0x808080")
    end
    return true
end

-- [[ GUI window mouse click functions (buttons, links, etc.) ]]
function mouseup_b1(flags, hotspot_id) -- when mouse button is released, redraw the buttons to normal appearance.
    local b = button_1_list[hotspot_id]
    local click = ((bit.band(flags, 0x20) == 0) and "L" or "R")
    local left = WindowHotspotInfo(win, hotspot_id, 1)
    local top = WindowHotspotInfo(win, hotspot_id, 2)
    draw_button_1_A(left, top, b.text, hotspot_id, b.tooltip, b.tdx, b.tdy)
    Redraw()
    Execute(((click == "L") and b.exec1 or b.exec2))
end

function mousedown_b1(flags, hotspot_id) -- when mouse button is pressed:
    local b = button_1_list[hotspot_id]
    local click = ((bit.band(flags, 0x20) == 0) and "L" or "R")
    local left = WindowHotspotInfo(win, hotspot_id, 1)
    local top = WindowHotspotInfo(win, hotspot_id, 2)
    draw_button_1_A(left, top, b.text, hotspot_id .. "2", "", b.tdx, b.tdy, true)
    Redraw()
end

function cancelmousedown_b1(flags, hotspot_id)
    local b = button_1_list[hotspot_id]
    local click = ((bit.band(flags, 0x20) == 0) and "L" or "R")
    local left = WindowHotspotInfo(win, hotspot_id, 1)
    local top = WindowHotspotInfo(win, hotspot_id, 2)
    draw_button_1_A(left, top, b.text, hotspot_id, b.tooltip, b.tdx, b.tdy)
    Redraw()
end

function mousedown_resize_window(flags, hotspot_id)
    if (hotspot_id == "hsResize") then
        startx, starty = WindowInfo(win, 17), WindowInfo(win, 18)
    end
end

function mouseup_noexp(flags)
    local f = flags
    local hs = "hs_noexp"
    local click = ((bit.band(f, 0x20) == 0) and "L" or "R")
    if (anex_automatic_onoff == "on") then
        if (click == "L") then
            anex_tnl_cutoff = anex_tnl_cutoff + 100
            if (anex_tnl_cutoff > 9900) then
                anex_tnl_cutoff = 9900
            end
        elseif (click == "R") then
            anex_tnl_cutoff = anex_tnl_cutoff - 100
            if (anex_tnl_cutoff < 0) then
                anex_tnl_cutoff = 0
            end
        else
            -- do nothing
        end
        set_variable("mcvar_anex_tnl_cutoff", anex_tnl_cutoff)
        anex_check_tnl_silent()
        xg_draw_window()
    end
end

function mousedown_drag(flags, hotspot_id)
    win_dragmove_start_x = WindowInfo(win, 14)
    win_dragmove_start_y = WindowInfo(win, 15)
end

function mouseup_drag(flags, hotspot_id)
    local f = flags
    local click = ((bit.band(f, 0x20) == 0) and "L" or "R")
    if (hotspot_id == "hsDrag1") then
        if (click == "R") then
            right_click_menu()
        end
    end
end

function win_mouseup_target_link(flags, hotspot_id)
    if (tonumber(hotspot_id) ~= nil) then
        xcp_arg("", "", {index = hotspot_id})
    end
end

function win_mouseup_target_quest()
    target_quest_mob(true)
    xg_draw_window()
end

--	[[ Window dragging / moving ]]
function dragmove(flags, hotspot_id)
    if (bit.band(flags, 0x20) == 0) then
        win_pos_x = WindowInfo(win, 17) -- - 50
        win_pos_y = WindowInfo(win, 18) -- - 7
        local delta_x = win_pos_x - win_dragmove_start_x
        local delta_y = win_pos_y - win_dragmove_start_y
        local max_x = GetInfo(281) - 100
        local max_y = GetInfo(280) - 60
        if (delta_x <= 1) then -- Prevents window from leaving the screen.  The bug that got me started on all this.
            delta_x = 1
        elseif (delta_x >= max_x) then
            delta_x = max_x
        end
        if (delta_y <= 1) then
            delta_y = 1
        elseif (delta_y >= max_y) then
            delta_y = max_y
        end
        WindowPosition(win, delta_x, delta_y, miniwin.pos_stretch_to_view, miniwin.create_absolute_location) -- move window to new location
    else
        return
    end
end

function dragrelease(flags, hotspot_id)
    --  print ("mouse drag release for " .. hotspot_id)
    --  print ("released at position", WindowInfo (win, 17), WindowInfo (win, 18))
end

--	[[ Window resize functions ]]

local lastRefresh = 0

function ResizeMoveCallback()
    local screen_width = GetInfo(281) - 100
    local screen_height = GetInfo(280) - 60
    if (GetPluginVariable("c293f9e7f04dde889f65cb90", "lock_down_miniwindows") == "1") then
        return
    end
    local x, y = WindowInfo(win, 17), WindowInfo(win, 18)
    win_width = win_width + x - startx
    startx = x
    if (win_width < win_width_min) then
        win_width = win_width_min
        startx = windowinfo.window_left + win_width
    elseif (win_width > screen_width) then
        win_width = screen_width
        startx = windowinfo.window_left + win_width
    end
    win_height = win_height + y - starty
    starty = y
    if (win_height < win_height_min) then
        win_height = win_height_min
        starty = windowinfo.window_top + win_height
    elseif (win_height > screen_height) then
        win_height = screen_height
        starty = windowinfo.window_top + win_height
    end
    WindowResize(win, win_width, win_height, win_bgcolor)
    local freq = 90
    local t = utils.timer()
    if ((t - lastRefresh) > (1 / freq)) then -- redraw rate while resizing (per second)
        xg_draw_window()
        lastRefresh = t
    end
end

function ResizeReleaseCallback()
    win_state = "max"
    w = win_width
    h = win_height
    WindowDeleteHotspot(win, "hsDrag1")
    win_hotspots["hsDrag1"] =
        WindowAddHotspot(
        win,
        "hsDrag1",
        0,
        0,
        w - 1,
        16, -- hotspot id, rectangle (left, top, right, bottom)
        "",
        "",
        "mousedown_drag",
        "",
        "mouseup_drag", --mouseover, cancelmouseover, mousedown_drag, cancelmousedown, mouseup_drag
        "Left click = Drag title bar to move\nRight click = Send window to front/back",
        miniwin.cursor_arrow,
        0
    )
    WindowDragHandler(win, "hsDrag1", "dragmove", "dragrelease", 0)
    xg_draw_window()
end

--	[[ Window right click menu]]
function right_click_menu()
    local color_options = {}
    for i, details in ipairs(TEXT_COLOR_DETAILS) do
        if details.key == "quest_available" or details.key == "alternating_row" then
            table.insert(color_options, "-")
        end
        table.insert(color_options, details.menu_name)
    end
    table.insert(color_options, "-")
    table.insert(color_options, "Reset to Defaults")

    local hide_settings = "Hide Settings Button"
    if win_hide_settings_button == "on" then
        hide_settings = "+" .. hide_settings
    end

    local menu_options = {
        "Change Font",
        ">Change Colors",
        table.concat(color_options, "|"),
        "<",
        "-",
        "Bring To Front",
        "Send To Back",
        "Collapse Window",
        "Expand Window",
        "-",
        hide_settings,
        "Check for Updates",
        "Changelog",
        "Help"
    }
    result =
        WindowMenu(
        win,
        WindowInfo(win, 14), -- x position
        WindowInfo(win, 15), -- y position
        table.concat(menu_options, "|")
    ) -- content

    if result == "Change Font" then
        local new_font = utils.fontpicker(win_font, win_font_size, 0)
        if new_font == nil then
            return
        end

        win_font = new_font.name
        win_font_size = new_font.size
        win_font_bold = new_font.bold
        win_font_italic = new_font.italic
        win_font_underline = new_font.underline

        WindowFont(win, "cplist", win_font, win_font_size, win_font_bold, win_font_italic, win_font_underline, false)

        set_variable("mcvar_window_font", win_font)
        set_variable("mcvar_window_font_size", win_font_size)
        set_variable("mcvar_window_font_bold", win_font_bold)
        set_variable("mcvar_window_font_italic", win_font_italic)
        set_variable("mcvar_window_font_underline", win_font_underline)

        xg_draw_window()
        InfoNote("Window font changed to ", string.format("%s Size %i (%s)", win_font, win_font_size, new_font.style))
    elseif (result == "Bring To Front") then
        CallPlugin(plugin_id_z_order, "boostMe", win)
    elseif (result == "Send To Back") then
        CallPlugin(plugin_id_z_order, "dropMe", win)
    elseif (result == "Collapse Window") then
        win_state = "min"
        win_height = win_height_min
        WindowResize(win, win_width, win_height, ColourNameToRGB("black"))
        xg_draw_window()
        Redraw()
    elseif (result == "Expand Window") then
        win_state = "max"
        win_height = win_height_max
        WindowResize(win, win_width, win_height, ColourNameToRGB("black"))
        xg_draw_window()
    elseif result == "Check for Updates" then
        Note("Check for updates...")
        force_update_check(true)
    elseif result == "Reset to Defaults" then
        for i, details in ipairs(TEXT_COLOR_DETAILS) do
            text_colors[details.key] = details.default
            set_variable("color_" .. details.key, details.default)
        end
        Note("All colors reset to default values.")
        xg_draw_window()
    elseif result == "Hide Settings Button" then
        if win_hide_settings_button == "off" then
            win_hide_settings_button = "on"
            InfoNote(
                "\nSettings button will be ",
                "hidden",
                ". You can still access settings by right clicking on the title bar."
            )
        else
            win_hide_settings_button = "off"
            InfoNote("\nSettings button will be ", "shown")
        end
        set_variable("mcvar_window_hide_settings_button", win_hide_settings_button)

        clear_window_menu_hotspots()
        xg_draw_window()
    elseif result == "Help" then
        Execute("xhelp")
    elseif result == "Changelog" then
        --show_changelog(true)
        get_changelog(true)
    elseif result == nil or result == "" then
        return
    else
        local color_details
        for i, details in ipairs(TEXT_COLOR_DETAILS) do
            if details.menu_name == result then
                color_details = details
                break
            end
        end
        if not color_details then
            ErrorNote("Invalid menu option ", result, ". How did you even do that?")
            return
        end
        local new_color = PickColour(ColourNameToRGB(text_colors[color_details.key]))
        if new_color == nil or new_color == -1 then
            return
        end

        new_color = RGBColourToName(new_color)
        text_colors[color_details.key] = new_color
        set_variable("color_" .. color_details.key, new_color)
        if color_details.key == "alternating_row" then
            ColourNote("white", new_color, string.format("This is now color for %s.", color_details.desc))
        else
            ColourNote(new_color, "", string.format("This is now color for %s.", color_details.desc))
        end
        xg_draw_window()
    end
end

function xgui_RefreshLinks()
    if current_activity == "gq" then
        do_gq_check()
    else
        do_cp_check()
    end
    mouseup_drag(0, "hsMaximize")
end

function xgui_ReloadLinks()
    if current_activity == "gq" then
        do_gq_info()
    else
        do_cp_info()
    end
    mouseup_drag(0, "hsMaximize")
end

function xset_ToggleWindowDisplay(name, line, wildcards)
    local arg = wildcards.onoff
    if (arg == "on") or (arg == "show") or (arg == "1") then
        WindowShow(win, true)
        set_variable("mcvar_xgui_window_onoff", "on")
    elseif (arg == "off") or (arg == "hide") or (arg == "0") then
        WindowShow(win, false)
        set_variable("mcvar_xgui_window_onoff", "off")
    else
        if (arg == "max") or (arg == "maximize") or (arg == "expand") then
            win_state = "max"
            win_height = win_height_max
        elseif (arg == "min") or (arg == "minimize") or (arg == "collapse") then
            win_state = "min"
            win_height = win_height_min
        end

        WindowResize(win, win_width, win_height, ColourNameToRGB("black"))
        xg_draw_window()
        Redraw()
    end
end

function deprecated_xset_font_size()
    InfoNote(
        "Changing font size is now done by right clicking on the title bar of the targets window and choosing 'Change Font'\n"
    )
end

function deprecated_xset_line_space(name, line, wildcards)
    InfoNote(
        "Line spacing is automatically picked up from the font which can be changed by right clicking on the title bar of the targets window and choosing 'Change Font'\n"
    )
end

function OnPluginSaveState()
    movewindow.save_state(win) -- save window location
    if WindowInfo(win, 3) and WindowInfo(win, 4) then
        win_width = WindowInfo(win, 3)
        win_height = WindowInfo(win, 4)
    end

    -- Since these are inside of OnPluginSaveState we need to use
    -- SetVariable instead of set_variable or we'll be in an endless
    -- loop of saving the plugin state
    SetVariable("mcvar_window_pos_x", win_pos_x)
    SetVariable("mcvar_window_pos_y", win_pos_y)
    SetVariable("mcvar_window_state", win_state)
    SetVariable("mcvar_window_width", win_width)
    SetVariable("mcvar_window_height", win_height)
    SetVariable("mcvar_window_width_max", win_width_max)
    SetVariable("mcvar_window_height_max", win_height_max)
end

function OnPluginClose()
    OnPluginSaveState()
    WindowShow(win, false) -- hide window, refresh screen
end

function set_speed(name, line, wildcards)
    if (wildcards.speed ~= "") then
        speed = wildcards.speed
    else
        if (speed == "walk") then
            speed = "run"
        else
            speed = "walk"
        end
    end
    InfoNote("Move speed:", speed)
end

-- Internal Utilities
--function copytable(t)
--	local new_t = {}
--	table.foreachi(t,
--		function (k, v)
--			table.insert (new_t, v)
--		end)
--	return new_t
--end

function dbcheck(code, query)
    if
        (code ~= sqlite3.OK) and -- no error
            (code ~= sqlite3.ROW) and -- completed OK with another row of data
            (code ~= sqlite3.DONE)
     then -- completed OK, no more rows
        local err = db:errmsg() -- the rollback will change the error message
        err = err .. "\n\nCODE: " .. code .. "\nQUERY: " .. query .. "\n"
        db:exec("ROLLBACK") -- rollback any transaction to unlock the database
        error(err, 2) -- show error in caller's context
    end
end

function fixsql(s)
    if s then
        return "'" .. (string.gsub(s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
    else
        return "NULL"
    end
end

function gmcp(s)
    local ret, datastring = CallPlugin(plugin_id_gmcp_handler, "gmcpdata_as_string", s)
    pcall(loadstring("data = " .. datastring))
    return data
end

function send_gmcp_packet(s)
    CallPlugin(plugin_id_gmcp_handler, "Send_GMCP_Packet", s)
end

function int(n)
    if not tonumber(n) then
        return
    else
        return math.floor(n)
    end
end

function md5(s)
    local hash = utils.tohex(utils.md5(tostring(s)))
    return hash
end

function quote(text)
    return '"' .. text .. '"'
end

function round_banker(x) -- round normally, but when number ends in exactly .5 round to nearest even value.
    if (x == 0) then
        return 0
    end -- prevent returning -0
    if (x + 0.5) % 2 == 0 then
        return math.floor(x + 0.5)
    else
        return math.ceil(x - 0.5)
    end
end

function rtrim(s)
    local n = #s
    while n > 0 and s:find("^%s", n) do
        n = n - 1
    end
    return s:sub(1, n)
end

function sanitize_filename(str)
    str = string.gsub(str, "[^%w%s()_-]", "")
    return str
end

function spairs(t, f)
    local tbl = {}
    for n in pairs(t) do
        table.insert(tbl, n)
    end
    table.sort(tbl, f)
    local i = 0 -- iterator variable
    local iter = function()
        -- iterator function
        i = i + 1
        if (tbl[i] == nil) then
            return nil
        else
            return tbl[i], t[tbl[i]]
        end
    end
    return iter
end

function split(line, delim)
    local result = {}
    local index = 1
    for token in string.gmatch(line, delim) do
        result[index] = token
        index = index + 1
    end
    return result
end

function tier_level()
    local l = tonumber(gmcp("char.status.level"))
    local t = tonumber(gmcp("char.base.tier"))
    return (l + 10 * t)
end

-- [[ Random stuff that doesn't fit anywhere else (?) ]]
function xtest_roomhist()
    ColourNote(
        "#00FFFF",
        "",
        "\ni: 0    r: " .. string.format("%-5s", room_history[0].rmid) .. "  a: " .. room_history[0].arid
    )
    for i, v in ipairs(room_history) do
        print(
            "i: " ..
                string.format("%-3s", i) ..
                    "  r: " .. string.format("%-5s", v.rmid) .. "  a: " .. string.format("%-10s", v.arid)
        )
    end
    print("")
end

function xtest_areadata()
    local db = assert(sqlite3.open(mapper_db_file))
    local sql = "SELECT uid, name FROM areas"
    local ar = {}
    local dasr = areaDefaultStartRooms -- default start rooms
    local xasr = area_start_rooms -- xset marked start rooms
    local alr = area_range_index -- area level range table
    --local worldPath = GetInfo(66) .. "/worlds/plugins/"
    --local db = assert(sqlite3.open(worldPath .. "sddb.db"))
    local index = 0
    ColourNote("#00C040", "", "\nrunning sql: " .. sql)
    for row in db:nrows(sql) do
        index = index + 1
        local a = row.uid
        local an = row.name
        local q = (dasr[a].noquest == true) and "0" or "1"
        local d = dasr[a].start
        local c = (xasr[a] ~= nil) and ((xasr[a].roomid ~= d) and xasr[a].roomid or "-1") or "-1"
        ar[index] = {
            arid = a,
            area_name = an,
            def_startroom = d,
            cur_startroom = c,
            questable = q,
            minlvl = "-1",
            maxlvl = "-1",
            lock = "-1"
        }
    end
    db:close_vm()
    for i, v in ipairs(ar) do
        local a = v.arid
        local an = v.area_name
        if (alr[an] ~= nil) then
            v.minlvl = alr[an].min
            v.maxlvl = alr[an].max
        end
    end
    --	if (dasr[v.arid].noquest == true) then
    --		v.questable = "0"
    --	else
    --		v.questable = "1"
    --	end
    --end
    --tprint(ar)
    --tprint(area_start_rooms)
    --tprint(alr)
end

function xtest_mcvars()
    local t = GetVariableList()
    tprint(t)
end

function xmap_rooms_linking_here(name, line, wildcards)
    local room_id = tonumber(wildcards.room_id) or tonumber(current_room.rmid) or -1
    local r1 = {}
    local list = {}
    local Q1 = string.format("SELECT uid, name, area FROM rooms WHERE uid = %s ", fixsql(room_id))
    local Q2 =
        string.format(
        "SELECT exits.dir as edir, exits.fromuid as efrom, exits.touid as eto, rooms.name as name, rooms.area as arid FROM exits,rooms WHERE exits.touid = %s AND rooms.uid = exits.fromuid ORDER BY efrom ASC ",
        fixsql(room_id),
        fixsql(room_id)
    )
    local db = assert(sqlite3.open(mapper_db_file))
    for row in db:nrows(Q1) do
        r1 = {rmid = row.uid, arid = row.area, roomname = row.name}
    end
    for row in db:nrows(Q2) do
        local ru = string.format("%5s", row.efrom)
        list[ru] = {
            roomname = row.name,
            arid = row.arid,
            exit_dir = row.edir
        }
    end
    db:close_vm()
    print("\n" .. "Rooms linking to " .. r1.rmid .. ": " .. r1.roomname .. " (" .. r1.arid .. ")" .. "\n")
    for k, v in spairs(list) do
        print(k .. ": " .. v.roomname .. " (" .. v.arid .. ") - " .. v.exit_dir)
    end
    print("")
end

function xtest_loadroom(name, line, wildcards)
    local ri = current_room
    local room_id = tonumber(wildcards.room_id) or tonumber(ri.rmid) or -1
    local roomdata = {}
    local sql_roomdata =
        "SELECT uid, name, area, info, noportal, norecall, ignore_exits_mismatch " .. "FROM rooms " .. "WHERE uid = %s "
    local sql_exitrow = "SELECT dir, fromuid, touid, level " .. "FROM exits " .. "WHERE fromuid = %s "
    local sel_roomdata = string.format(sql_roomdata, fixsql(room_id))
    local sel_exits = string.format(sql_exitrow, fixsql(room_id))
    local db_results_found = false
    local db = assert(sqlite3.open(mapper_db_file))
    for row in db:nrows(sel_roomdata) do
        roomdata = {
            roomid = row.uid,
            roomname = row.name or "-no room name-",
            arid = row.area or "-no area-",
            --building = row.building,
            --terrain = row.terrain,
            info = row.info or "-no info-",
            --notes = row.notes,
            --x = row.x or 0,
            --y = row.y or 0,
            --z = row.z or 0,
            noportal = row.noportal or 0,
            norecall = row.norecall or 0,
            exits = {},
            exit_locks = {},
            ig_ex_mis = (row.ignore_exits_mismatch == 1)
        }
        for exitrow in db:nrows(sel_exits) do
            roomdata.exits[exitrow.dir] = tostring(exitrow.touid)
            roomdata.exit_locks[exitrow.dir] = tostring(exitrow.level)
        end -- for each ex
    end
    db:close_vm()

    if not (roomdata.roomid) then
        roomdata = {
            roomid = tostring(room_id),
            roomname = "-1",
            arid = "-1",
            info = "none",
            noportal = 0,
            norecall = 0,
            exits = {},
            exit_locks = {},
            ig_ex_mis = false
        }
    end
    table.insert(xtest_loadroom_table, roomdata)
    tprint(xtest_loadroom_table)
    print("")
end

function xtest_popmsg(name, line, wildcards)
end

function xtest_set_qt(name, line, wildcards)
    local qt = tonumber(wildcards.qt)
    next_quest_time = os.time() + qt * 60
    quest_timer_tick()
end

function xtest_print_target()
    DebugNote("Target is: ", target_as_json())
end

function xtest_debug(name, line, wildcards)
    if debug_mode == "on" then
        InfoNote("Debug mode ", "disabled\n")
        debug_mode = "off"
    else
        InfoNote("Debug mode ", "enabled\n")
        debug_mode = "on"
    end
    set_variable("debug_mode", debug_mode)
end

function InfoNote(...)
    print_alternating_note({...}, NOTE_COLORS.INFO, NOTE_COLORS.INFO_HIGHLIGHT)
end

function ErrorNote(...)
    print_alternating_note({...}, NOTE_COLORS.ERROR, NOTE_COLORS.ERROR_HIGHLIGHT, NOTE_COLORS.ERROR_BACKGROUND)
end

function ImportantNote(...)
    print_alternating_note(
        {...},
        NOTE_COLORS.IMPORTANT,
        NOTE_COLORS.IMPORTANT_HIGHLIGHT,
        NOTE_COLORS.IMPORTANT_BACKGROUND
    )
end

function DebugNote(...)
    if debug_mode == "on" then
        ColourTell(NOTE_COLORS.DEBUG_HIGHLIGHT, "", "DEBUG: ")
        print_alternating_note({...}, NOTE_COLORS.DEBUG, NOTE_COLORS.DEBUG_HIGHLIGHT)
    end
end

function print_alternating_note(messages, regular_color, highlight_color, background)
    local current_color, other_color = regular_color, highlight_color
    background = background or ""

    for i, message in ipairs(messages) do
        ColourTell(current_color, background, message)
        current_color, other_color = other_color, current_color
    end
    print("")
end

-- [[ New code ]]
function update_plugin()
    DebugNote("Checking version to see if it should update itself")
    download_version_file(do_update, true)
end

function force_update_plugin(name, line, wildcards)
    local branch = "master"

    if wildcards.branch ~= "" then
        branch = wildcards.branch
    end

    DebugNote("Forcing update from ", branch)
    download_plugin(branch, callback_update_plugin)
end

function check_for_updates()
    if automatic_update_checks ~= "on" then
        return
    elseif GetInfo(304) >= last_update_check + UPDATE_CHECK_INTERVAL then
        force_update_check()
    end
end

function force_update_check(log_no_updates)
    DebugNote("Checking if there's an updated version available")
    last_update_check = GetInfo(304)
    download_version_file(show_update_banner, log_no_updates)
end

function download_plugin(version, callback)
    DebugNote("Downloading plugin version ", version)
    local url = string.format(pluginURL, version)
    download_file(url, callback)
end

function download_version_file(callback, log_no_updates)
    DebugNote("Attempting to download master")
    local url = versionURL
    download_file(url, check_version_callback(callback, log_no_updates))
end

function download_file(url, callback)
    DebugNote("Starting download of ", url)

    if async_ok then
        plugin_page = async.doAsyncRemoteRequest(url, callback, "HTTPS")
    else
        ImportantNote("Error on file download")
    end
end

function check_version_callback(callback, log_no_updates)
    return function(retval, page, status, headers, full_status, request_url)
        if status ~= 200 then
            DebugNote("check_version_callback got ", status)
            if log_no_updates then
                ErrorNote("Error while fetching latest version number")
            end
            return
        end
        local upstream_version = Trim(page)
        if upstream_version ~= tostring(PLUGIN_VERSION) then
            callback(upstream_version)
        elseif log_no_updates then
            InfoNote("Search&Destroy: No new updates available")
        end
    end
end

function do_update(version)
    DebugNote("Attempting to do_update with version ", version)
    download_plugin("v" .. version, callback_update_plugin)
end

function callback_update_plugin(retval, page, status, headers, full_status, request_url)
    if status ~= 200 then
        DebugNote("callback_update_plugin got ", status)
        ErrorNote("Error while fetching latest plugin version")
        return
    end
    local upstream_version = tonumber(string.match(page, '<plugin version="([0-9%.]+)"'))
    ImportantNote("Updating from version ", PLUGIN_VERSION, " to ", upstream_version, ". Do not touch anything!")
    local file = io.open(GetPluginInfo(GetPluginID(), 6), "w")
    file:write(page)
    file:close()
    if "" == GetAlphaOption("script_prefix") then
        SetAlphaOption("script_prefix", "\\\\\\")
    end
    Execute(
        GetAlphaOption("script_prefix") ..
            'DoAfterSpecial(1, "ReloadPlugin(\'' .. GetPluginID() .. '\')", sendto.script)'
    )
    ImportantNote("Update complete!")
end -- end Update code

function show_update_banner(upstream_version)
    ColourNote(NOTE_COLORS.INFO, "", "\n+=================================================================+")
    ColourNote("silver", "", "              Search & Destroy ", "lime", "", "New Version Available")
    print("")
    ColourNote(
        "silver",
        "",
        "             Current version: ",
        "tomato",
        "",
        PLUGIN_VERSION,
        "silver",
        "",
        " Latest version: ",
        "lime",
        "",
        upstream_version
    )
    print("")
    ColourNote(
        "silver",
        "",
        "         Use ",
        "lime",
        "",
        "snd update",
        "silver",
        "",
        " to upgrade to the latest version."
    )
    print("")
    ColourNote(
        "silver",
        "",
        "     Use ",
        "tomato",
        "",
        "snd check_update",
        "silver",
        "",
        " to disable automatic version checks."
    )
    ColourNote(NOTE_COLORS.INFO, "", "+=================================================================+\n")
end

function toggle_automatic_update_checking()
    if automatic_update_checks == "on" then
        automatic_update_checks = "off"
        EnableTimer("update_check_tick", false)
    else
        automatic_update_checks = "on"
        force_update_check()
        EnableTimer("update_check_tick", true)
    end
    set_variable("mcvar_automatic_update_checks", automatic_update_checks)

    InfoNote("\nSearch&Destroy automatic update checking is now ", string.upper(automatic_update_checks))
end

function download_sounds(callback)
    local download_path = soundsURL
    local sounds = {
        other_target_here_sound,
        target_nearby_sound
    }
    --local async_ok, async = pcall (require, "async")
    local file
    local files_to_download = {}

    if async_ok then
        for i, filename in ipairs(sounds) do
            file = io.open(GetInfo(74) .. filename)
            if file then
                file:close()
            else
                table.insert(files_to_download, filename)
            end
        end

        local callbacks_required = #files_to_download
        local all_downloads_successful = true
        function callbackWrapper(success)
            all_downloads_successful = all_downloads_successful and success
            callbacks_required = callbacks_required - 1
            if callbacks_required == 0 then
                callback(all_downloads_successful)
            end
        end

        for i, filename in ipairs(files_to_download) do
            ImportantNote("Downloading ", filename)
            async.doAsyncRemoteRequest(
                string.format(download_path, filename),
                download_sounds_callback(filename, callbackWrapper),
                "HTTPS"
            )
        end

        if #files_to_download == 0 then
            callback(true)
        end
    else
        ErrorNote("Error downloading sounds: async could not be initialized.")
        callback(false)
    end
end

function download_sounds_callback(filename, callback)
    return function(retval, page, status, headers, full_status, request_url)
        if status == 200 then
            local file = io.open(GetInfo(74) .. filename, "wb")
            file:write(page)
            file:close()
            Note(string.format("Wrote %s successfully to sounds directory", filename))
            callback(true)
        else
            ErrorNote("Couldn't download ", filename)
            DebugNote("HTTP Status: ", status)
            DebugNote("Full status: ", full_status)
            DebugNote("Headers: ", require("json").encode(headers))
            if page and #page > 200 then
                if debug_mode == "on" then
                    SetClipboard(page)
                end
                DebugNote("Page data was too large for display and has been save to the clipboard")
            else
                DebugNote("Page: ", page)
            end
            callback(false)
        end
    end
end

function helpWrap(str, limit, indent, indent1)
    indent = indent or ""
    indent1 = indent1 or indent
    limit = limit or 76
    local here = 1 - #indent1
    local lastColor = ""
    return indent1 ..
        str:gsub(
            "(%s+)()(%S+)()",
            function(sp, st, word, fi)
                local delta = 0
                here = here + delta
                if fi - here > limit then
                    here = st - #indent + delta
                    return "\n" .. word
                end
            end
        )
end

function onHelp(name, line, wildcards)
    local str = wildcards.search
    local helpFiles = {
        "win",
        "speed",
        "vidblain",
        "mark",
        "index areas",
        "silent",
        "xm|xmall|rlh",
        "xmap",
        "roomnote",
        "qw",
        "ht",
        "ah|aha",
        "ak|kk|qk",
        "qs",
        "xq",
        "xqt",
        "noexp",
        "kw|keyword",
        "nx",
        "go",
        "xset nx",
        "xset con_overwrite",
        "xset gqalias",
        "xset table notes",
        "xset table width",
        "sound",
        "xrt|xrun",
        "cp|gq",
        "xcp",
        "xcp mode",
        "quest|xcp quest",
        "ms|msearch|xms|xmsearch",
        "mgo|mgoto|xmgo|xmgoto",
        "snd migrate|mergePwar",
        "snd update",
        "snd reload",
        "snd check_update",
        "snd changelog",
        "summary"
    }

    local headers = {
        "cyan",
        "",
        string.rep("-", 76) .. "\n",
        "darkcyan",
        "",
        "Help keywords",
        "antiquewhite",
        "",
        " : " .. str .. "\n",
        "cyan",
        "",
        string.rep("-", 76) .. "\n"
    }

    ColourNote(unpack(headers))

    if str == "" or "" == nil or str == "xhelp" then
        ColourNote("darkcyan", "", "Plugin name    ", "antiquewhite", "", " : Search & Destroy")
        ColourNote("darkcyan", "", "Maintained by  ", "antiquewhite", "", " : Crowley")
        ColourNote("darkcyan", "", "Original Author", "antiquewhite", "", " : WinkleWinkle")
        ColourNote("darkcyan", "", "Credit to      ", "antiquewhite", "", " : Nokfah and Starling")
        Note()
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xhelp <command> (to view helpfiles below)")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Search & Destroy is a quality-of-life tool. It utilizes the mapper plugin in order to get to your quest mobs faster, your campaign targets faster, and yes, even global quest mobs. It makes every attempt to load up the keyword into an alias so all you have to do is type the alias and enter. It presents a window that displays your campaign or global targets (and eventually will show quest targets, perhaps tabbed). It uses its own runto feature in order to run to your personally chosen 'start' room of the area. To clarify, there are no 'start' rooms to any area. It's why the mapper plugin cannot just run you to an area because you tell it to."
                    )
                }
            )
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "In short, it can speed up your quests/campaigns/global quests. It is NOT, however, a bot as some may claim."
                    )
                }
            )
        )
        Note()
        ColourNote("antiquewhite", "", "To get started, view the help files below:")
        Note()
        ColourNote("limegreen", "", unpack({helpWrap(table.concat(helpFiles, ", "))}))
    elseif str == "win" then
        ColourNote(
            "yellow",
            "",
            "Syntax",
            "antiquewhite",
            "",
            ": xset win <on|off|show|hide|max<imize>|min<imize>|expand|collapse>"
        )
        ColourNote("antiquewhite", "", "        xset winreset")
        Note()
        ColourNote("limegreen", "", "xset win:")
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "This command toggles the Search & Destroy miniwindow. Use 'on' or 'show' to show the window, and use 'off' or 'hide' to close the window. Use max or expand to expand the window from a collapsed state, or use min or collapse to minimize the window."
                    )
                }
            )
        )
        Note()
        ColourNote("limegreen", "", "xset winreset:")
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "If, for any reason, the window goes missing and the previous command does not restore it, this command will reset the window to a default location on top of your windows."
                    )
                }
            )
        )
    elseif str == "speed" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset speed <walk|run>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Without an argument, it will display the current movement speed the mapper is using. With an argument, it will change the map speed to walk (without using portals) or run (using portals)."
                    )
                }
            )
        )
    elseif str == "vidblain" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset vidblain")
        ColourNote("antiquewhite", "", "        xset vidblain level <#>")
        Note()
        ColourNote("limegreen", "", "xset vidblain:")
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "This will toggle a fix that allows you to run to areas within Vidblain. This was necessary because of the random drop locations when you runto Vidblain without a portal. See the next command if you have a portal to an area within Vidblain."
                    )
                }
            )
        )
        Note()
        ColourNote("limegreen", "", "xset vidblain level <#>:")
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "This command is used to display or set the lowest level portal you have to an area in Vidblain. For example, if you have a level 1 portal to Sendhia, you would simply type 'xset vidblain level 1'. "
                    )
                }
            )
        )
    elseif str == "mark" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset mark <areaname roomid>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("This command will set your current room as the designated 'start' room of the area. With the optional area name and ID, you can remotely set it from afar. This also allows you to set individual keywords for areas (e.g. 'xset mark bloodlust 45933' will set a keyword of 'bloodlust' that leads to room 45933).")})
        )
    elseif str == "index areas" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset index areas")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Occasionally, SnD does not realize you've mapped an area for whatever reason. This becomes apparent when you see a lot of red links on your campaign or global quest check list. When this happen, this command SHOULD fix it, but again, only if you've mapped the areas linked in red. If it does not, something else is amiss, and you should probably note Crowley about it."
                    )
                }
            )
        )
    elseif str == "silent" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset silent <on|off>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "This command will turn the display of campaign or global quest targets in the main window on or off. Soneone once mentioned it was redudant to have it in both the miniwindow and the main window, so for the sake of spamreduce, this was included."
                    )
                }
            )
        )
    elseif str == "xm" or str == "xmall" or str == "rlh" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xm <room name>")
        ColourNote("antiquewhite", "", "        xmall <room name>")
        ColourNote("antiquewhite", "", "        xm rlh <#>")
        Note()
        ColourNote("limegreen", "", "xm <room name>:")
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Searches for the supplied room name within the area. It can match partial room names. To get a list of all rooms in the current area, use '%' as the room name."
                    )
                }
            )
        )
        Note()
        ColourNote("limegreen", "", "xmall <room name>:")
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "As with above, searches for the supplied room name, but across all zones. It can match partial room names. Would not suggest using '%' here as it will display every room you have mapped in Aardwolf."
                    )
                }
            )
        )
        Note()
        ColourNote("limegreen", "", "xm rlh <#>:")
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Without an argument, displays rooms that link to the current room. With an argument, displays rooms that link to your chosen room ID. This will display room ID, room name, and room zone name that links to the room."
                    )
                }
            )
        )
    elseif str == "xmap" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xmap move <roomID> <walk|run>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Moves between rooms at default speed (see 'xhelp xset speed') without argument, or, with argument, walks (without portals) or runs (with portals) to the supplied room ID."
                    )
                }
            )
        )
    elseif str == "roomnote" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": roomnote <area|area areakey>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {helpWrap("Displays roomnotes for the current room, current area, or for the supplied area keyword.")}
            )
        )
    elseif str == "qw" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": qw<x> <mobname>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Uses the 'where' command on the stored mobname based on quest, campaign, or global quest target. If an argument is supplied, it will 'where' the argument. Use 'x' if you want an exact match on mob name."
                    )
                }
            )
        )
    elseif str == "ht" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": ht <mob|stop>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Executes the 'hunt trick' for the current campaign target or supplied argument. Use 'stop' to stop the hunt trick, which will work in most cases but may fail if a mob has a keyword of 'stop'."
                    )
                }
            )
        )
    elseif str == "ah" or str == "aha" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": ah<a> <mobname>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Automatically sends the 'hunt' command and executes the direction hunt leads you. Append 'a' in order to abort autohunting. This is useful for tracking quest mobs through mazes, or if you really want to, hunting players. However, you must have hunt practiced for it to work."
                    )
                }
            )
        )
    elseif str == "ak" or str == "kk" or str == "qk" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": <xset> <ak|kk|qk> <commands>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "With the 'xset' argument, sets the interchangable command of 'ak', 'kk', and 'qk' to the command supplied. Without the 'xset' argument, executes the 'quick kill' command. If you wish to stack multiple commands, you must separate each command with a double semicolon (or a single semicolon if you start the line with a semicolon). For example, 'xset kick;;bash;;slap' (or ';xset kick;bash;slap')  will kick the target, then bash the target, then slap the target."
                    )
                }
            )
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Any of the commands can be given a 'notarg' argument and they will be executed without supplying the target name. For example:"
                    )
                }
            )
        )
        ColourNote("limegreen", "", "  xset kk backstab;;spiral notarg")
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("If your target is a guard then this will do 'backstab guard;spiral'.")})
        )
    elseif str == "qs" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": qs")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("Executes a scan for the current quest, campaign, or global quest target.")})
        )
    elseif str == "xq" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xq")
        Note()
        ColourNote("antiquewhite", "", unpack({helpWrap("Reloads and displays your current quest information.")}))
    elseif str == "xqt" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xqt")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("Retargets the current quest mob if you changed it, for instance with 'xcp' or 'qw.'")})
        )
    elseif str == "nx" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": nx<->")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("Moves to the next room in the list, or with '-', the previous room.")})
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "See 'xhelp xset nx' for information about the action that will be taken upon arriving in the room."
                    )
                }
            )
        )
    elseif str == "go" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": go <index #>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Moves to the first room in the index, or with a supplied argument to the index number supplied."
                    )
                }
            )
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "See 'xhelp xset nx' for information about the action that will be taken upon arriving in the room."
                    )
                }
            )
        )
    elseif str == "xset nx" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset nx <smartscan|con|scan|scanhere|qs|none>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Sets the behaviour when you arrive at a room via nx or go. Without an argument it will display the current action. With an argument, sets your action to:"
                    )
                }
            )
        )
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("  * smartscan: scan for just your targets, and fallback on con when")})
        )
        ColourNote("antiquewhite", "", unpack({helpWrap("    potential noscan targets are encountered.")}))
        ColourNote("antiquewhite", "", unpack({helpWrap("  * con: consider the room")}))
        ColourNote("antiquewhite", "", unpack({helpWrap("  * scan: perform a scan.")}))
        ColourNote("antiquewhite", "", unpack({helpWrap("  * scanhere: perform a scan of the current room.")}))
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("  * qs: perform a quick scan, looking for only your current target mob.")})
        )
        ColourNote("antiquewhite", "", unpack({helpWrap("  * none: do nothing.")}))
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {helpWrap("When you scan or consider, mobs found in the current room are added to the mobs database.")}
            )
        )
    elseif str == "xset gqalias" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset gqalias")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("Enable or disable extra 'qq' and 'gg' aliases for 'gquest check'.")})
        )
    elseif str == "table notes" or str == "xset table notes" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset table notes")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "When enabled, show room notes directly in the rooms table, up to the width available. Table width can be expanded with the `xset table width` command."
                    )
                }
            )
        )
    elseif str == "table width" or str == "xset table width" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset table width <num>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Set the table width for room tables to the given number, between 80 and 150. This is particularly useful for showing notes when the xset table notes is enabled."
                    )
                }
            )
        )
    elseif str == "xset con_overwrite" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset con_overwrite")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Disable replacing the output of consider. This is mainly for when you have other plugins that replace the output."
                    )
                }
            )
        )
    elseif str == "xrt" or str == "xrun" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": <xrt|xrun> <area keyword>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Executes a run to the supplied area keyword. If a room has been marked (help 'xset mark') as the start room of the area, it will run there instead."
                    )
                }
            )
        )
    elseif str == "noexp" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset noexp <off|#>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Without an argument, it will display the current setting. With an argument, it will turn off monitoring for noexp or set a threshhold for turning on noexp. This feature is to keep you from accidentally leveling while you're campaign leveling."
                    )
                }
            )
        )
    elseif str == "cp" or str == "gq" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": <cp|gq> <i|info|c|check>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Displays information/check for campaigns and global quests. With the 'i' or 'info' argument, it will load the list of mobs in the miniwindow."
                    )
                }
            )
        )
    elseif str == "xcp" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xcp <index>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Without an argument, this command will search for the first mob listed in the miniwindow. Otherwise, it will search for the mob based on the supplied index number."
                    )
                }
            )
        )
    elseif str == "xcp mode" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xcp mode <ht|qw|off>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Without an argument, displays your current default action to take when searching for a mob using 'xcp' (see 'xhelp xcp'). With an argument, sets your default action to 'ht' (hunt trick, 'xhelp ht'), 'qw' (quick where, 'xhelp qw'), or 'off' (no action taken)."
                    )
                }
            )
        )
    elseif str == "xcp quest" or str == "quest" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xcp quest")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "When enabled, using 'xcp' with no arguments will target your quest mob if you are currently on a quest."
                    )
                }
            )
        )
    elseif str == "snd update" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": snd update")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Whenever Crowley announces a new version, this command will make it easy to update the Search & Destroy plugin."
                    )
                }
            )
        )
    elseif str == "ms" or str == "msearch" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": <<x>ms|<x>msearch> <here|area> <mob name>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "This command will search the mob database for the mob name supplied based on the area supplied (here, [area key], defaults to 'all' with no argument), returning the rooms the mob has been found, the area, and the times it has been found in that room. The leading 'x' is optional."
                    )
                }
            )
        )
    elseif str == "mgo" or str == "mgoto" or str == "xmgo" or str == "xmgoto" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": <x>mgo<to> <idx>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "This command is used after searching for a mob and will go to the room provided by the index number. The leading 'x' is optional."
                    )
                }
            )
        )
    elseif str == "snd reload" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": snd reload")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "If, for any reason, Search & Destroy stops functioning correctly, this theoretically should fix it. In some cases, it may be necessary to open up your plugins (Ctrl+Shift+P) and reinstall Search & Destroy."
                    )
                }
            )
        )
    elseif str == "snd check_update" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": snd check_update")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("Toggles automatic checking for new versions of Search & Destroy.")})
        )
    elseif str == "snd migrate" or str == "mergePwar" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": snd migrate")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "This command is for previous users of Pwar's Search & Destroy. In an effort to not lose a previously built mob database, this command will migrate all data to this version of SnD."
                    )
                }
            )
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "This will only work if the file name has not been altered from 'WinkleGold_Database.db' and that the file is located in the default plugin directory. If you have moved it or renamed it, please make sure it is located in the 'plugins' folder with the name 'WinkleGold_Database.db' and run this command again. Thank you."
                    )
                }
            )
        )
    elseif str == "kw" or str == "keyword" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset kw <mob keyword>")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "This command will change a mob's keyword so that it is properly targeted. For example, say you have a campaign target of 'a yummy beef pot pie.' By default, S&D might target 'yummy pie' which doesn't actually match. Instead, you'll want it to target 'beef pie.'"
                    )
                }
            )
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "To do so, you can use 'xset kw beef pie' while it is a campaign, quest, or gquest target. Alternatively, you can use 'xset kw' with no arguments and follow the dialogs that appear."
                    )
                }
            )
        )
    elseif str == "sound" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": xset sound")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "Toggles sounds. Currently this is only used to signify that a target is in a nearby room as determined by scan, or that one of the targets on your campaign/gquest, but not your current target, is in the same room as you. For full functionality, the soundpack plugin is expected to be enabled."
                    )
                }
            )
        )
    elseif str == "changelog" then
        ColourNote("yellow", "", "Syntax", "antiquewhite", "", ": snd changelog")
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("Displays the entire changelog from oldest to newest top to bottom.")})
        )
    elseif str == "summary" then
        ColourNote("yellow", "", "Commands:")
        Note()
        ColourNote("antiquewhite", "", unpack({helpWrap("xset win <on|off>: Shows your hides the window.")}))
        Note()
        ColourNote("antiquewhite", "", unpack({helpWrap("xset winreset: Resets the window.")}))
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("xset speed <walk|run>: Displays current move speed, or changes it to argument.")})
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "xset vidblain:  Fixes Vidblain's 'random drop' so you can still run to areas within Vidblain."
                    )
                }
            )
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("xset mark:  Sets current room as 'start' for the current area.")})
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "xset index areas:  Indexes areas. Use this if you get a lot of 'red' links but you've mapped the area."
                    )
                }
            )
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("xset silent <on|off>:  Toggles displaying target list in main MUD window.")})
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("xm rlh <roomID>:  Displays rooms linking to <roomID> or current room.")})
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("xmall <room name>:  Displays rooms across the MUD matching the argument.")})
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("xm <room name>:  Displays rooms in zone matching the argument.")})
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "xmap move <roomID> <run|walk>:  Move to the room id at default speed, or walks (without portals) or runs (with portals) based on argument."
                    )
                }
            )
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "roomnote <area|area areakey>:  Displays roomnotes for current room, current area, or area argument."
                    )
                }
            )
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "qw<x> <mobname>:  Where's the current stored target or argument. Use 'x' to where exact mob name."
                    )
                }
            )
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "ht <mob|stop>:  Executes the 'hunt trick' for current target or argument. Use 'stop' to abort."
                    )
                }
            )
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("ah<a> <targ>:  Autohunts target. Append 'a' with no target to abort.")})
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("xset <ak|kk|qk>:  Sets the 'quick kill' command. All options are interchangeable.")})
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("<ak|kk|qk>:  Executes the 'quick kill' command. All options are interchangeable.")})
        )
        Note()
        ColourNote("antiquewhite", "", unpack({helpWrap("qs:  Executes a 'quick scan' for the stored target.")}))
        Note()
        ColourNote("antiquewhite", "", unpack({helpWrap("xq:  Reloads the quest info.")}))
        Note()
        ColourNote("antiquewhite", "", unpack({helpWrap("xqt:  Retargets the current quest mob.")}))
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "xset noexp <off|#>:  Displays current setting with no argument. With argument, toggles noexp off or sets it to turn on at # exp remaining."
                    )
                }
            )
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {helpWrap("xset kw <mob keyword>:  Set the keyword(s) that will be used to target a particular mob.")}
            )
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("nx<->:  Moves to the next room on the list, or the previous room with -.")})
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {helpWrap("go <index>:  Runs to the first room in the index, or to the index number with argument.")}
            )
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "xset nx <smartscan|con|scan|scanhere|qs|none>:  Set the action to take upon arriving in a room via 'nx' or 'go'."
                    )
                }
            )
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "xset con_overwrite:  Toggle overwriting the output of consider, for example if you have another plugin that also does this."
                    )
                }
            )
        )
        Note()
        ColourNote("antiquewhite", "", unpack({helpWrap("xset sound:  Toggles sounds.")}))
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("<xrt|xrun> <area>:  Runs to the area matching the argument.")})
        )
        Note()
        ColourNote("antiquewhite", "", unpack({helpWrap("<cp|gq> i|info:  Displays campaign/gquest info.")}))
        Note()
        ColourNote("antiquewhite", "", unpack({helpWrap("<cp|gq> ch|check:  Displays campaign/gquest check.")}))
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "xcp <index>:  Without argument, goes to top result in cp/gq check. Otherwise heads to the index chosen."
                    )
                }
            )
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "xcp mode <ht|qw|off>:  Sets whether you use hunt trick or quick where upon entering an area on cp/gq. Use 'off' to turn off this feature."
                    )
                }
            )
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("xcp quest:  Set whether or not 'xcp' will target quest mobs.")})
        )
        Note()
        ColourNote("antiquewhite", "", unpack({helpWrap("snd update:  Automatically updates Search & Destroy.")}))
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {helpWrap("snd check_update:  Toggles automatically checking for new versions of Search & Destroy.")}
            )
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("ms<earch> <area|here|all> <mob>: Searches for mobs in the mob database.")})
        )
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack({helpWrap("mgo<to> <idx>: After searching for mobs, goes to the index chosen.")})
        )
        Note()
        ColourNote("antiquewhite", "", unpack({helpWrap("snd reload: Reloads the plugin if it errors out.")}))
        Note()
        ColourNote(
            "antiquewhite",
            "",
            unpack(
                {
                    helpWrap(
                        "snd migrate: If you used Pwar's plugin and have a database, this will migrate it over to this version so you do not lose your hard earned data."
                    )
                }
            )
        )
    else
        ColourNote("antiquewhite", "", "No help files found with your query. Please see the help files below:")
        Note()
        ColourNote("limegreen", "", unpack({helpWrap(table.concat(helpFiles, ", "))}))
    end
    ColourNote("cyan", "", string.rep("-", 76))
end

function sndReload()
    Execute(
        GetAlphaOption("script_prefix") ..
            'DoAfterSpecial(1, "ReloadPlugin(\'' .. GetPluginID() .. '\')", sendto.script)'
    )
end

function copyPwarWarn()
    InfoNote(
        "Are you sure you want to do this? It will wipe out your existing mob and keyword data. Type ",
        "snd migrate confirm",
        " to migrate data from your pwar database."
    )
end

function copyPwarDB()
    local success, err = pcall(rawCopyPwarDB)

    if success then
        InfoNote("Finished migrating! You can now resume play!")
    else
        ErrorNote(err)
    end
end

function rawCopyPwarDB()
    local f = io.open(GetInfo(60) .. "WinkleGold_Database.db", "r")

    if not f then
        error(
            "To start migration process, please locate the file 'WinkleGold_Database.db' and move it to the plugins folder. Then try again."
        )
    else
        InfoNote("Now rebuilding the database with data from Pwar's Search & Destroy.")
        f:close()

        local PwarDb = assert(sqlite3.open(GetInfo(60) .. "/WinkleGold_Database.db"))
        local mapperDb = assert(sqlite3.open(GetInfo(66) .. "Aardwolf.db"))
        local SnDdb = assert(sqlite3.open(snd_db_file))
        local roomsById = {}
        local roomsToLookup = {}
        local migrateTable = {}
        local insertStatements = {}
        local batch_size = 10000
        local err

        InfoNote("Dropping existing data")
        execute_in_transaction(
            SnDdb,
            {
                "DELETE FROM mobs;",
                "DELETE FROM mob_keyword_exceptions;"
            }
        )

        local mobQuery = "SELECT roomid, mobname, sum(freq) as count FROM mobs GROUP BY roomid, mobname"

        for row in PwarDb:nrows(mobQuery) do
            table.insert(roomsToLookup, row.roomid)
            table.insert(migrateTable, {roomid = row.roomid, mob = row.mobname, count = row.count})
        end

        roomQuery =
            string.format("SELECT uid, area, name FROM rooms WHERE uid IN (%s)", table.concat(roomsToLookup, ","))

        for row in mapperDb:nrows(roomQuery) do
            roomsById[tostring(row.uid)] = {area = row.area, name = row.name}
        end
        mapperDb:close()

        for i, mob in ipairs(migrateTable) do
            room = roomsById[tostring(mob.roomid)]
            if room then
                table.insert(
                    insertStatements,
                    string.format(
                        "INSERT OR IGNORE INTO mobs (mob,room,roomid,zone,seen_count) VALUES (%s,%s,%s,%s,%i);",
                        fixsql(mob.mob),
                        fixsql(room.name),
                        mob.roomid,
                        fixsql(room.area),
                        mob.count
                    )
                )

                if #insertStatements > batch_size then
                    execute_in_transaction(SnDdb, insertStatements)
                    if SnDdb:errcode() > 0 then
                        err = SnDdb:error_message()
                        SnDdb:close()
                        PwarDb:close()
                        error("Encountered an error during migration: " .. err)
                    end
                    insertStatements = {}
                end
            end
        end

        local keyQuery = "SELECT mobname, areaid, subname FROM mobsubs"

        for row in PwarDb:nrows(keyQuery) do
            table.insert(
                insertStatements,
                string.format(
                    "INSERT OR REPLACE INTO mob_keyword_exceptions (area_name,mob_name,keyword) VALUES (%s,%s,%s);",
                    fixsql(row.areaid),
                    fixsql(row.mobname),
                    fixsql(row.subname)
                )
            )
            if #insertStatements > batch_size then
                execute_in_transaction(SnDdb, insertStatements)
                if SnDdb:errcode() > 0 then
                    err = SnDdb:error_message()
                    SnDdb:close()
                    PwarDb:close()
                    error("Encountered an error during migration: " .. err)
                end

                insertStatements = {}
            end
        end

        local startRoomQuery = "SELECT areaname, roomid FROM startrooms"
        local marks_updated = false
        for row in PwarDb:nrows(startRoomQuery) do
            marks_updated = true
            area_start_rooms[row.areaname] = {roomid = row.roomid}
        end

        if marks_updated then
            local serial = serialize.save_simple(area_start_rooms)
            set_variable("mcvar_areaStartRooms", serial)
        end

        PwarDb:close()

        execute_in_transaction(SnDdb, insertStatements)
        if SnDdb:errcode() > 0 then
            err = SnDdb:error_message()
            SnDdb:close()
            error("Encountered an error during migration: " .. err)
        end

        SnDdb:close()
    end
end
 --

--[[Mob searching]] function onSearch(name, line, wildcards)
    local zone, name, level, sendit = wildcards[1], wildcards[2], tonumber(wildcards[3]) or nil, false
    DebugNote(zone, name, level)

    if #name < 1 then
        name = zone
        zone = "all"
        sendit = true
    elseif #name >= 1 and #name < 2 then
        InfoNote("*** You need at least 2 characters of the mob name!")
    else
        sendit = true
    end

    if sendit then
        mobLookup(name, zone, ifc(level, level, ""))
    else
        InfoNote("*** Syntax error! Use: ", "xmsearch <areakey|here|all> <mob>")
    end
end

function mobLookup(name, location, level, exact)
    SnDdb = sqlite3.open(snd_db_file)

    if exact ~= "" or exact ~= nil then
        exact = false
    else
        exact = true
    end

    local locFound = false
    local locQuery = "SELECT * FROM area WHERE key LIKE '%s'"
    local searchQuery =
        "SELECT * FROM mobs, area WHERE %s LIKE '%s' AND mob LIKE '%s'%s AND area.key = mobs.zone ORDER BY mobs.zone, mobs.kill_count DESC"
    local lvlQuery = " AND area.minlvl <= %s AND area.maxlvl >= %s"
    local searchMsg = "Searching for %s in %s"

    if location ~= "" or location ~= nil then
        if location:upper() == "HERE" then
            location = gmcp("room.info.zone")
        elseif location:upper() == "ALL" then
            location = "%"
        end

        locQuery = locQuery:format(fixSQL(location))

        for a in SnDdb:rows(locQuery) do
            if a[1] then
                locFound = true
            end
        end
    end

    local zone_search, loc_search, name_search, level_search =
        ifc(locFound, "zone", "mobs.room"),
        ifc(locFound, fixSQL(location), "%" .. fixSQL(location) .. "%"),
        ifc(exact, fixSQL(name), "%" .. fixSQL(name) .. "%"),
        ifc(tonumber(level), lvlQuery:format(level, level), "")

    searchQuery = searchQuery:format(zone_search, loc_search, name_search, level_search)

    SnDdb:close()

    showResults(searchQuery, searchMsg:format(name, location))
end

function showResults(query, msg)
    DebugNote("Executing search query: ", query)
    SnDdb = sqlite3.open(snd_db_file)
    mshow = {}

    local searchMsg, failure = msg, "No matches found!"

    local dividers =
        "+" ..
        string.rep("-", 30) ..
            "+" ..
                string.rep("-", 25) ..
                    "+" .. string.rep("-", 9) .. "+" .. string.rep("-", 12) .. "+" .. string.rep("-", 7) .. "+"

    InfoNote(searchMsg)
    ColourNote("dimgray", "", dividers)
    ColourNote(
        "dimgray",
        "",
        "| ",
        "white",
        "",
        string.format("%-28s", "Mob name"),
        "dimgray",
        "",
        " | ",
        "green",
        "",
        string.format("%-23s", "Room name"),
        "dimgray",
        "",
        " | ",
        "cyan",
        "",
        string.format("%-7s", "ID"),
        "dimgray",
        "",
        " | ",
        "yellow",
        "",
        string.format("%-10s", "Zone"),
        "dimgray",
        "",
        " | ",
        "white",
        "",
        "Kills",
        "dimgray",
        "",
        " |"
    )

    ColourNote("dimgray", "", dividers)

    local count = 0

    for a in SnDdb:rows(query) do
        count = count + 1
        if #a > 0 then
            mName, rName, rID, zName, mobKills = count .. ". " .. a[1], a[2], tostring(a[3]), a[4], a[6]

            if #mName > 28 then
                mName = mName:sub(1, 28)
            end

            if #rName > 23 then
                rName = rName:sub(1, 23)
            end

            bgColor = ifc(count % 2 == 0, "midnightblue", "black")

            table.insert(mshow, {a[1], zName, rID})

            ColourTell(
                "dimgray",
                bgColor,
                "| ",
                "white",
                bgColor,
                string.format("%-28s", mName),
                "dimgray",
                bgColor,
                " | ",
                "limegreen",
                bgColor,
                string.format("%-23s", rName),
                "dimgray",
                bgColor,
                " | "
            )

            Hyperlink("mapper goto " .. rID, string.format("%-7s", rID), "goto " .. rID, "cyan", bgColor, 0, 1)

            ColourTell(
                "dimgray",
                bgColor,
                " | ",
                "yellow",
                bgColor,
                string.format("%-10s", zName),
                "dimgray",
                bgColor,
                " | ",
                "white",
                bgColor,
                string.format("%5d", mobKills),
                "dimgray",
                bgColor,
                " |\n"
            )
        end
    end

    if count == 0 then
        ColourNote("dimgray", "", "| ", "tomato", "", string.format("%-90s", failure), "dimgray", "", "|")
    end

    ColourNote("dimgray", "", dividers)

    if count == 1 then
        InfoNote("1 match found!")
    elseif count > 1 then
        InfoNote(count .. " matches found!")
    end

    SnDdb:close()
    SnDdb = nil
end

function mobShow(name, line, args)
    if #mshow ~= 0 then
        mob, zone, room, rid =
            mshow[tonumber(args[1])][1],
            mshow[tonumber(args[1])][2],
            mshow[tonumber(args[1])][3],
            mshow[tonumber(args[1])][4]
        Execute(args[2] .. " " .. string.format(showStr, mob, zone, room, rid))
    else
        InfoNote("No results loaded. Try searching for your mob first.")
    end
end

function mobGo(name, line, args)
    if #mshow ~= 0 then
        Execute("mapper goto " .. mshow[tonumber(args[1])][3])
    else
        InfoNote("No results loaded. Try searching for your mob first.")
    end
end

function fixSQL(str)
    return str:gsub("'", "''")
end

function strip_colours(s)
    s = s:gsub("@@", "\0") -- change @@ to 0x00
    s = s:gsub("@%-", "~") -- fix tildes (historical)
    s = s:gsub("@x%d?%d?%d?", "") -- strip valid and invalid xterm color codes
    s = s:gsub("@.([^@]*)", "%1") -- strip normal color codes and hidden garbage
    return (s:gsub("%z", "@")) -- put @ back (has parentheses on purpose)
end

function xset_nx_check()
    InfoNote("xset nx is set to ", xset_nx_action)
    print_xset_nx_desc()
end

function xset_nx(name, line, wildcards)
    xset_nx_action = wildcards.action
    set_variable("mcvar_xset_nx_action", xset_nx_action)
    print_xset_nx_desc()
end

function print_xset_nx_desc()
    if xset_nx_action == "smartscan" then
        InfoNote(
            "You will ",
            "scan",
            " every room upon arrival after nx or go, filtering down to just campaign, gquest, and quest targets. If you encounter potential noscan mobs, follow up with a filtered ",
            "consider",
            " to check if they are here.\n"
        )
    elseif xset_nx_action == "con" then
        InfoNote("You will ", "consider", " every room upon arrival after nx or go.\n")
    elseif xset_nx_action == "scan" then
        InfoNote("You will ", "scan", " surrounding rooms upon arrival after nx or go.\n")
    elseif xset_nx_action == "scanhere" then
        InfoNote("You will ", "scan the current room", " upon arrival after nx or go.\n")
    elseif xset_nx_action == "qs" then
        InfoNote(
            "You will ",
            "quick scan",
            " every room upon arrival after nx or go, looking only for your target mob.\n"
        )
    else
        InfoNote("You will take no action upon arrival after nx or go.\n")
    end
end

function xset_con_overwrite()
    if xset_overwrite_con == "on" then
        xset_overwrite_con = "off"
    else
        xset_overwrite_con = "on"
    end
    toggle_con_overwrite_triggers()
    set_variable("mcvar_xset_overwrite_con", xset_overwrite_con)

    InfoNote("\nConsider overwriting is now ", string.upper(xset_overwrite_con))
end

function is_con_overwritten()
    return xset_overwrite_con == "on"
end

function toggle_con_overwrite_triggers()
    local enabled = is_con_overwritten()
    for i, name in ipairs(GetTriggerList()) do
        if GetTriggerInfo(name, 26) == "consider" then
            SetTriggerOption(name, "omit_from_output", enabled)
        end
    end
end

function consider_trigger(name, line, wildcards, style)
    local con_details = {
        ["con_1"] = {level_range = "-20 and below", colour = "cornflowerblue"},
        ["con_2"] = {level_range = "-10 to -19", colour = "deepskyblue"},
        ["con_3"] = {level_range = "-5 to -9", colour = "turquoise"},
        ["con_4"] = {level_range = "-2 to -4", colour = "mediumspringgreen"},
        ["con_5"] = {level_range = "-1 to +1", colour = "lime"},
        ["con_6"] = {level_range = "+2 to +4", colour = "lawngreen"},
        ["con_7"] = {level_range = "+5 to +9", colour = "limegreen"},
        ["con_8"] = {level_range = "+10 to +15", colour = "greenyellow"},
        ["con_9"] = {level_range = "+16 to +20", colour = "#EFF22D"},
        ["con_10"] = {level_range = "+21 to +30", colour = "gold"},
        ["con_11"] = {level_range = "+31 to +40", colour = "darkorange"},
        ["con_12"] = {level_range = "+41 to +50", colour = "orangered"},
        ["con_13"] = {level_range = "+51 and above", colour = "red"}
    }

    local details = con_details[name]
    local on_target_list = false
    local mob_name = Trim(wildcards.mob_name)
    local lower_mob_name = mob_name:lower()
    local tags = mob_activity_tags(mob_name, true)
    local mob_scanned = false

    EnableTrigger("consider_end", true)

    if con_after_scan then
        for i, scanned_mob in ipairs(scanned_mobs_here) do
            if scanned_mob == lower_mob_name then
                mob_scanned = true
                break
            end
        end
    end

    if not mob_scanned then
        table.insert(considered_mobs_here, lower_mob_name)
    end

    if is_con_overwritten() and (#tags > 0 or not con_after_scan) then
        for i, tag in ipairs(tags) do
            ColourTell(tag.colour, "", tag.text)
        end

        for i, s in ipairs(style) do
            if string.match(s.text, "^%s*%(.+%)%s*$") or s.text == " " then
                NoteStyle(s.style)
                ColourTell(RGBColourToName(s.textcolour), RGBColourToName(s.backcolour), s.text)
            else
                break
            end
        end

        NoteStyle(0)
        ColourNote("silver", "", mob_name, details.colour, "", string.format(" (%s)", details.level_range))
    end
end

function consider_unkillable(name, line, wildcards, style)
    EnableTrigger("consider_end", true)

    if is_con_overwritten() and not con_after_scan then
        local mob_name = Trim(wildcards.name)

        for i, s in ipairs(style) do
            if string.match(s.text, "^%s*%(.+%)%s*$") then
                ColourTell(RGBColourToName(s.textcolour), RGBColourToName(s.backcolour), s.text)
            else
                break
            end
        end

        ColourTell("silver", "", mob_name)
        NoteStyle(1)
        if name == "consider_shopkeeper" then
            ColourNote("gold", "", " (shopkeeper)")
        else
            ColourNote("white", "", " (divine protection)")
        end
    end
end

function consider_end()
    EnableTriggerGroup("consider_end", false)

    if #considered_mobs_here > 0 then
        write_mob_list_to_db(considered_mobs_here)
    else
        DebugNote("No considered mobs found to update the mobs database")
    end

    -- Don't play sound when a quest target is here, assume soundpack will already play a sound
    if not quest_target_found_here then
        if activity_target_found_here then
            -- The current target is found in the room, play a sound
            play_target_found_sound()
        elseif not con_after_scan then
            -- A non-active target on the campaign/gquest list is found in the current room, play a sound
            if other_target_found_here then
                play_other_target_here_sound()
            end
        end
    end

    local target_found = quest_target_found_here or activity_target_found_here or other_target_found_here
    if con_after_scan and not target_found then
        ColourNote(RGBColourToName(GetNormalColour(8)), "", "Consider found no targets in this room.\n")
    end

    activity_target_found_here = false
    quest_target_found_here = false
    other_target_found_here = false
    con_after_scan = false
    considered_mobs_here = {}
end

function play_target_found_sound()
    DebugNote("Play target found here sound")
    if is_sound_enabled() and IsPluginInstalled(plugin_id_soundpack) and GetPluginInfo(plugin_id_soundpack, 17) then
        CallPlugin(plugin_id_soundpack, "TriggerEvent", "quest_target_found")
    end
end

function play_target_nearby_sound()
    DebugNote("Play target found nearby sound")
    if is_sound_enabled() and sound_not_played then
        sound_not_played = false
        PlaySound(0, GetInfo(74) .. target_nearby_sound, false, 100, 0)
    end
end

function play_other_target_here_sound()
    DebugNote("Play other target here sound")
    if is_sound_enabled() and sound_not_played then
        sound_not_played = false
        PlaySound(0, GetInfo(74) .. other_target_here_sound, false, 100, 0)
    end
end

function scan_start()
    EnableTriggerGroup("scan", true)
    doors_in_scanned_room = {}
    scanned_mobs_here = {}
    scan_full_display = {{doors = doors_in_scanned_room}}
end

function scan_end()
    EnableTriggerGroup("scan", false)

    local anything_seen = false

    for i, room in ipairs(scan_full_display) do
        if room.mobs and #room.mobs > 0 then
            if room.header then
                for j, style in ipairs(room.header) do
                    NoteStyle(style.style)
                    ColourTell(style.color, style.bcolor, style.text)
                end
                print("")
            end

            for j, mob in ipairs(room.mobs) do
                anything_seen = true
                for k, style in ipairs(mob) do
                    NoteStyle(style.style)
                    ColourTell(style.color, style.bcolor, style.text)
                end
                print("")
            end
        end

        if #room.doors > 0 then
            for j, door in ipairs(room.doors) do
                for k, style in ipairs(door) do
                    NoteStyle(style.style)
                    ColourTell(style.color, style.bcolor, style.text)
                end
                print("")
            end
        end
    end

    if not anything_seen and running_smart_scan then
        ColourNote(RGBColourToName(GetNormalColour(8)), "", "You see no targets around.")
    end

    write_mob_list_to_db(scanned_mobs_here)

    if not quest_target_found_here then
        if activity_target_found_here then
            play_target_found_sound()
        else
            if running_smart_scan and #scanned_mobs_here < mob_count_here then
                DebugNote("Saw ", mob_count_here, " mobs in the room but only ", #scanned_mobs_here, " on scan")
                InfoNote(
                    "Target not found on smart scan but potential noscan mobs found in this room. Running consider."
                )
                con_after_scan = true
                SendNoEcho("con")
            end

            if target_found_nearby then
                play_target_nearby_sound()
            end

            if other_target_found_here then
                play_other_target_here_sound()
            end
        end
    end
    scanning_current_room = false
    activity_target_found_here = false
    quest_target_found_here = false
    target_found_nearby = false
    other_target_found_here = false
    running_smart_scan = false
end

function scan_location_current_room(name, line, wildcards, style)
    scanning_current_room = true
    scanned_mobs_here = {}
    setup_scan_room(style)
end

function scan_location_nearby_room(name, line, wildcards, style)
    scanning_current_room = false
    setup_scan_room(style)
end

function setup_scan_room(style)
    mobs_in_scanned_room = {}
    doors_in_scanned_room = {}
    table.insert(
        scan_full_display,
        {header = convert_full_styles(style), mobs = mobs_in_scanned_room, doors = doors_in_scanned_room}
    )
end

function scan_door_nearby(name, line, wildcards, style)
    table.insert(doors_in_scanned_room, convert_full_styles(style))
end

function convert_full_styles(styles)
    local result = {}
    for i, style in ipairs(styles) do
        table.insert(result, convert_one_style(style))
    end
    return result
end

function convert_one_style(style)
    return {
        style = style.style or 0,
        color = RGBColourToName(style.textcolour),
        bcolor = RGBColourToName(style.backcolour),
        text = style.text
    }
end

function scan_mob(name, line, wildcards, style)
    local tags = {}
    if not string.match(wildcards.flags, "(Player)") and not string.find(wildcards.flags, "(P)") then
        local mob_name = wildcards.mob_name
        tags = mob_activity_tags(mob_name, scanning_current_room)

        if scanning_current_room then
            table.insert(scanned_mobs_here, mob_name:lower())
        end
    end

    if #tags > 0 or not running_smart_scan then
        local padding = 5
        local mob_styled_text = {}
        for i, tag in ipairs(tags) do
            table.insert(mob_styled_text, {style = 0, color = tag.colour, bcolor = "", text = tag.text})
            padding = padding - #tag.text
        end

        for i, s in ipairs(style) do
            if i == 1 then
                s.text = string.gsub(s.text, "^     ", string.rep(" ", padding))
            end
            table.insert(mob_styled_text, convert_one_style(s))
        end
        table.insert(mobs_in_scanned_room, mob_styled_text)
    end
end

function scan_empty(name, line, wildcards, style)
    if not running_smart_scan then
        for i, s in ipairs(style) do
            ColourTell(RGBColourToName(s.textcolour), RGBColourToName(s.backcolour), s.text)
        end
    end
end

function roomchars_start()
    mob_count_here = 0
    EnableTrigger("roomchars", true)
end

function roomchars_end()
    EnableTrigger("roomchars", false)
    DebugNote("Detected ", mob_count_here, string.format(" mob%s in this room", mob_count_here == 1 and "" or "s"))
end

function roomchars()
    mob_count_here = mob_count_here + 1
end

function mob_activity_tags(mob_name, checking_current_room)
    local on_target_list = false
    local lower_mob_name = mob_name:lower()
    local result = {}

    for i, target in ipairs(main_target_list) do
        if (current_room.arid == target.arid or target.unknown) and target.mob:lower() == lower_mob_name then
            on_target_list = true
            break
        end
    end

    if on_target_list then
        if checking_current_room then
            if has_activity_target() and current_target.name:lower() == lower_mob_name then
                activity_target_found_here = true
            else
                other_target_found_here = true
            end
        else
            target_found_nearby = true
        end
        table.insert(result, {text = "[", colour = "gold"})
        table.insert(result, {text = current_activity:upper(), colour = "magenta"})
        table.insert(result, {text = "] ", colour = "gold"})
    end

    if quest_target.mob and quest_target.mob:lower() == lower_mob_name and quest_target.arid == current_room.arid then
        if checking_current_room then
            quest_target_found_here = true
        else
            target_found_nearby = true
        end
        table.insert(result, {text = "[", colour = "gold"})
        table.insert(result, {text = "Q", colour = "magenta"})
        table.insert(result, {text = "] ", colour = "gold"})
    end

    return result
end

function write_mob_list_to_db(mob_list)
    if #mob_list < 1 then
        DebugNote("No mobs to be written to the database")
        return
    end

    local rname = strip_colours(gmcp("room.info.name"))
    local zname = gmcp("room.info.zone")
    local writes = {}
    local sql_mobs = {}
    for i, mob in ipairs(mob_list) do
        table.insert(sql_mobs, fixsql(mob))
        table.insert(
            writes,
            string.format(
                "INSERT OR IGNORE INTO mobs (mob,room,roomid,zone) VALUES (%s,%s,%i,%s);",
                fixsql(mob),
                fixsql(rname),
                tonumber(current_room.rmid),
                fixsql(zname)
            )
        )
        table.insert(
            writes,
            string.format(
                "UPDATE mobs SET seen_count = seen_count + 1 WHERE mob = %s AND roomid = %i;",
                fixsql(mob),
                tonumber(current_room.rmid)
            )
        )
    end

    local db = assert(sqlite3.open(snd_db_file))

    execute_in_transaction(db, writes)

    if debug_mode == "on" then
        if db:errcode() > 0 then
            ErrorNote("Db error: " .. db:error_message())
        else
            DebugNote("Successfully inserted or updated ", #mob_list, " in the mobs database")
        end
    end
    db:close_vm()
end

function update_sounds_onoff_value(new_val)
    xset_sound_onoff = new_val
    set_variable("mcvar_xset_sound_onoff", xset_sound_onoff)

    InfoNote("\nSearch&Destroy Sounds are now ", string.upper(xset_sound_onoff))
end

function xset_sound()
    if xset_sound_onoff == "on" then
        update_sounds_onoff_value("off")
    else
        download_sounds(
            function(success)
                if success then
                    xset_sound_onoff = "on"
                    update_sounds_onoff_value("on")
                else
                    ErrorNote("Sound could not be enabled")
                end
            end
        )
    end
end

function is_sound_enabled()
    return xset_sound_onoff == "on"
end

function xset_table_notes()
    if table_notes == "on" then
        table_notes = "off"
        InfoNote("Room notes will no longer be shown directly in the tables")
    else
        table_notes = "on"
        InfoNote("Room notes will be shown directly in the tables")
    end
    SetVariable("mcvar_xset_table_notes", table_notes)
end

function show_notes_in_table()
    return table_notes == "on"
end

function xset_table_width(name, line, wildcards)
    local width = tonumber(wildcards.width) or 80
    table_width = math.min(150, math.max(80, width))
    InfoNote("Set table width to ", table_width)
    SetVariable("mcvar_xset_table_width", table_width)
end

function trigger_receive_xp()
    if last_mob_damaged then
        DebugNote(
            "I suspect you just killed ",
            last_mob_damaged,
            " in room ",
            current_room.rmid,
            " (",
            current_room.arid,
            ")"
        )
        last_mob_killed = last_mob_damaged
    else
        DebugNote("****** ", "I don't know which mob you just killed", " ******")
    end
    last_mob_damaged = nil
end

function trigger_damage_done(name, line, wildcards)
    last_mob_damaged = Trim(wildcards.mob_name)
end

function set_variable(key, value)
    SetVariable(key, value or "")
    state_changed = true
    DebugNote("Changing ", key, " to ", value)
end

function check_state_changed()
    if state_changed then
        state_changed = false
        SaveState()
        DebugNote("State changed. Saving plugin state file.")
    end
end

local SCAN_FLAGS = {
    -- Player flags
    "P",
    "Player",
    "OPK",
    "Linkdead",
    "WANTED",
    "HARDCORE",
    "OPK",
    "Linkdead",
    "Raider",
    "Traitor",
    -- Mob flags
    "Animated",
    "A",
    "Angry",
    "Charmed",
    "C",
    "Diseased",
    "D",
    "Golden Aura",
    "G",
    "Hidden",
    "H",
    "Invis",
    "I",
    "Marked",
    "X",
    "Red Aura",
    "R",
    "Stealth",
    "S",
    "Translucent",
    "T",
    "Undead",
    "U",
    "White Aura",
    "W",
    "wounded",
    "aimed",
    "Old",
    "O"
}

local CONSIDER_OUTCOMES = {
    "You would stomp (?<mob_name>.+?) into the ground\\.$",
    "(?<mob_name>.+?) would be easy, but is it even worth the work out\\?$",
    "No Problem! (?<mob_name>.+?) is weak compared to you\\.$",
    "(?<mob_name>.+?) looks a little worried about the idea\\.$",
    "(?<mob_name>.+?) should be a fair fight!$",
    "(?<mob_name>.+?) snickers nervously\\.$",
    "(?<mob_name>.+?) chuckles at the thought of you fighting \\S+\\.$",
    "Best run away from (?<mob_name>.+?) while you can!$",
    "Challenging (?<mob_name>.+?) would be either very brave or very stupid\\.$",
    "(?<mob_name>.+?) would crush you like a bug!$",
    "(?<mob_name>.+?) would dance on your grave!$",
    "(?<mob_name>.+?) says 'BEGONE FROM MY SIGHT unworthy\\!'$",
    "You would be completely annihilated by (?<mob_name>.+?)!$"
}

function setup_scan_con_triggers()
    local flags_string = "(?<flags>(?: ?\\[AFK\\]| ?\\((?:" .. table.concat(SCAN_FLAGS, "|") .. ")\\))*)?"
    local match = "^ {5}-" .. flags_string .. " (?<mob_name>.+)$"
    local name

    local flags = trigger_flag.OmitFromOutput + trigger_flag.IgnoreCase + trigger_flag.RegularExpression

    AddTriggerEx("scan_mob", match, "", flags, -1, 0, "", "scan_mob", sendto.script, 100)
    SetTriggerOption("scan_mob", "group", "scan")

    flags = flags + trigger_flag.Enabled

    for i, str in ipairs(CONSIDER_OUTCOMES) do
        match = "^" .. flags_string .. " ?" .. str
        name = string.format("con_%i", i)
        AddTriggerEx(name, match, "", flags, -1, 0, "", "consider_trigger", sendto.script, 100)
        SetTriggerOption(name, "group", "consider")
    end
end

	]]>
</script>
<triggers>
+<!-- Receive xp -->
	<trigger match="^You (?:don't )?receive \d+(?:\+\d+)* experience points?\."
		script="trigger_receive_xp" ignore_case="y" enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

<!-- Damage triggers -->
	<trigger match="^.+\w tickles +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w bruises +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w scratches +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w grazes +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w nicks +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w scars +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w hits +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w injures +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w wounds +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w mauls +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w maims +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w mangles +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w mars +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w LACERATES +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w DECIMATES +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w DEVASTATES +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w ERADICATES +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w OBLITERATES +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w EXTIRPATES +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w INCINERATES +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w MUTILATES +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w DISEMBOWELS +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w MASSACRES +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w DISMEMBERS +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w RENDS +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w - BLASTS - +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w -= DEMOLISHES =- +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w \*\* SHREDS \*\* +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w \*\*\*\* DESTROYS \*\*\*\* +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w \*\*\*\*\* PULVERIZES \*\*\*\*\* +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w -=- VAPORIZES -=- +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-==-> ATOMIZES <-==-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-:-> ASPHYXIATES <-:-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-\*-> RAVAGES <-\*-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <>\*<> FISSURES <>\*<> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <\*><\*> LIQUIDATES <\*><\*> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <\*><\*><\*> EVAPORATES <\*><\*><\*> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-=-> SUNDERS <-=-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <=-=><=-=> TEARS INTO <=-=><=-=> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <->\*<=> WASTES <=>\*<-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-\+-><-\*-> CREMATES <-\*-><-\+-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <\*><\*><\*><\*> ANNIHILATES <\*><\*><\*><\*> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <--\*--><--\*--> IMPLODES <--\*--><--\*--> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-><-=-><-> EXTERMINATES <-><-=-><-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-==-><-==-> SHATTERS <-==-><-==-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <\*><-:-><\*> SLAUGHTERS <\*><-:-><\*> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-\*-><-><-\*-> RUPTURES <-\*-><-><-\*-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-\*-><\*><-\*-> NUKES <-\*-><\*><-\*-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w -<\[=-\+-=\]<:::<>:::> GLACIATES <:::<>:::>\[=-\+-=\]>- +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-=-><-:-\*-:-><\*--\*> METEORITES <\*--\*><-:-\*-:-><-=-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w <-:-><-:-\*-:-><-\*-> SUPERNOVAS <-\*-><-:-\*-:-><-:-> +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w does UN\w+ things to +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w damages? +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +shreds +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +destroys +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +pulverizes +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +vaporizes +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +atomizes +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +asphyxiates +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +ravages +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +fissures +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +liquidates +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +evaporates +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +sunders +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +into +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +wastes +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +cremates +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +annihilates +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +implodes +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +exterminates +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +shatters +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +slaughters +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +ruptures +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +nukes +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +glaciates +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +meteorites +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^.+\w +supernovas +(?<mob_name>\S.*)[!\.] \[\d+\]$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

	<trigger match="^(?:You assassinate |You catch |You attempt to bury .* deep into |You lunge at)(?<mob_name>.*)(?: with cold efficiency\.| completely off-guard and inflict massive damage on .*\.|'s? back!|with a .*!)$"
		script="trigger_damage_done" ignore_case="y"  enabled="y" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="n" > </trigger>

<!-- Gquest operations -->
	<!-- group: trg_gq -->
	<trigger match="^Quest Name\.\.\.\.\.\.\.\.\.: \[ Global quest # (?<gq_id>\d{1,5}) \]$"
		script="gq_info_quest_name"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^---------------------------------------------------------------------------$"
		script="gq_info_end"
		group="trg_gq_info"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Quest Status\.\.\.\.\.\.\.: \[ Extended \]$"
		script="gq_info_extended"
		group="trg_gq_info"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Quest Status\.\.\.\.\.\.\.: \[ Finished \]$"
		script="gq_info_finished"
		group="trg_gq_info"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Level range\.\.\.\.\.\.\.\.: \[\s+(?<minlvl>\d{1,3}) \] - \[\s+(?<maxlvl>\d{1,3}) \]$"
		script="gq_info_level_range"
		group="trg_gq_info"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Kill at least (?<qty>\d) \* (?<target>.+)\.$"
		script="gq_info_line"
		group="trg_gq_info"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^You still have to kill (?<qty>[1-3]) \* (?<target>.+)$"
		script="gq_check_line"
		name="trg_gq_check_line" group="trg_gq_check"
		enabled="n"	regexp="y" sequence="500" keep_evaluating="y" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_gq_check_end", true) </send> </trigger>

	<trigger match="^(?!You still have to kill [1-3] \* .+ \(\S.+?(?: - Dead)?\))$"
		script="gq_check_end"
		name="trg_gq_check_end" group="trg_gq_check"
		enabled="n"	regexp="y" sequence="500" keep_evaluating="y" omit_from_output="n" send_to="12" > </trigger>

	<!-- gq messages to always listen for -->
	<trigger match="^You have now joined Global Quest # (?<gq_id>\d{1,5})\. See 'help gquest' for available commands\.$"
		script="gqmsg_joined"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest: Global quest # (?<gq_id>\d{1,5}) for levels (?<min_lvl>\d{1,3}) to (?<max_lvl>\d{1,3})(?: - (?:200|10) or fewer wins only)? has now started\.$"
		script="gqmsg_started"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<!-- gq messages to only listen for when in a gquest -->
	<trigger match="^You have finished this global quest\.$"
		script="player_not_on_gq"
		name="trg_gq_finished_extended" 	group="trg_gqmsg"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest: Global Quest # (?<gq_id>\d{1,5}) has been won by (?<winner>[A-Z][A-Za-z]+) - \d*(?:1st|2nd|3rd|\dth) win\.$"
		script="gqmsg_winner"
		name="trg_gqmsg_winner" 			group="trg_gqmsg"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest: Global Quest # (?<gq_id>\d{1,5}) will go into extended time for 5 more minutes\.$"
		script="gqmsg_extended_time"
		name="trg_gqmsg_extended_time" 		group="trg_gqmsg_ext"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest: Global quest # (?<gq_id>\d{1,5})(?: \(extended\))? is now over\.$"
		script="gq_ended"
		name="trg_gqmsg_extended_end" 		group="trg_gqmsg"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest: Global quest # (?<gq_id>\d{1,5}) has been cancelled due to lack of activity\.$"
		script="gq_ended"
		name="trg_gqmsg_extended_end2" 		group="trg_gqmsg"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^You are no longer part of Global Quest # (?<gq_id>\d{1,5}) and will be unable to rejoin\.$"
		script="player_not_on_gq"
		name="trg_gqmsg_quit" 				group="trg_gqmsg"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Congratulations, that was one of the GLOBAL QUEST mobs\!$"
		script="gq_mob_killed"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^You are not in a global quest\.$"
		script="player_not_on_gq"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^There are no global quests running\.$"
		script="player_not_on_gq"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^Global Quest # (?<gq_id>\d{1,5}) has not yet started\.$"
		script="gq_check_not_yet_started"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

<!-- CAMPAIGN OPERATIONS -->
	<trigger match="^Level Taken\.{8}: \[\s+(?<level>[1-2]?\d{1,2}) \]$"
		script="cp_info_level_taken"
		name="trg_cp_info_level_taken" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_info_level_taken", false) </send> </trigger>

	<trigger match="^The targets for this campaign are:$"
		script=""
		name="trg_cp_info_targets" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_info_targets", false)
					EnableTrigger("trg_cp_info_line", true)
					EnableTrigger("trg_cp_info_end", true) </send> </trigger>

	<trigger match="^Find and kill 1 \* (?<target>.+)$"
		script="cp_info_line"
		name="trg_cp_info_line" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^(?!Find and kill 1 \* .+ \(.+\))$"
		script="cp_info_end"
		name="trg_cp_info_end" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_info_line", false)
					EnableTrigger("trg_cp_info_end", false) </send> </trigger>

	<trigger match="^You still have to kill \* (?<target>.+)$"
		script="cp_check_line"
		name="trg_cp_check_line" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_check_end", true)</send> </trigger>


	<trigger match="^(?!You still have to kill \* .+ \(.+?(?: - Dead)?\))$"
		script="cp_check_end"
		name="trg_cp_check_end" group="trg_campaign"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_check_gag_dead", true)
					EnableTrigger("trg_cp_check_line", false)
					EnableTrigger("trg_cp_check_end", false) </send> </trigger>

	<trigger match="^Note: Dead means that the target is dead, not that you have killed it\.$"
		name="trg_cp_check_gag_dead" group="trg_campaign"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_cp_check_gag_dead", false) </send> </trigger>

<!-- CAMPAIGN STATUS TRACKING -->
	<trigger match="^Congratulations, that was one of your CAMPAIGN mobs\!$"
		script="cp_mob_killed"
		name="trg_cp_mob_killed" 	group="trg_cp_2"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^CONGRATULATIONS\! You have completed your campaign\.$"
		script="do_cp_complete"
		name="trg_cp_complete" 		group="trg_cp_2"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y"> </trigger>

	<trigger match="^Campaign cleared\.$"
		script="player_not_on_cp"
		name="trg_cp_quit" 			group="trg_cp_2"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^\w.+ tells you 'Good luck in your campaign\!'$"
		script="player_start_new_cp"
		name="trg_cp_request" 		group="trg_cp_2"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^You are not currently on a campaign\.$"
		script="player_not_on_cp"
		name="trg_player_not_on_cp" group="trg_cp_2"
		enabled="y"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^(?:(?:## )?You may now take another campaign\.|You may take (?:a campaign at this level|another campaign)\.)$"
		script="cp_check_can_get_new_cp"
		name="trg_can_get_new_cp" group="trg_cp_2"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^You (?:will have to level before you can go on another campaign|cannot take another campaign for (?:(?:\d+ hours?, )?\d+ minutes? and )?\d+ seconds?)\.$"
		name="trg_cannot_get_new_cp" group="trg_cp_2"
		script="cp_check_cannot_get_new_cp"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^You use a daily blessing campaign reset token to reset your campaign\.$"
		name="trg_cp_reset_token" group="trg_cp_2"
		script=""
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" omit_from_output="n" send_to="12" > </trigger>

<!-- QUICK WHERE -->
	<trigger match="^(?<mobname>.{30}) (?<roomname>[^ (0-9].*)$"
		script="qw_match"
		name="trg_quick_where_match" group="QuickWhere"
		enabled="n"	regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^There is no \w.+ around here\.$"
		script="qw_no_match"
		name="trg_quick_where_no_match" group="QuickWhere"
		enabled="n"	regexp="y" sequence="50" keep_evaluating="y" send_to="12" > </trigger>

<!-- HUNT TRICK -->
	<trigger match="^You are (?:almost )?certain that \w.+ is (?:north|south|east|west|up|down) from here\.|You are confident that \w.+ passed through here, heading (?:north|south|east|west|up|down)\.|The trail of \w.+ is confusing, but you're reasonably sure \w.+ headed (?:north|south|east|west|up|down)\.|There are traces of \w.+ having been here. Perhaps they lead (?:north|south|east|west|up|down)\?|You have no idea what you\'re doing\, but maybe \w.+ is (?:north|south|east|west|up|down)\?|You couldn\'t find a path to \w.+ from here\.|\w.+ is here\!$"
		script="ht_continue"
		name="trg_hunt_trick_continue_dir" group="HuntTrick"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You are (?:almost )?certain that \w.+ is through .+\.|You are confident that \w.+ passed through here, heading through .+\.|The trail of \w.+ is confusing, but you're reasonably sure \w.+ headed through .+\.|There are traces of \w.+ having been here\. Perhaps they lead through \w.+\?|You have no idea which way \w.+ went\.$"
		script="ht_continue"
		name="trg_hunt_trick_continue_portal" group="HuntTrick"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You seem unable to hunt that target for some reason\.$"
		script="ht_complete"
		name="trg_hunt_trick_complete" group="HuntTrick"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^\w.+ is here\!$"
		name="trg_hunt_trick_continue_2" group="HuntTrick"
		script="ht_continue"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^No one in this area by the name '\w.+'\.$"
		name="trg_hunt_trick_fail" group="HuntTrick"
		script="ht_fail"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^Not while you are fighting\!|You can't hunt while (?:resting|sitting)\.|You dream about going on a nice hunting trip, with pony rides, and campfires too\.$"
		name="trg_hunt_trick_abort" group="HuntTrick"
		script="ht_abort"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

<!--  AUTO HUNT -->
	<trigger match="^You are (?:almost )?certain that (?<mob>\w.+) is (?<dir>north|south|east|west|up|down) from here\.$"
		script="auto_hunt_next"
		name="trg_autohunt_next_1" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You are confident that (?<mob>.+) passed through here\, heading (?<dir>north|south|east|west|up|down)\.$"
		script="auto_hunt_next"
		name="trg_autohunt_next_2" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^The trail of \w.+ is confusing, but you\'re reasonably sure .+ headed (?:north|south|east|west|up|down)\.|There are traces of \w.+ having been here\. Perhaps they lead (?:north|south|east|west|up|down)\?|You have no idea what you\'re doing, but maybe \w.+ is (?:north|south|east|west|up|down)\?$"
		script="auto_hunt_lowskill"
		name="trg_autohunt_lowskill" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You are (?:almost )?certain that \w.+ is through .+\.|You are confident that \w.+ passed through here, heading through .+\.|The trail of \w.+ is confusing, but you're reasonably sure \w.+ headed through .+\.|There are traces of \w.+ having been here\. Perhaps they lead through .+\?|You have no idea what you\'re doing\, but maybe \w.+ is through .+\?$"
		script="auto_hunt_portal"
		name="trg_autohunt_portal" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^No one in this area by the name '\w.+'\.|You couldn\'t find a path to \w.+ from here\.|No one in this area by that name\.|Not while you are fighting\!|You can't hunt while (?:resting|sitting)\.|You dream about going on a nice hunting trip, with pony rides, and campfires too\.$"
		script="auto_hunt_abort"
		name="trg_autohunt_abort" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^You seem unable to hunt that target for some reason\.$"
		script="auto_hunt_abort"
		name="trg_hunt_trick" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^\w.+ is here\!$"
		script="auto_hunt_complete"
		name="trg_autohunt_complete" group="AutoHunt"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^Magical wards around \w.+ bounce you back\.$"
		name="trg_autohunt_nopass" group="AutoHunt"
		script="auto_hunt_door"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^The \w.+ is closed\.$"
		name="trg_autohunt_door" group="AutoHunt"
		script="auto_hunt_door"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You do not have a key for \w.+\.$"
		name="trg_autohunt_no_key" group="AutoHunt"
		script="auto_hunt_abort"
		enabled="n" regexp="y" sequence="100" > </trigger>

	<trigger match="^You open \w.+\.$"
		name="trg_autohunt_door_open" group="AutoHunt"
		script="auto_hunt_door_open"
		enabled="n" regexp="y" sequence="100" > </trigger>

<!-- AUTO SET NOEXP -->
	<trigger match="^You will no longer receive experience\. Happy questing\!$"
		script="anex_automatic_off"
		name="trg_anex_automatic_off"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^You will now receive experience\. Happy leveling\!$"
		script="anex_automatic_on"
		name="trg_anex_automatic_on"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" > </trigger>

	<trigger match="^You (?:don't )?receive (\d+)(?:\+\d+)? experience points?\.$"
		script="anex_mobdeath_xp1"
		name="trg_anex_mobdeath_xp1"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y" send_to="12" > </trigger>

	<trigger match="^You raise a level\! You are now level \d+\.$"
		script="player_level_up"
		name="trg_player_level_up"
		enabled="y" regexp="y" sequence="100" keep_evaluating="y"> </trigger>

<!-- AREA INDEX PROCESS -->
	<trigger match="^              \[ Listing all areas in range 1 to 300 \]$"
		script="area_index_start"
		name="trg_area_index_start" group="AreaIndex"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_gag_headers", true)
					EnableTrigger("trg_area_index_gag_header_lines", true)
					EnableTrigger("trg_area_index_line", true)
					EnableTrigger("trg_area_index_gag_lock_means", true)
					EnableTrigger("trg_area_index_end", true) </send> </trigger>

	<trigger match="^From To   Lock  Keyword          Area Name                      $"
		name="trg_area_index_gag_headers" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_gag_headers", false) </send> </trigger>

	<trigger match="^---- ---- ----  ---------------  ------------------------------$"
		name="trg_area_index_gag_header_lines" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_gag_header_lines", false) </send> </trigger>

	<trigger match="^\s+(?<min>\d+)\s+(?<max>\d+)\s+(?<lock>\d+)?\s+?(?<arid>[0-9a-z]+?)\s+(?<areaName>[A-Z].+?)$"
		script="area_index_line"
		name="trg_area_index_line" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^'Lock' means you cannot enter until you are that level or higher\.$"
		name="trg_area_index_gag_lock_means" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_gag_lock_means", false) </send> </trigger>

	<trigger match="^---------------------------------------------------------------$"
		script="area_index_end"
		name="trg_area_index_end" group="AreaIndex"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" keep_evaluating="y" send_to="12" >
			<send>	EnableTrigger("trg_area_index_line", false)
					EnableTrigger("trg_area_index_end", false) </send> </trigger>

<!-- Consider -->

	<trigger match="^(?<name>.+) has divine protection\.$"
		script="consider_unkillable" name="consider_protected" group="consider"
		enabled="y" regexp="y" sequence="100" omit_from_output="n" send_to="12" > </trigger>

	<trigger match="^If you killed (?<name>.+), who would serve .+ customers\?$"
		script="consider_unkillable" name="consider_shopkeeper" group="consider"
		enabled="y" regexp="y" sequence="100" omit_from_output="n" send_to="12" > </trigger>

	<trigger match="^$"
		name="consider_end"
		group="consider_end"
		script="consider_end"
		enabled="n" regexp="y" sequence="100" omit_from_output="n" send_to="12" > </trigger>

	<trigger match="^(?:You see no one here but yourself!|Strange forces prevent violence here\.)$"
		name="consider_end_empty"
		group="consider_end"
		script="consider_end"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

<!-- Scan -->
	<trigger match="^Tag option scan turned ON$"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="{scan}"
		script="scan_start"
		enabled="y" regexp="n" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="{/scan}"
		script="scan_end"
		enabled="y" regexp="n" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^Right here you see:$"
		script="scan_location_current_room"
		group="scan"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^(\d )?(North|East|South|West|Up|Down) from here you see:$"
		script="scan_location_nearby_room"
		group="scan"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^You see .+\.$"
		script="scan_door_nearby"
		group="scan"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^Nothing to see around here, might as well move on\.$"
		script="scan_empty"
		group="scan"
		enabled="n" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

<!-- Roomchars -->
	<trigger match="^Tag option roomchars turned ON$"
		enabled="y" regexp="y" sequence="100" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="{roomchars}"
		script="roomchars_start"
		enabled="y" regexp="n" sequence="50" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="{/roomchars}"
		script="roomchars_end"
		enabled="y" regexp="n" sequence="50" omit_from_output="y" send_to="12" > </trigger>

	<trigger match="^.+$"
		script="roomchars" name="roomchars"
		enabled="n" regexp="y" sequence="100" omit_from_output="n" send_to="12" > </trigger>

<!-- PAGE SIZE -->
	<trigger match="^You currently display ([0-9]+) lines per page\.|You do not page long messages\.$"
		script="capture_page_size"
		name="trg_capture_page_size"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" omit_from_output = "y" > </trigger>

	<trigger match="^Use 'pagesize \<lines\>' to change, or 'pagesize 0' to disable paging\.$"
		script=""
		name="trg_pagesize_gag_1"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" omit_from_output = "y" send_to="12" >
			<send>	EnableTrigger("trg_pagesize_gag_1", false) </send> </trigger>

<!-- Misc. gag triggers -->
	<trigger match="^Players found: \[\d+\], Max this reboot: \[\d+\], Connections this reboot: \[\d+\]$"
		name="trg_gag_who_footer_1"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" > </trigger>

	<trigger match="^Players invis: \[\d+\], Max on ever: \[\d+\]$"
		name="trg_gag_who_footer_2"
		enabled="n" regexp="y" sequence="100" keep_evaluating="y" omit_from_output="y" > </trigger>

	<trigger match="^[\s\S]*$"
		name="trg_gag_everything"
		enabled="n" regexp="y" sequence="1" keep_evaluating="y" omit_from_output="y" > </trigger>
</triggers>

<aliases>
<!-- Plugin Update automatic -->
	<alias enabled="y" match="snd update" script="update_plugin" sequence="100">
	</alias>
	<alias enabled="y" match="^(?:xhelp|snd help)(?:\s(?<search>.*))?$" regexp="y" script="onHelp" sequence="100">
	</alias>

	<alias enabled="y" match="^snd force update(?: (?<branch>\S+))?$" script="force_update_plugin" regexp="y" sequence="100">
	</alias>

	<alias enabled="y" match="snd check_update" script="toggle_automatic_update_checking" sequence="100">
	</alias>

	<alias enabled="y" match="^xset silent(?: (on|off))?" regexp="y" script="xset_silentMode" sequence="100">
	</alias>

<!-- Auto-hunt commands-->
	<alias	match="^ah (?<arg>\w.+)$"
			script="auto_hunt"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:aha|ah0)$"
			script="auto_hunt_abort"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>
	
	<alias	match="^ah$"
			script="auto_hunt_noarg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- campaign data input: cp info, check -->
	<alias	match="^cp (?:i|info)$"
			script="do_cp_info"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^cp (?:ch|check)$"
			script="do_cp_check"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- gquest data input: gq info, check -->
	<alias	match="^gq i(?:n(?:fo?)?)?$"
			script="do_gq_info"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:gg|qq)$"
			script="do_gq_check"
			name="extra_gq_check_aliases"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:gq (?:c|ch|check))$"
			script="do_gq_check"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- xcp commands  -->
	<alias	match="^xcp$"
			script="xcp_noarg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xcp (?<index>[0-9]+)$"
			script="xcp_arg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xcp mode(?: (?<option>ht|qw|off))?$"
			script="xcp_set_action_mode"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xcp q(uest)?$"
		script="xcp_toggle_quest_targeting"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- movement: xrunto, go, nx, etc.  -->
	<alias	match="^(?:xrt|xrun|xrunto) (?<destination>.+)$"
			script="xrun_to_alias"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:go|goto)( (?<index>[0-9]+))?$"
			script="goto_number"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" keep_evaluating="y" > </alias>

	<alias	match="^nx$"
			script="goto_next"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^nx-$"
			script="goto_previous"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Automatic noexp -->
	<alias	match="^xset noexp( (?<arg>off|[0-9]+))?$"
			script="xset_noexp_tnl"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Quest commands -->
	<alias	match="^(?:xq|xq1)$"
			script="xq_command"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xqt$"
			script="retarget_quest"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Quick scan -->
	<alias	match="^qs$"
			script="quick_scan"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Quick-kill commands: qk, ak, kk, xset attack -->
	<alias	match="^(?:quick kill|ak|kk|qk)$"
			script="quick_kill"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset (?:kk|ak|qk|qkill)(?: (?<arg>.+))?$"
			script="xset_quick_kill_command"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Hunt trick -->
	<alias	match="^ht$"
			script="ht_noarg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^ht (?:(?<index>\d+)\.)?(?<mob>.+)?$"
			script="ht_arg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^ht(?:a|0| abort| stop)$"
			script="ht_abort"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Quick where -->
	<alias	match="^qw$"
			script="qw_noarg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^qw (?:(?<index>\d+)\.)?(?<mob>.+)?$"
			script="qw_arg_alias"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^qwx$"
			script="qw_exact"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- roomnotes -->
	<alias	match="^(?:roomnote|rn)$"
			script="room_note"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:roomnote|rn) a(?:rea)?(?: (?<arid>.+))?$"
			script="room_note_area"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:roomnote|rn) (?<roomid>\d+)$"
			script="room_note_room"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- Sql Execution -->
	<alias	match="^runsql (?<sql>.+)$"
			script="RunSql"
			enabled="y" regexp="y" sequence="1" ignore_case="y" send_to="12" > </alias>

	<alias	match="^execsql (?<sql>.+)$"
			script="ExecSql"
			enabled="y" regexp="y" sequence="1" ignore_case="y" send_to="12" > </alias>

<!-- xmapper  -->
	<alias	match="^(?:xmap|xmapper) move (?<roomid>\d+|-1)(?: (?<speed>run|walk))?$"
			script="xmapper_move"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xm(?:\ {(?<mob>[^\}]+)\})? (?<loc>.+)$"
			script="map_area"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xmall(?:\ {(?<mob>[^\}]+)\})? (?<loc>.+)$"
			script="map_area_all"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:xm|xmap|xmapper) rlh(?: (?<room_id>\d+))?$"
			script="xmap_rooms_linking_here"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- xset commands -->
	<alias  match="^xset (?:index areas|area index)$"
			script="area_index_process"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset (?:mark|start)(?:\s(\w+))?(?:\s(\d+))?$"
			script="xset_to_mark"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias  match="^xset gqalias$"
			script="xset_gqalias"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias  match="^xset vidblain$"
			script="xset_vidblain"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias  match="^xset vidblain level(?: (?<level>\d{1,3}))?$"
			script="xset_vidblain_setlevel"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias  match="^xset speed ?(?<speed>run|walk)?$"
			script="set_speed"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset sendecho$"
			script=""
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset kw$"
		script="set_mob_keyword"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset kw (?<keyword>.+)$"
		script="set_current_mob_keyword"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset nx$"
		script="xset_nx_check"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset nx (?<action>smartscan|con|scan|scanhere|qs|none)$"
		script="xset_nx"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias  match="^xset con_overwrite"
		script="xset_con_overwrite"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset sound$"
		script="xset_sound"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset table notes$"
		script="xset_table_notes"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset table width (?<width>\d{2,3})$"
		script="xset_table_width"
		enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- xset window commands -->
	<alias	match="^xset fontsize.*$"
			script="deprecated_xset_font_size"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset linespace.*$"
			script="deprecated_xset_line_space"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset winreset$"
			script="xg_create_window"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" >
				<send>	win_init = false	</send> </alias>

	<alias	match="^xset (?:window|win) (?<onoff>on|off|show|hide|0|1|true|false|max(?:imize)?|expand|min(?:imize)?|collapse)$"
			script="xset_ToggleWindowDisplay"
			enabled="y" regexp="y" sequence="100" > </alias>

	<alias	match="^(?:xw|xwh|xwhere)( (?<n1>\d+))?( (?<n2>\d+))?( (?<mob>.+))?$"
			script="do_xwhere"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^(?:xg|xgui) (?:ref|refresh)$"
			script="xgui_RefreshLinks"
			enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>

	<alias	match="^(?:xg|xgui) (?:rel|reload)$"
			script="xgui_ReloadLinks"
			enabled="y" regexp="y" sequence="100" ignore_case="y" > </alias>

<!-- xset page size (area index process) -->
	<alias	match="^xset suspend page size$"
			script="suspend_page_size"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xset resume page size$"
			script="resume_page_size"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- xtest commands -->
	<alias  match="^xtest areadata$"
			script="xtest_areadata"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest mcvars$"
			script="xtest_mcvars"
			enabled="y" regexp="y" sequence="100" > </alias>

	<alias	match="^xtest roomhist$"
			script="xtest_roomhist"
			enabled="y" regexp="y" sequence="100" > </alias>

	<alias	match="^xtest simulate cp(?: (?<type>area|room))?$"
			script="simulate_cp"
			enabled="y" regexp="y" sequence="1" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest simulate level (?<level>\d{1,3})$"
			script="spoof_level"
			enabled="y" regexp="y" sequence="1" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest simulate q(?:uest)?(?: (?<status>start|status|killed|comp|fail|reset|ready|timeout|statkilled|wait|ready))?$"
			script="simulate_quest"
			enabled="y" regexp="y" sequence="1" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest debug gq(uest)?$"
			script="xtest_debug_gquest"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest simulate gq wait(?: (?<num>\d{1,5}))?$"
			script="xtest_gq_waiting"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest simulate gq start(?: (?<type>area|room))?(?: (?<num>\d{1,5}))?$"
			script="xtest_gq_start"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest simulate gq join (?<num>\d{1,5})(?: (?<silent>s))?$"
			script="xtest_gq_join"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest simulate gq end(?: (?<num>\d{1,5}))?$"
			script="xtest_gq_end"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest simulate gq win(?: (?<num>\d{1,5}))?$"
			script="xtest_gq_win"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest simulate gq lose(?: (?<num>\d{1,5}))?(?<noextend> noextended)$"
			script="xtest_gq_lose"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest simulate gq kill(?: (?<num>\d+))?$"
			script="xtest_gq_kill"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest simulate gq quit(?: (?<num>\d{1,5}))?$"
			script="xtest_gq_quit"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest simulate xcp(?: (?<num>\d+))?$"
			script="xtest_xcp"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias  match="^xtest gqid$"
			script="echo_gqid_joined"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest loadroom(?: (?<roomid>\d+))?$"
			script="xtest_loadroom"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest popmsg$"
			script="xtest_popmsg"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest debug$"
			script="xtest_debug"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest qt (?<qt>\d{1,2})$"
			script="xtest_set_qt"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias	match="^xtest target$"
			script="xtest_print_target"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias  match="^snd reload$"
			script="sndReload"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

<!-- New commands -->
	<alias	match="^x?m(?:ob)?s(?:earch)? ([\p{P}\w]+)(?:\s([^0-9]+))?(?:\s+(\d+))?$"
			script="onSearch"
			group="Mob_Database"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias 	match="^x?mgo(?:to)? (\d+)$"
			script="mobGo"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias 	match="^(snd migrate|mergePwar)$"
			script="copyPwarWarn"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias 	match="^(snd migrate|mergePwar) confirm$"
			script="copyPwarDB"
			enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>


	<alias	match="snd changelog"
			enabled="y" sequence="100" ignore_case="y" send_to="12" >
			<send>get_changelog(true)</send> </alias>
</aliases>
</muclient>
